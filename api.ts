/* tslint:disable */
/* eslint-disable */
/**
 * Trieve API
 * Trieve OpenAPI Specification. This document describes all of the operations available through the Trieve API.
 *
 * The version of the OpenAPI document: 0.12.0
 * Contact: developers@trieve.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const APIVersion = {
    V1: 'V1',
    V2: 'V2'
} as const;

export type APIVersion = typeof APIVersion[keyof typeof APIVersion];


/**
 * 
 * @export
 * @interface AddChunkToGroupReqPayload
 */
export interface AddChunkToGroupReqPayload {
    /**
     * Id of the chunk to make a member of the group.
     * @type {string}
     * @memberof AddChunkToGroupReqPayload
     */
    'chunk_id'?: string | null;
    /**
     * Tracking Id of the chunk to make a member of the group.
     * @type {string}
     * @memberof AddChunkToGroupReqPayload
     */
    'chunk_tracking_id'?: string | null;
}
/**
 * 
 * @export
 * @interface AddToCart
 */
export interface AddToCart {
    /**
     * The name of the event
     * @type {string}
     * @memberof AddToCart
     */
    'event_name': string;
    /**
     * 
     * @type {string}
     * @memberof AddToCart
     */
    'event_type': AddToCartEventTypeEnum;
    /**
     * Whether the event is a conversion event
     * @type {boolean}
     * @memberof AddToCart
     */
    'is_conversion'?: boolean | null;
    /**
     * The items that were added to the cart
     * @type {Array<string>}
     * @memberof AddToCart
     */
    'items': Array<string>;
    /**
     * Any other metadata associated with the event
     * @type {any}
     * @memberof AddToCart
     */
    'metadata'?: any | null;
    /**
     * 
     * @type {RequestInfo}
     * @memberof AddToCart
     */
    'request'?: RequestInfo | null;
    /**
     * The user id of the user who added the items to the cart
     * @type {string}
     * @memberof AddToCart
     */
    'user_id'?: string | null;
}

export const AddToCartEventTypeEnum = {
    AddToCart: 'add_to_cart'
} as const;

export type AddToCartEventTypeEnum = typeof AddToCartEventTypeEnum[keyof typeof AddToCartEventTypeEnum];

/**
 * 
 * @export
 * @interface ApiKeyRespBody
 */
export interface ApiKeyRespBody {
    /**
     * 
     * @type {string}
     * @memberof ApiKeyRespBody
     */
    'created_at': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiKeyRespBody
     */
    'dataset_ids'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyRespBody
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyRespBody
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiKeyRespBody
     */
    'organization_ids'?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof ApiKeyRespBody
     */
    'role': number;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyRespBody
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyRespBody
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface AuthQuery
 */
export interface AuthQuery {
    /**
     * Code sent via email as a result of successful call to send_invitation
     * @type {string}
     * @memberof AuthQuery
     */
    'inv_code'?: string | null;
    /**
     * ID of organization to authenticate into
     * @type {string}
     * @memberof AuthQuery
     */
    'organization_id'?: string | null;
    /**
     * URL to redirect to after successful login
     * @type {string}
     * @memberof AuthQuery
     */
    'redirect_uri'?: string | null;
}
/**
 * 
 * @export
 * @interface AutocompleteReqPayload
 */
export interface AutocompleteReqPayload {
    /**
     * Set content_only to true to only returning the chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typically 10-50ms). Default is false.
     * @type {boolean}
     * @memberof AutocompleteReqPayload
     */
    'content_only'?: boolean | null;
    /**
     * If specified to true, this will extend the search results to include non-exact prefix matches of the same search_type such that a full page_size of results are returned. Default is false.
     * @type {boolean}
     * @memberof AutocompleteReqPayload
     */
    'extend_results'?: boolean | null;
    /**
     * 
     * @type {ChunkFilter}
     * @memberof AutocompleteReqPayload
     */
    'filters'?: ChunkFilter | null;
    /**
     * 
     * @type {HighlightOptions}
     * @memberof AutocompleteReqPayload
     */
    'highlight_options'?: HighlightOptions | null;
    /**
     * Page size is the number of chunks to fetch. This can be used to fetch more than 10 chunks at a time.
     * @type {number}
     * @memberof AutocompleteReqPayload
     */
    'page_size'?: number | null;
    /**
     * Query is the search query. This can be any string. The query will be used to create an embedding vector and/or SPLADE vector which will be used to find the result set.
     * @type {string}
     * @memberof AutocompleteReqPayload
     */
    'query': string;
    /**
     * If true, stop words (specified in server/src/stop-words.txt in the git repo) will be removed. Queries that are entirely stop words will be preserved.
     * @type {boolean}
     * @memberof AutocompleteReqPayload
     */
    'remove_stop_words'?: boolean | null;
    /**
     * Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.
     * @type {number}
     * @memberof AutocompleteReqPayload
     */
    'score_threshold'?: number | null;
    /**
     * 
     * @type {ScoringOptions}
     * @memberof AutocompleteReqPayload
     */
    'scoring_options'?: ScoringOptions | null;
    /**
     * 
     * @type {SearchMethod}
     * @memberof AutocompleteReqPayload
     */
    'search_type': SearchMethod;
    /**
     * Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typically 10-50ms). Default is false.
     * @type {boolean}
     * @memberof AutocompleteReqPayload
     */
    'slim_chunks'?: boolean | null;
    /**
     * 
     * @type {SortOptions}
     * @memberof AutocompleteReqPayload
     */
    'sort_options'?: SortOptions | null;
    /**
     * 
     * @type {TypoOptions}
     * @memberof AutocompleteReqPayload
     */
    'typo_options'?: TypoOptions | null;
    /**
     * If true, quoted and - prefixed words will be parsed from the queries and used as required and negated words respectively. Default is false.
     * @type {boolean}
     * @memberof AutocompleteReqPayload
     */
    'use_quote_negated_terms'?: boolean | null;
    /**
     * User ID is the id of the user who is making the request. This is used to track user interactions with the search results.
     * @type {string}
     * @memberof AutocompleteReqPayload
     */
    'user_id'?: string | null;
}


/**
 * 
 * @export
 * @interface BatchQueuedChunkResponse
 */
export interface BatchQueuedChunkResponse {
    /**
     * 
     * @type {Array<ChunkMetadata>}
     * @memberof BatchQueuedChunkResponse
     */
    'chunk_metadata': Array<ChunkMetadata>;
    /**
     * The current position the last access item is in the queue
     * @type {number}
     * @memberof BatchQueuedChunkResponse
     */
    'pos_in_queue': number;
}
/**
 * 
 * @export
 * @interface BulkDeleteChunkPayload
 */
export interface BulkDeleteChunkPayload {
    /**
     * 
     * @type {ChunkFilter}
     * @memberof BulkDeleteChunkPayload
     */
    'filter': ChunkFilter;
}
/**
 * @type CTRAnalytics
 * @export
 */
export type CTRAnalytics = RecommendationCTRMetrics1 | RecommendationsWithClicks | RecommendationsWithoutClicks | SearchCTRMetrics1 | SearchesWithClicks | SearchesWithoutClicks;

/**
 * @type CTRAnalyticsResponse
 * @export
 */
export type CTRAnalyticsResponse = CTRRecommendationsWithClicksResponse | CTRRecommendationsWithoutClicksResponse | CTRSearchQueryWithClicksResponse | CTRSearchQueryWithoutClicksResponse | RecommendationCTRMetrics | SearchCTRMetrics;

/**
 * 
 * @export
 * @interface CTRDataRequestBody
 */
export interface CTRDataRequestBody {
    /**
     * The ID of chunk that was clicked
     * @type {string}
     * @memberof CTRDataRequestBody
     */
    'clicked_chunk_id'?: string | null;
    /**
     * The tracking ID of the chunk that was clicked
     * @type {string}
     * @memberof CTRDataRequestBody
     */
    'clicked_chunk_tracking_id'?: string | null;
    /**
     * 
     * @type {CTRType}
     * @memberof CTRDataRequestBody
     */
    'ctr_type': CTRType;
    /**
     * Any metadata you want to include with the event i.e. action, user_id, etc.
     * @type {any}
     * @memberof CTRDataRequestBody
     */
    'metadata'?: any | null;
    /**
     * The position of the clicked chunk
     * @type {number}
     * @memberof CTRDataRequestBody
     */
    'position': number;
    /**
     * The request id for the CTR data
     * @type {string}
     * @memberof CTRDataRequestBody
     */
    'request_id': string;
}


/**
 * 
 * @export
 * @interface CTRRecommendationsWithClicksResponse
 */
export interface CTRRecommendationsWithClicksResponse {
    /**
     * 
     * @type {Array<RecommendationsWithClicksCTRResponse>}
     * @memberof CTRRecommendationsWithClicksResponse
     */
    'recommendations': Array<RecommendationsWithClicksCTRResponse>;
}
/**
 * 
 * @export
 * @interface CTRRecommendationsWithoutClicksResponse
 */
export interface CTRRecommendationsWithoutClicksResponse {
    /**
     * 
     * @type {Array<RecommendationsWithoutClicksCTRResponse>}
     * @memberof CTRRecommendationsWithoutClicksResponse
     */
    'recommendations': Array<RecommendationsWithoutClicksCTRResponse>;
}
/**
 * 
 * @export
 * @interface CTRSearchQueryWithClicksResponse
 */
export interface CTRSearchQueryWithClicksResponse {
    /**
     * 
     * @type {Array<SearchQueriesWithClicksCTRResponse>}
     * @memberof CTRSearchQueryWithClicksResponse
     */
    'queries': Array<SearchQueriesWithClicksCTRResponse>;
}
/**
 * 
 * @export
 * @interface CTRSearchQueryWithoutClicksResponse
 */
export interface CTRSearchQueryWithoutClicksResponse {
    /**
     * 
     * @type {Array<SearchQueriesWithoutClicksCTRResponse>}
     * @memberof CTRSearchQueryWithoutClicksResponse
     */
    'queries': Array<SearchQueriesWithoutClicksCTRResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CTRType = {
    Search: 'search',
    Rag: 'rag',
    Recommendation: 'recommendation'
} as const;

export type CTRType = typeof CTRType[keyof typeof CTRType];


/**
 * 
 * @export
 * @interface ChatMessageProxy
 */
export interface ChatMessageProxy {
    /**
     * 
     * @type {string}
     * @memberof ChatMessageProxy
     */
    'content': string;
    /**
     * 
     * @type {RoleProxy}
     * @memberof ChatMessageProxy
     */
    'role': RoleProxy;
}


/**
 * Filters is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata.
 * @export
 * @interface ChunkFilter
 */
export interface ChunkFilter {
    /**
     * JOSNB prefilter tells the server to perform a full scan over the metadata JSONB column instead of using the filtered HNSW. Datasets on the enterprise plan with custom metadata indices will perform better with the filtered HNSW instead. When false, the server will use the filtered HNSW index to filter chunks. When true, the server will perform a full scan over the metadata JSONB column to filter chunks. Default is true.
     * @type {boolean}
     * @memberof ChunkFilter
     */
    'jsonb_prefilter'?: boolean | null;
    /**
     * All of these field conditions have to match for the chunk to be included in the result set.
     * @type {Array<ConditionType>}
     * @memberof ChunkFilter
     */
    'must'?: Array<ConditionType> | null;
    /**
     * None of these field conditions can match for the chunk to be included in the result set.
     * @type {Array<ConditionType>}
     * @memberof ChunkFilter
     */
    'must_not'?: Array<ConditionType> | null;
    /**
     * Only one of these field conditions has to match for the chunk to be included in the result set.
     * @type {Array<ConditionType>}
     * @memberof ChunkFilter
     */
    'should'?: Array<ConditionType> | null;
}
/**
 * 
 * @export
 * @interface ChunkGroup
 */
export interface ChunkGroup {
    /**
     * 
     * @type {string}
     * @memberof ChunkGroup
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroup
     */
    'dataset_id': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroup
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroup
     */
    'id': string;
    /**
     * 
     * @type {any}
     * @memberof ChunkGroup
     */
    'metadata'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroup
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChunkGroup
     */
    'tag_set'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroup
     */
    'tracking_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroup
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface ChunkGroupAndFileId
 */
export interface ChunkGroupAndFileId {
    /**
     * 
     * @type {string}
     * @memberof ChunkGroupAndFileId
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroupAndFileId
     */
    'dataset_id': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroupAndFileId
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroupAndFileId
     */
    'file_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroupAndFileId
     */
    'id': string;
    /**
     * 
     * @type {any}
     * @memberof ChunkGroupAndFileId
     */
    'metadata'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroupAndFileId
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChunkGroupAndFileId
     */
    'tag_set'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroupAndFileId
     */
    'tracking_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroupAndFileId
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface ChunkMetadata
 */
export interface ChunkMetadata {
    /**
     * HTML content of the chunk, can also be an arbitrary string which is not HTML
     * @type {string}
     * @memberof ChunkMetadata
     */
    'chunk_html'?: string | null;
    /**
     * Timestamp of the creation of the chunk
     * @type {string}
     * @memberof ChunkMetadata
     */
    'created_at': string;
    /**
     * ID of the dataset which the chunk belongs to
     * @type {string}
     * @memberof ChunkMetadata
     */
    'dataset_id': string;
    /**
     * Unique identifier of the chunk, auto-generated uuid created by Trieve
     * @type {string}
     * @memberof ChunkMetadata
     */
    'id': string;
    /**
     * Image URLs of the chunk, can be any list of strings. Used for image search and RAG.
     * @type {Array<string>}
     * @memberof ChunkMetadata
     */
    'image_urls'?: Array<string> | null;
    /**
     * Link to the chunk, should be a URL
     * @type {string}
     * @memberof ChunkMetadata
     */
    'link'?: string | null;
    /**
     * 
     * @type {GeoInfo}
     * @memberof ChunkMetadata
     */
    'location'?: GeoInfo | null;
    /**
     * Metadata of the chunk, can be any JSON object
     * @type {any}
     * @memberof ChunkMetadata
     */
    'metadata'?: any | null;
    /**
     * Numeric value of the chunk, can be any float. Can represent the most relevant numeric value of the chunk, such as a price, quantity in stock, rating, etc.
     * @type {number}
     * @memberof ChunkMetadata
     */
    'num_value'?: number | null;
    /**
     * Tag set of the chunk, can be any list of strings. Used for tag-filtered searches.
     * @type {Array<string>}
     * @memberof ChunkMetadata
     */
    'tag_set'?: Array<string> | null;
    /**
     * Timestamp of the chunk, can be any timestamp. Specified by the user.
     * @type {string}
     * @memberof ChunkMetadata
     */
    'time_stamp'?: string | null;
    /**
     * Tracking ID of the chunk, can be any string, determined by the user. Tracking ID\'s are unique identifiers for chunks within a dataset. They are designed to match the unique identifier of the chunk in the user\'s system.
     * @type {string}
     * @memberof ChunkMetadata
     */
    'tracking_id'?: string | null;
    /**
     * Timestamp of the last update of the chunk
     * @type {string}
     * @memberof ChunkMetadata
     */
    'updated_at': string;
    /**
     * Weight of the chunk, can be any float. Used as a multiplier on a chunk\'s relevance score for ranking purposes.
     * @type {number}
     * @memberof ChunkMetadata
     */
    'weight': number;
}
/**
 * 
 * @export
 * @interface ChunkMetadataStringTagSet
 */
export interface ChunkMetadataStringTagSet {
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataStringTagSet
     */
    'chunk_html'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataStringTagSet
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataStringTagSet
     */
    'dataset_id': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataStringTagSet
     */
    'id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChunkMetadataStringTagSet
     */
    'image_urls'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataStringTagSet
     */
    'link'?: string | null;
    /**
     * 
     * @type {GeoInfo}
     * @memberof ChunkMetadataStringTagSet
     */
    'location'?: GeoInfo | null;
    /**
     * 
     * @type {any}
     * @memberof ChunkMetadataStringTagSet
     */
    'metadata'?: any | null;
    /**
     * 
     * @type {number}
     * @memberof ChunkMetadataStringTagSet
     */
    'num_value'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataStringTagSet
     */
    'tag_set'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataStringTagSet
     */
    'time_stamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataStringTagSet
     */
    'tracking_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataStringTagSet
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof ChunkMetadataStringTagSet
     */
    'weight': number;
}
/**
 * @type ChunkMetadataTypes
 * @export
 */
export type ChunkMetadataTypes = ChunkMetadataStringTagSet | ContentChunkMetadata | SlimChunkMetadata;

/**
 * 
 * @export
 * @interface ChunkMetadataWithPosition
 */
export interface ChunkMetadataWithPosition {
    /**
     * 
     * @type {ChunkMetadata}
     * @memberof ChunkMetadataWithPosition
     */
    'chunk': ChunkMetadata;
    /**
     * 
     * @type {number}
     * @memberof ChunkMetadataWithPosition
     */
    'position': number;
}
/**
 * 
 * @export
 * @interface ChunkMetadataWithScore
 */
export interface ChunkMetadataWithScore {
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataWithScore
     */
    'chunk_html'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataWithScore
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataWithScore
     */
    'dataset_id': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataWithScore
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataWithScore
     */
    'link'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof ChunkMetadataWithScore
     */
    'metadata'?: any | null;
    /**
     * 
     * @type {number}
     * @memberof ChunkMetadataWithScore
     */
    'score': number;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataWithScore
     */
    'tag_set'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataWithScore
     */
    'time_stamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataWithScore
     */
    'tracking_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataWithScore
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof ChunkMetadataWithScore
     */
    'weight': number;
}
/**
 * Request payload for creating a new chunk
 * @export
 * @interface ChunkReqPayload
 */
export interface ChunkReqPayload {
    /**
     * HTML content of the chunk. This can also be plaintext. The innerText of the HTML will be used to create the embedding vector. The point of using HTML is for convienience, as some users have applications where users submit HTML content.
     * @type {string}
     * @memberof ChunkReqPayload
     */
    'chunk_html'?: string | null;
    /**
     * Convert HTML to raw text before processing to avoid adding noise to the vector embeddings. By default this is true. If you are using HTML content that you want to be included in the vector embeddings, set this to false.
     * @type {boolean}
     * @memberof ChunkReqPayload
     */
    'convert_html_to_text'?: boolean | null;
    /**
     * 
     * @type {FullTextBoost}
     * @memberof ChunkReqPayload
     */
    'fulltext_boost'?: FullTextBoost | null;
    /**
     * Group ids are the Trieve generated ids of the groups that the chunk should be placed into. This is useful for when you want to create a chunk and add it to a group or multiple groups in one request. Groups with these Trieve generated ids must be created first, it cannot be arbitrarily created through this route.
     * @type {Array<string>}
     * @memberof ChunkReqPayload
     */
    'group_ids'?: Array<string> | null;
    /**
     * Group tracking_ids are the user-assigned tracking_ids of the groups that the chunk should be placed into. This is useful for when you want to create a chunk and add it to a group or multiple groups in one request. If a group with the tracking_id does not exist, it will be created.
     * @type {Array<string>}
     * @memberof ChunkReqPayload
     */
    'group_tracking_ids'?: Array<string> | null;
    /**
     * Image urls are a list of urls to images that are associated with the chunk. This is useful for when you want to associate images with a chunk.
     * @type {Array<string>}
     * @memberof ChunkReqPayload
     */
    'image_urls'?: Array<string> | null;
    /**
     * Link to the chunk. This can also be any string. Frequently, this is a link to the source of the chunk. The link value will not affect the embedding creation.
     * @type {string}
     * @memberof ChunkReqPayload
     */
    'link'?: string | null;
    /**
     * 
     * @type {GeoInfo}
     * @memberof ChunkReqPayload
     */
    'location'?: GeoInfo | null;
    /**
     * Metadata is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata.
     * @type {any}
     * @memberof ChunkReqPayload
     */
    'metadata'?: any | null;
    /**
     * Num value is an arbitrary numerical value that can be used to filter chunks. This is useful for when you want to filter chunks by numerical value. There is no performance hit for filtering on num_value.
     * @type {number}
     * @memberof ChunkReqPayload
     */
    'num_value'?: number | null;
    /**
     * 
     * @type {SemanticBoost}
     * @memberof ChunkReqPayload
     */
    'semantic_boost'?: SemanticBoost | null;
    /**
     * If semantic_content is present, it will be used for creating semantic embeddings instead of the innerText `chunk_html`. `chunk_html` will still be the only thing stored and always used for fulltext functionality.
     * @type {string}
     * @memberof ChunkReqPayload
     */
    'semantic_content'?: string | null;
    /**
     * Split avg is a boolean which tells the server to split the text in the chunk_html into smaller chunks and average their resulting vectors. This is useful for when you want to create a chunk from a large piece of text and want to split it into smaller chunks to create a more fuzzy average dense vector. The sparse vector will be generated normally with no averaging. By default this is false.
     * @type {boolean}
     * @memberof ChunkReqPayload
     */
    'split_avg'?: boolean | null;
    /**
     * Tag set is a list of tags. This can be used to filter chunks by tag. Unlike with metadata filtering, HNSW indices will exist for each tag such that there is not a performance hit for filtering on them.
     * @type {Array<string>}
     * @memberof ChunkReqPayload
     */
    'tag_set'?: Array<string> | null;
    /**
     * Time_stamp should be an ISO 8601 combined date and time without timezone. It is used for time window filtering and recency-biasing search results.
     * @type {string}
     * @memberof ChunkReqPayload
     */
    'time_stamp'?: string | null;
    /**
     * Tracking_id is a string which can be used to identify a chunk. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk.
     * @type {string}
     * @memberof ChunkReqPayload
     */
    'tracking_id'?: string | null;
    /**
     * Upsert when a chunk with the same tracking_id exists. By default this is false, and the request will fail if a chunk with the same tracking_id exists. If this is true, the chunk will be updated if a chunk with the same tracking_id exists.
     * @type {boolean}
     * @memberof ChunkReqPayload
     */
    'upsert_by_tracking_id'?: boolean | null;
    /**
     * Weight is a float which can be used to bias search results. This is useful for when you want to bias search results for a chunk. The magnitude only matters relative to other chunks in the chunk\'s dataset dataset.
     * @type {number}
     * @memberof ChunkReqPayload
     */
    'weight'?: number | null;
}
/**
 * @type ChunkReturnTypes
 * @export
 */
export type ChunkReturnTypes = ChunkMetadata | ChunkMetadataStringTagSet;

/**
 * 
 * @export
 * @interface ChunkWithPosition
 */
export interface ChunkWithPosition {
    /**
     * 
     * @type {string}
     * @memberof ChunkWithPosition
     */
    'chunk_id': string;
    /**
     * 
     * @type {number}
     * @memberof ChunkWithPosition
     */
    'position': number;
}
/**
 * 
 * @export
 * @interface Click
 */
export interface Click {
    /**
     * 
     * @type {ChunkWithPosition}
     * @memberof Click
     */
    'clicked_items': ChunkWithPosition;
    /**
     * The name of the event
     * @type {string}
     * @memberof Click
     */
    'event_name': string;
    /**
     * 
     * @type {string}
     * @memberof Click
     */
    'event_type': ClickEventTypeEnum;
    /**
     * Whether the event is a conversion event
     * @type {boolean}
     * @memberof Click
     */
    'is_conversion'?: boolean | null;
    /**
     * 
     * @type {RequestInfo}
     * @memberof Click
     */
    'request'?: RequestInfo | null;
    /**
     * The user id of the user who clicked the items
     * @type {string}
     * @memberof Click
     */
    'user_id'?: string | null;
}

export const ClickEventTypeEnum = {
    Click: 'click'
} as const;

export type ClickEventTypeEnum = typeof ClickEventTypeEnum[keyof typeof ClickEventTypeEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const ClickhouseRagTypes = {
    ChosenChunks: 'chosen_chunks',
    AllChunks: 'all_chunks'
} as const;

export type ClickhouseRagTypes = typeof ClickhouseRagTypes[keyof typeof ClickhouseRagTypes];


/**
 * 
 * @export
 * @enum {string}
 */

export const ClickhouseRecommendationTypes = {
    Chunk: 'Chunk',
    Group: 'Group'
} as const;

export type ClickhouseRecommendationTypes = typeof ClickhouseRecommendationTypes[keyof typeof ClickhouseRecommendationTypes];


/**
 * 
 * @export
 * @enum {string}
 */

export const ClickhouseSearchTypes = {
    Search: 'search',
    SearchOverGroups: 'search_over_groups',
    Autocomplete: 'autocomplete',
    Rag: 'rag'
} as const;

export type ClickhouseSearchTypes = typeof ClickhouseSearchTypes[keyof typeof ClickhouseSearchTypes];


/**
 * 
 * @export
 * @interface CloneTopicReqPayload
 */
export interface CloneTopicReqPayload {
    /**
     * The name of the topic. If this is not provided, the topic name is the same as the previous topic
     * @type {string}
     * @memberof CloneTopicReqPayload
     */
    'name'?: string | null;
    /**
     * The owner_id of the topic. This is typically a browser fingerprint or your user\'s id. It is used to group topics together for a user.
     * @type {string}
     * @memberof CloneTopicReqPayload
     */
    'owner_id': string;
    /**
     * The topic_id to clone from
     * @type {string}
     * @memberof CloneTopicReqPayload
     */
    'topic_id': string;
}
/**
 * @type ClusterAnalytics
 * @export
 */
export type ClusterAnalytics = ClusterQueries | ClusterTopics;

/**
 * 
 * @export
 * @interface ClusterAnalyticsFilter
 */
export interface ClusterAnalyticsFilter {
    /**
     * 
     * @type {DateRange}
     * @memberof ClusterAnalyticsFilter
     */
    'date_range'?: DateRange | null;
}
/**
 * @type ClusterAnalyticsResponse
 * @export
 */
export type ClusterAnalyticsResponse = SearchClusterResponse | SearchQueryResponse;

/**
 * 
 * @export
 * @interface ClusterQueries
 */
export interface ClusterQueries {
    /**
     * 
     * @type {string}
     * @memberof ClusterQueries
     */
    'cluster_id': string;
    /**
     * 
     * @type {number}
     * @memberof ClusterQueries
     */
    'page'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ClusterQueries
     */
    'type': ClusterQueriesTypeEnum;
}

export const ClusterQueriesTypeEnum = {
    ClusterQueries: 'cluster_queries'
} as const;

export type ClusterQueriesTypeEnum = typeof ClusterQueriesTypeEnum[keyof typeof ClusterQueriesTypeEnum];

/**
 * 
 * @export
 * @interface ClusterTopics
 */
export interface ClusterTopics {
    /**
     * 
     * @type {ClusterAnalyticsFilter}
     * @memberof ClusterTopics
     */
    'filter'?: ClusterAnalyticsFilter | null;
    /**
     * 
     * @type {string}
     * @memberof ClusterTopics
     */
    'type': ClusterTopicsTypeEnum;
}

export const ClusterTopicsTypeEnum = {
    ClusterTopics: 'cluster_topics'
} as const;

export type ClusterTopicsTypeEnum = typeof ClusterTopicsTypeEnum[keyof typeof ClusterTopicsTypeEnum];

/**
 * @type ConditionType
 * @export
 */
export type ConditionType = FieldCondition | HasIDCondition;

/**
 * 
 * @export
 * @interface ContentChunkMetadata
 */
export interface ContentChunkMetadata {
    /**
     * 
     * @type {string}
     * @memberof ContentChunkMetadata
     */
    'chunk_html'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContentChunkMetadata
     */
    'id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContentChunkMetadata
     */
    'image_urls'?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof ContentChunkMetadata
     */
    'num_value'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ContentChunkMetadata
     */
    'time_stamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContentChunkMetadata
     */
    'tracking_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ContentChunkMetadata
     */
    'weight': number;
}
/**
 * Context options to use for the completion. If not specified, all options will default to false.
 * @export
 * @interface ContextOptions
 */
export interface ContextOptions {
    /**
     * Include links in the context. If not specified, this defaults to false.
     * @type {boolean}
     * @memberof ContextOptions
     */
    'include_links'?: boolean | null;
}
/**
 * 
 * @export
 * @interface CountChunkQueryResponseBody
 */
export interface CountChunkQueryResponseBody {
    /**
     * 
     * @type {number}
     * @memberof CountChunkQueryResponseBody
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface CountChunksReqPayload
 */
export interface CountChunksReqPayload {
    /**
     * 
     * @type {ChunkFilter}
     * @memberof CountChunksReqPayload
     */
    'filters'?: ChunkFilter | null;
    /**
     * Set limit to restrict the maximum number of chunks to count. This is useful for when you want to reduce the latency of the count operation. By default the limit will be the number of chunks in the dataset.
     * @type {number}
     * @memberof CountChunksReqPayload
     */
    'limit'?: number | null;
    /**
     * 
     * @type {QueryTypes}
     * @memberof CountChunksReqPayload
     */
    'query': QueryTypes;
    /**
     * Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.
     * @type {number}
     * @memberof CountChunksReqPayload
     */
    'score_threshold'?: number | null;
    /**
     * 
     * @type {CountSearchMethod}
     * @memberof CountChunksReqPayload
     */
    'search_type': CountSearchMethod;
    /**
     * If true, quoted and - prefixed words will be parsed from the queries and used as required and negated words respectively. Default is false.
     * @type {boolean}
     * @memberof CountChunksReqPayload
     */
    'use_quote_negated_terms'?: boolean | null;
}


/**
 * 
 * @export
 * @interface CountQueries
 */
export interface CountQueries {
    /**
     * 
     * @type {SearchAnalyticsFilter}
     * @memberof CountQueries
     */
    'filter'?: SearchAnalyticsFilter | null;
    /**
     * 
     * @type {string}
     * @memberof CountQueries
     */
    'type': CountQueriesTypeEnum;
}

export const CountQueriesTypeEnum = {
    CountQueries: 'count_queries'
} as const;

export type CountQueriesTypeEnum = typeof CountQueriesTypeEnum[keyof typeof CountQueriesTypeEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const CountSearchMethod = {
    Fulltext: 'fulltext',
    Semantic: 'semantic',
    Bm25: 'bm25'
} as const;

export type CountSearchMethod = typeof CountSearchMethod[keyof typeof CountSearchMethod];


/**
 * Interval at which specified site should be re-scraped
 * @export
 * @enum {string}
 */

export const CrawlInterval = {
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly'
} as const;

export type CrawlInterval = typeof CrawlInterval[keyof typeof CrawlInterval];


/**
 * Options for including an openapi spec in the crawl
 * @export
 * @interface CrawlOpenAPIOptions
 */
export interface CrawlOpenAPIOptions {
    /**
     * OpenAPI json schema to be processed alongside the site crawl
     * @type {string}
     * @memberof CrawlOpenAPIOptions
     */
    'openapi_schema_url': string;
    /**
     * Tag to look for to determine if a page should create an openapi route chunk instead of chunks from heading-split of the HTML
     * @type {string}
     * @memberof CrawlOpenAPIOptions
     */
    'openapi_tag': string;
}
/**
 * Options for setting up the crawl which will populate the dataset.
 * @export
 * @interface CrawlOptions
 */
export interface CrawlOptions {
    /**
     * Option for allowing the crawl to follow links to external websites.
     * @type {boolean}
     * @memberof CrawlOptions
     */
    'allow_external_links'?: boolean | null;
    /**
     * Text strings to remove from body when creating chunks for each page
     * @type {Array<string>}
     * @memberof CrawlOptions
     */
    'body_remove_strings'?: Array<string> | null;
    /**
     * Boost titles such that keyword matches in titles are prioritized in search results. Strongly recommended to leave this on. Defaults to true.
     * @type {boolean}
     * @memberof CrawlOptions
     */
    'boost_titles'?: boolean | null;
    /**
     * URL Patterns to exclude from the crawl
     * @type {Array<string>}
     * @memberof CrawlOptions
     */
    'exclude_paths'?: Array<string> | null;
    /**
     * Specify the HTML tags, classes and ids to exclude from the response.
     * @type {Array<string>}
     * @memberof CrawlOptions
     */
    'exclude_tags'?: Array<string> | null;
    /**
     * Text strings to remove from headings when creating chunks for each page
     * @type {Array<string>}
     * @memberof CrawlOptions
     */
    'heading_remove_strings'?: Array<string> | null;
    /**
     * Ignore the website sitemap when crawling, defaults to true.
     * @type {boolean}
     * @memberof CrawlOptions
     */
    'ignore_sitemap'?: boolean | null;
    /**
     * URL Patterns to include in the crawl
     * @type {Array<string>}
     * @memberof CrawlOptions
     */
    'include_paths'?: Array<string> | null;
    /**
     * Specify the HTML tags, classes and ids to include in the response.
     * @type {Array<string>}
     * @memberof CrawlOptions
     */
    'include_tags'?: Array<string> | null;
    /**
     * 
     * @type {CrawlInterval}
     * @memberof CrawlOptions
     */
    'interval'?: CrawlInterval | null;
    /**
     * How many pages to crawl, defaults to 1000
     * @type {number}
     * @memberof CrawlOptions
     */
    'limit'?: number | null;
    /**
     * 
     * @type {ScrapeOptions}
     * @memberof CrawlOptions
     */
    'scrape_options'?: ScrapeOptions | null;
    /**
     * The URL to crawl
     * @type {string}
     * @memberof CrawlOptions
     */
    'site_url'?: string | null;
}


/**
 * Options for Crawling Shopify
 * @export
 * @interface CrawlShopifyOptions
 */
export interface CrawlShopifyOptions {
    /**
     * This option will ingest all variants as individual chunks and place them in groups by product id. Turning this off will only scrape 1 variant per product. default: true
     * @type {boolean}
     * @memberof CrawlShopifyOptions
     */
    'group_variants'?: boolean | null;
}
/**
 * @type CreateChunkGroupReqPayloadEnum
 * @export
 */
export type CreateChunkGroupReqPayloadEnum = Array<CreateSingleChunkGroupReqPayload> | CreateSingleChunkGroupReqPayload;

/**
 * @type CreateChunkGroupResponseEnum
 * @export
 */
export type CreateChunkGroupResponseEnum = Array<ChunkGroup> | ChunkGroup;

/**
 * @type CreateChunkReqPayloadEnum
 * @export
 */
export type CreateChunkReqPayloadEnum = Array<ChunkReqPayload> | ChunkReqPayload;

/**
 * 
 * @export
 * @interface CreateDatasetRequest
 */
export interface CreateDatasetRequest {
    /**
     * 
     * @type {CrawlOptions}
     * @memberof CreateDatasetRequest
     */
    'crawl_options'?: CrawlOptions | null;
    /**
     * Name of the dataset.
     * @type {string}
     * @memberof CreateDatasetRequest
     */
    'dataset_name': string;
    /**
     * 
     * @type {DatasetConfigurationDTO}
     * @memberof CreateDatasetRequest
     */
    'server_configuration'?: DatasetConfigurationDTO | null;
    /**
     * Optional tracking ID for the dataset. Can be used to track the dataset in external systems. Must be unique within the organization. Strongly recommended to not use a valid uuid value as that will not work with the TR-Dataset header.
     * @type {string}
     * @memberof CreateDatasetRequest
     */
    'tracking_id'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateMessageReqPayload
 */
export interface CreateMessageReqPayload {
    /**
     * If concat user messages query is set to true, all of the user messages in the topic will be concatenated together and used as the search query. If not specified, this defaults to false. Default is false.
     * @type {boolean}
     * @memberof CreateMessageReqPayload
     */
    'concat_user_messages_query'?: boolean | null;
    /**
     * 
     * @type {ContextOptions}
     * @memberof CreateMessageReqPayload
     */
    'context_options'?: ContextOptions | null;
    /**
     * 
     * @type {ChunkFilter}
     * @memberof CreateMessageReqPayload
     */
    'filters'?: ChunkFilter | null;
    /**
     * 
     * @type {HighlightOptions}
     * @memberof CreateMessageReqPayload
     */
    'highlight_options'?: HighlightOptions | null;
    /**
     * 
     * @type {LLMOptions}
     * @memberof CreateMessageReqPayload
     */
    'llm_options'?: LLMOptions | null;
    /**
     * The content of the user message to attach to the topic and then generate an assistant message in response to.
     * @type {string}
     * @memberof CreateMessageReqPayload
     */
    'new_message_content': string;
    /**
     * Page size is the number of chunks to fetch during RAG. If 0, then no search will be performed. If specified, this will override the N retrievals to include in the dataset configuration. Default is None.
     * @type {number}
     * @memberof CreateMessageReqPayload
     */
    'page_size'?: number | null;
    /**
     * Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.
     * @type {number}
     * @memberof CreateMessageReqPayload
     */
    'score_threshold'?: number | null;
    /**
     * Query is the search query. This can be any string. The search_query will be used to create a dense embedding vector and/or sparse vector which will be used to find the result set. If not specified, will default to the last user message or HyDE if HyDE is enabled in the dataset configuration. Default is None.
     * @type {string}
     * @memberof CreateMessageReqPayload
     */
    'search_query'?: string | null;
    /**
     * 
     * @type {SearchMethod}
     * @memberof CreateMessageReqPayload
     */
    'search_type'?: SearchMethod | null;
    /**
     * The ID of the topic to attach the message to.
     * @type {string}
     * @memberof CreateMessageReqPayload
     */
    'topic_id': string;
    /**
     * If use_group_search is set to true, the search will be conducted using the `search_over_groups` api. If not specified, this defaults to false.
     * @type {boolean}
     * @memberof CreateMessageReqPayload
     */
    'use_group_search'?: boolean | null;
    /**
     * The user_id is the id of the user who is making the request. This is used to track user interactions with the RAG results.
     * @type {string}
     * @memberof CreateMessageReqPayload
     */
    'user_id'?: string | null;
}


/**
 * 
 * @export
 * @interface CreateOrganizationReqPayload
 */
export interface CreateOrganizationReqPayload {
    /**
     * The arbitrary name which will be used to identify the organization. This name must be unique.
     * @type {string}
     * @memberof CreateOrganizationReqPayload
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateSetupCheckoutSessionResPayload
 */
export interface CreateSetupCheckoutSessionResPayload {
    /**
     * 
     * @type {string}
     * @memberof CreateSetupCheckoutSessionResPayload
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface CreateSingleChunkGroupReqPayload
 */
export interface CreateSingleChunkGroupReqPayload {
    /**
     * Description to assign to the chunk_group. Convenience field for you to avoid having to remember what the group is for.
     * @type {string}
     * @memberof CreateSingleChunkGroupReqPayload
     */
    'description'?: string | null;
    /**
     * Optional metadata to assign to the chunk_group. This is a JSON object that can store any additional information you want to associate with the chunks inside of the chunk_group.
     * @type {any}
     * @memberof CreateSingleChunkGroupReqPayload
     */
    'metadata'?: any | null;
    /**
     * Name to assign to the chunk_group. Does not need to be unique.
     * @type {string}
     * @memberof CreateSingleChunkGroupReqPayload
     */
    'name'?: string | null;
    /**
     * Optional tags to assign to the chunk_group. This is a list of strings that can be used to categorize the chunks inside the chunk_group.
     * @type {Array<string>}
     * @memberof CreateSingleChunkGroupReqPayload
     */
    'tag_set'?: Array<string> | null;
    /**
     * Optional tracking id to assign to the chunk_group. This is a unique identifier for the chunk_group.
     * @type {string}
     * @memberof CreateSingleChunkGroupReqPayload
     */
    'tracking_id'?: string | null;
    /**
     * Upsert when a chunk_group with the same tracking_id exists. By default this is false, and the request will fail if a chunk_group with the same tracking_id exists. If this is true, the chunk_group will be updated if a chunk_group with the same tracking_id exists.
     * @type {boolean}
     * @memberof CreateSingleChunkGroupReqPayload
     */
    'upsert_by_tracking_id'?: boolean | null;
}
/**
 * 
 * @export
 * @interface CreateTopicReqPayload
 */
export interface CreateTopicReqPayload {
    /**
     * The first message which will belong to the topic. The topic name is generated based on this message similar to how it works in the OpenAI chat UX if a name is not explicitly provided on the name request body key.
     * @type {string}
     * @memberof CreateTopicReqPayload
     */
    'first_user_message'?: string | null;
    /**
     * The name of the topic. If this is not provided, the topic name is generated from the first_user_message.
     * @type {string}
     * @memberof CreateTopicReqPayload
     */
    'name'?: string | null;
    /**
     * The owner_id of the topic. This is typically a browser fingerprint or your user\'s id. It is used to group topics together for a user.
     * @type {string}
     * @memberof CreateTopicReqPayload
     */
    'owner_id': string;
}
/**
 * 
 * @export
 * @interface Dataset
 */
export interface Dataset {
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof Dataset
     */
    'deleted': number;
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    'organization_id': string;
    /**
     * 
     * @type {any}
     * @memberof Dataset
     */
    'server_configuration': any;
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    'tracking_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface DatasetAnalytics
 */
export interface DatasetAnalytics {
    /**
     * 
     * @type {number}
     * @memberof DatasetAnalytics
     */
    'avg_latency': number;
    /**
     * 
     * @type {number}
     * @memberof DatasetAnalytics
     */
    'p50': number;
    /**
     * 
     * @type {number}
     * @memberof DatasetAnalytics
     */
    'p95': number;
    /**
     * 
     * @type {number}
     * @memberof DatasetAnalytics
     */
    'p99': number;
    /**
     * 
     * @type {number}
     * @memberof DatasetAnalytics
     */
    'search_rps': number;
    /**
     * 
     * @type {number}
     * @memberof DatasetAnalytics
     */
    'total_queries': number;
}
/**
 * 
 * @export
 * @interface DatasetAndUsage
 */
export interface DatasetAndUsage {
    /**
     * 
     * @type {DatasetDTO}
     * @memberof DatasetAndUsage
     */
    'dataset': DatasetDTO;
    /**
     * 
     * @type {DatasetUsageCount}
     * @memberof DatasetAndUsage
     */
    'dataset_usage': DatasetUsageCount;
}
/**
 * Lets you specify the configuration for a dataset
 * @export
 * @interface DatasetConfigurationDTO
 */
export interface DatasetConfigurationDTO {
    /**
     * The average length of the chunks in the index for BM25
     * @type {number}
     * @memberof DatasetConfigurationDTO
     */
    'BM25_AVG_LEN'?: number | null;
    /**
     * The BM25 B parameter
     * @type {number}
     * @memberof DatasetConfigurationDTO
     */
    'BM25_B'?: number | null;
    /**
     * Whether to use BM25
     * @type {boolean}
     * @memberof DatasetConfigurationDTO
     */
    'BM25_ENABLED'?: boolean | null;
    /**
     * The BM25 K parameter
     * @type {number}
     * @memberof DatasetConfigurationDTO
     */
    'BM25_K'?: number | null;
    /**
     * 
     * @type {DistanceMetric}
     * @memberof DatasetConfigurationDTO
     */
    'DISTANCE_METRIC'?: DistanceMetric | null;
    /**
     * The base URL for the embedding API
     * @type {string}
     * @memberof DatasetConfigurationDTO
     */
    'EMBEDDING_BASE_URL'?: string | null;
    /**
     * The name of the embedding model to use
     * @type {string}
     * @memberof DatasetConfigurationDTO
     */
    'EMBEDDING_MODEL_NAME'?: string | null;
    /**
     * The prefix to use for the embedding query
     * @type {string}
     * @memberof DatasetConfigurationDTO
     */
    'EMBEDDING_QUERY_PREFIX'?: string | null;
    /**
     * The size of the embeddings
     * @type {number}
     * @memberof DatasetConfigurationDTO
     */
    'EMBEDDING_SIZE'?: number | null;
    /**
     * The frequency penalty to use
     * @type {number}
     * @memberof DatasetConfigurationDTO
     */
    'FREQUENCY_PENALTY'?: number | null;
    /**
     * Whether to use fulltext search
     * @type {boolean}
     * @memberof DatasetConfigurationDTO
     */
    'FULLTEXT_ENABLED'?: boolean | null;
    /**
     * Whether to only use indexed chunks
     * @type {boolean}
     * @memberof DatasetConfigurationDTO
     */
    'INDEXED_ONLY'?: boolean | null;
    /**
     * The base URL for the LLM API
     * @type {string}
     * @memberof DatasetConfigurationDTO
     */
    'LLM_BASE_URL'?: string | null;
    /**
     * The default model to use for the LLM
     * @type {string}
     * @memberof DatasetConfigurationDTO
     */
    'LLM_DEFAULT_MODEL'?: string | null;
    /**
     * Whether the dataset is locked to prevent changes or deletion
     * @type {boolean}
     * @memberof DatasetConfigurationDTO
     */
    'LOCKED'?: boolean | null;
    /**
     * The maximum limit for the number of chunks for counting
     * @type {number}
     * @memberof DatasetConfigurationDTO
     */
    'MAX_LIMIT'?: number | null;
    /**
     * The maximum number of tokens to use in LLM Response
     * @type {number}
     * @memberof DatasetConfigurationDTO
     */
    'MAX_TOKENS'?: number | null;
    /**
     * The prompt to use for converting a message to a query
     * @type {string}
     * @memberof DatasetConfigurationDTO
     */
    'MESSAGE_TO_QUERY_PROMPT'?: string | null;
    /**
     * The number of retrievals to include with the RAG model
     * @type {number}
     * @memberof DatasetConfigurationDTO
     */
    'N_RETRIEVALS_TO_INCLUDE'?: number | null;
    /**
     * The presence penalty to use
     * @type {number}
     * @memberof DatasetConfigurationDTO
     */
    'PRESENCE_PENALTY'?: number | null;
    /**
     * 
     * @type {PublicDatasetOptions}
     * @memberof DatasetConfigurationDTO
     */
    'PUBLIC_DATASET'?: PublicDatasetOptions | null;
    /**
     * The prompt to use for the RAG model
     * @type {string}
     * @memberof DatasetConfigurationDTO
     */
    'RAG_PROMPT'?: string | null;
    /**
     * The base URL for the reranker API
     * @type {string}
     * @memberof DatasetConfigurationDTO
     */
    'RERANKER_BASE_URL'?: string | null;
    /**
     * Whether to use semantic search
     * @type {boolean}
     * @memberof DatasetConfigurationDTO
     */
    'SEMANTIC_ENABLED'?: boolean | null;
    /**
     * The stop tokens to use
     * @type {Array<string>}
     * @memberof DatasetConfigurationDTO
     */
    'STOP_TOKENS'?: Array<string> | null;
    /**
     * The system prompt to use for the LLM
     * @type {string}
     * @memberof DatasetConfigurationDTO
     */
    'SYSTEM_PROMPT'?: string | null;
    /**
     * The temperature to use
     * @type {number}
     * @memberof DatasetConfigurationDTO
     */
    'TEMPERATURE'?: number | null;
    /**
     * Whether to use the message to query prompt
     * @type {boolean}
     * @memberof DatasetConfigurationDTO
     */
    'USE_MESSAGE_TO_QUERY_PROMPT'?: boolean | null;
}


/**
 * 
 * @export
 * @interface DatasetDTO
 */
export interface DatasetDTO {
    /**
     * 
     * @type {string}
     * @memberof DatasetDTO
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DatasetDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DatasetDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DatasetDTO
     */
    'organization_id': string;
    /**
     * 
     * @type {string}
     * @memberof DatasetDTO
     */
    'tracking_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DatasetDTO
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface DatasetUsageCount
 */
export interface DatasetUsageCount {
    /**
     * 
     * @type {number}
     * @memberof DatasetUsageCount
     */
    'chunk_count': number;
    /**
     * 
     * @type {string}
     * @memberof DatasetUsageCount
     */
    'dataset_id': string;
    /**
     * 
     * @type {string}
     * @memberof DatasetUsageCount
     */
    'id': string;
}
/**
 * DateRange is a JSON object which can be used to filter chunks by a range of dates. This leverages the time_stamp field on chunks in your dataset. You can specify this if you want values in a certain range. You must provide ISO 8601 combined date and time without timezone.
 * @export
 * @interface DateRange
 */
export interface DateRange {
    /**
     * 
     * @type {string}
     * @memberof DateRange
     */
    'gt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DateRange
     */
    'gte'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DateRange
     */
    'lt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DateRange
     */
    'lte'?: string | null;
}
/**
 * 
 * @export
 * @interface DeleteTopicData
 */
export interface DeleteTopicData {
    /**
     * The id of the topic to target.
     * @type {string}
     * @memberof DeleteTopicData
     */
    'topic_id': string;
}
/**
 * 
 * @export
 * @interface DeleteUserApiKeyRequest
 */
export interface DeleteUserApiKeyRequest {
    /**
     * The id of the api key to delete.
     * @type {string}
     * @memberof DeleteUserApiKeyRequest
     */
    'api_key_id': string;
}
/**
 * 
 * @export
 * @interface DeprecatedSearchOverGroupsResponseBody
 */
export interface DeprecatedSearchOverGroupsResponseBody {
    /**
     * 
     * @type {string}
     * @memberof DeprecatedSearchOverGroupsResponseBody
     */
    'corrected_query'?: string | null;
    /**
     * 
     * @type {Array<GroupScoreChunk>}
     * @memberof DeprecatedSearchOverGroupsResponseBody
     */
    'group_chunks': Array<GroupScoreChunk>;
    /**
     * 
     * @type {number}
     * @memberof DeprecatedSearchOverGroupsResponseBody
     */
    'total_chunk_pages': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DistanceMetric = {
    Euclidean: 'euclidean',
    Cosine: 'cosine',
    Manhattan: 'manhattan',
    Dot: 'dot'
} as const;

export type DistanceMetric = typeof DistanceMetric[keyof typeof DistanceMetric];


/**
 * 
 * @export
 * @interface EditMessageReqPayload
 */
export interface EditMessageReqPayload {
    /**
     * If concat user messages query is set to true, all of the user messages in the topic will be concatenated together and used as the search query. If not specified, this defaults to false. Default is false.
     * @type {boolean}
     * @memberof EditMessageReqPayload
     */
    'concat_user_messages_query'?: boolean | null;
    /**
     * 
     * @type {ContextOptions}
     * @memberof EditMessageReqPayload
     */
    'context_options'?: ContextOptions | null;
    /**
     * 
     * @type {ChunkFilter}
     * @memberof EditMessageReqPayload
     */
    'filters'?: ChunkFilter | null;
    /**
     * 
     * @type {HighlightOptions}
     * @memberof EditMessageReqPayload
     */
    'highlight_options'?: HighlightOptions | null;
    /**
     * 
     * @type {LLMOptions}
     * @memberof EditMessageReqPayload
     */
    'llm_options'?: LLMOptions | null;
    /**
     * The sort order of the message to edit.
     * @type {number}
     * @memberof EditMessageReqPayload
     */
    'message_sort_order': number;
    /**
     * The new content of the message to replace the old content with.
     * @type {string}
     * @memberof EditMessageReqPayload
     */
    'new_message_content': string;
    /**
     * Page size is the number of chunks to fetch during RAG. If 0, then no search will be performed. If specified, this will override the N retrievals to include in the dataset configuration. Default is None.
     * @type {number}
     * @memberof EditMessageReqPayload
     */
    'page_size'?: number | null;
    /**
     * Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.
     * @type {number}
     * @memberof EditMessageReqPayload
     */
    'score_threshold'?: number | null;
    /**
     * Query is the search query. This can be any string. The search_query will be used to create a dense embedding vector and/or sparse vector which will be used to find the result set. If not specified, will default to the last user message or HyDE if HyDE is enabled in the dataset configuration. Default is None.
     * @type {string}
     * @memberof EditMessageReqPayload
     */
    'search_query'?: string | null;
    /**
     * 
     * @type {SearchMethod}
     * @memberof EditMessageReqPayload
     */
    'search_type'?: SearchMethod | null;
    /**
     * The id of the topic to edit the message at the given sort order for.
     * @type {string}
     * @memberof EditMessageReqPayload
     */
    'topic_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof EditMessageReqPayload
     */
    'use_group_search'?: boolean | null;
    /**
     * The user_id is the id of the user who is making the request. This is used to track user interactions with the RAG results.
     * @type {string}
     * @memberof EditMessageReqPayload
     */
    'user_id'?: string | null;
}


/**
 * 
 * @export
 * @interface ErrorResponseBody
 */
export interface ErrorResponseBody {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseBody
     */
    'message': string;
}
/**
 * Filter to apply to the events when querying for them
 * @export
 * @interface EventAnalyticsFilter
 */
export interface EventAnalyticsFilter {
    /**
     * 
     * @type {DateRange}
     * @memberof EventAnalyticsFilter
     */
    'date_range'?: DateRange | null;
    /**
     * 
     * @type {EventTypesFilter}
     * @memberof EventAnalyticsFilter
     */
    'event_type'?: EventTypesFilter | null;
    /**
     * Filter by conversions
     * @type {boolean}
     * @memberof EventAnalyticsFilter
     */
    'is_conversion'?: boolean | null;
    /**
     * Filter by metadata path i.e. path.attribute = \\\"value\\\"
     * @type {string}
     * @memberof EventAnalyticsFilter
     */
    'metadata_filter'?: string | null;
    /**
     * Filter by user ID
     * @type {string}
     * @memberof EventAnalyticsFilter
     */
    'user_id'?: string | null;
}


/**
 * EventData represents a single analytics event
 * @export
 * @interface EventData
 */
export interface EventData {
    /**
     * The time the event was created.
     * @type {string}
     * @memberof EventData
     */
    'created_at': string;
    /**
     * The unique identifier for the dataset the event is associated with.
     * @type {string}
     * @memberof EventData
     */
    'dataset_id': string;
    /**
     * The name of the event, e.g. \"Added to Cart\", \"Purchased\", \"Viewed Home Page\", \"Clicked\", \"Filter Clicked\".
     * @type {string}
     * @memberof EventData
     */
    'event_name': string;
    /**
     * The type of event, \"add_to_cart\", \"purchase\", \"view\", \"click\", \"filter_clicked\".
     * @type {string}
     * @memberof EventData
     */
    'event_type': string;
    /**
     * The unique identifier for the event
     * @type {string}
     * @memberof EventData
     */
    'id': string;
    /**
     * Whether the event is a conversion event.
     * @type {boolean}
     * @memberof EventData
     */
    'is_conversion'?: boolean | null;
    /**
     * The items associated with the event. This could be a list of stringified json chunks for search events, or a list of items for add_to_cart, purchase, view, and click events.
     * @type {Array<string>}
     * @memberof EventData
     */
    'items': Array<string>;
    /**
     * Additional metadata associated with the event. This can be custom data that is specific to the event.
     * @type {any}
     * @memberof EventData
     */
    'metadata'?: any | null;
    /**
     * The unique identifier for the request the event is associated with.
     * @type {string}
     * @memberof EventData
     */
    'request_id'?: string | null;
    /**
     * The type of request the event is associated with.
     * @type {string}
     * @memberof EventData
     */
    'request_type'?: string | null;
    /**
     * The time the event was last updated.
     * @type {string}
     * @memberof EventData
     */
    'updated_at': string;
    /**
     * The user identifier associated with the event.
     * @type {string}
     * @memberof EventData
     */
    'user_id'?: string | null;
}
/**
 * 
 * @export
 * @interface EventReturn
 */
export interface EventReturn {
    /**
     * 
     * @type {Array<string>}
     * @memberof EventReturn
     */
    'event_types': Array<string>;
    /**
     * 
     * @type {Array<WorkerEvent>}
     * @memberof EventReturn
     */
    'events': Array<WorkerEvent>;
    /**
     * 
     * @type {number}
     * @memberof EventReturn
     */
    'page_count': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EventTypeRequest = {
    FileUploaded: 'file_uploaded',
    FileUploadFailed: 'file_upload_failed',
    ChunksUploaded: 'chunks_uploaded',
    ChunkActionFailed: 'chunk_action_failed',
    ChunkUpdated: 'chunk_updated',
    BulkChunksDeleted: 'bulk_chunks_deleted',
    DatasetDeleteFailed: 'dataset_delete_failed',
    QdrantUploadFailed: 'qdrant_upload_failed',
    BulkChunkUploadFailed: 'bulk_chunk_upload_failed',
    GroupChunksUpdated: 'group_chunks_updated',
    GroupChunksActionFailed: 'group_chunks_action_failed',
    CrawlCompleted: 'crawl_completed',
    CrawlFailed: 'crawl_failed'
} as const;

export type EventTypeRequest = typeof EventTypeRequest[keyof typeof EventTypeRequest];


/**
 * @type EventTypes
 * @export
 */
export type EventTypes = AddToCart | Click | FilterClicked | Purchase | RAG | Recommendation | Search | View;

/**
 * 
 * @export
 * @enum {string}
 */

export const EventTypesFilter = {
    AddToCart: 'add_to_cart',
    Purchase: 'purchase',
    View: 'view',
    Click: 'click',
    FilterClicked: 'filter_clicked'
} as const;

export type EventTypesFilter = typeof EventTypesFilter[keyof typeof EventTypesFilter];


/**
 * 
 * @export
 * @interface FieldCondition
 */
export interface FieldCondition {
    /**
     * 
     * @type {DateRange}
     * @memberof FieldCondition
     */
    'date_range'?: DateRange | null;
    /**
     * Field is the name of the field to filter on. The field value will be used to check for an exact substring match on the metadata values for each existing chunk. This is useful for when you want to filter chunks by arbitrary metadata. To access fields inside of the metadata that you provide with the card, prefix the field name with `metadata.`.
     * @type {string}
     * @memberof FieldCondition
     */
    'field': string;
    /**
     * 
     * @type {LocationBoundingBox}
     * @memberof FieldCondition
     */
    'geo_bounding_box'?: LocationBoundingBox | null;
    /**
     * 
     * @type {LocationPolygon}
     * @memberof FieldCondition
     */
    'geo_polygon'?: LocationPolygon | null;
    /**
     * 
     * @type {LocationRadius}
     * @memberof FieldCondition
     */
    'geo_radius'?: LocationRadius | null;
    /**
     * Match all lets you pass in an array of values that will return results if all of the items match. The match value will be used to check for an exact substring match on the metadata values for each existing chunk. If both match_all and match_any are provided, the match_any condition will be used.
     * @type {Array<MatchCondition>}
     * @memberof FieldCondition
     */
    'match_all'?: Array<MatchCondition> | null;
    /**
     * Match any lets you pass in an array of values that will return results if any of the items match. The match value will be used to check for an exact substring match on the metadata values for each existing chunk. If both match_all and match_any are provided, the match_any condition will be used.
     * @type {Array<MatchCondition>}
     * @memberof FieldCondition
     */
    'match_any'?: Array<MatchCondition> | null;
    /**
     * 
     * @type {Range}
     * @memberof FieldCondition
     */
    'range'?: Range | null;
}
/**
 * 
 * @export
 * @interface FileDTO
 */
export interface FileDTO {
    /**
     * 
     * @type {string}
     * @memberof FileDTO
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof FileDTO
     */
    'file_name': string;
    /**
     * 
     * @type {string}
     * @memberof FileDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FileDTO
     */
    'link'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof FileDTO
     */
    'metadata'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof FileDTO
     */
    's3_url': string;
    /**
     * 
     * @type {number}
     * @memberof FileDTO
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof FileDTO
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface FilterClicked
 */
export interface FilterClicked {
    /**
     * The name of the event
     * @type {string}
     * @memberof FilterClicked
     */
    'event_name': string;
    /**
     * 
     * @type {string}
     * @memberof FilterClicked
     */
    'event_type': FilterClickedEventTypeEnum;
    /**
     * Whether the event is a conversion event
     * @type {boolean}
     * @memberof FilterClicked
     */
    'is_conversion'?: boolean | null;
    /**
     * The filter items that were clicked in a hashmap ie. {filter_name: filter_value} where filter_name is filter_type::field_name
     * @type {{ [key: string]: string; }}
     * @memberof FilterClicked
     */
    'items': { [key: string]: string; };
    /**
     * 
     * @type {RequestInfo}
     * @memberof FilterClicked
     */
    'request'?: RequestInfo | null;
    /**
     * The user id of the user who clicked the items
     * @type {string}
     * @memberof FilterClicked
     */
    'user_id'?: string | null;
}

export const FilterClickedEventTypeEnum = {
    FilterClicked: 'filter_clicked'
} as const;

export type FilterClickedEventTypeEnum = typeof FilterClickedEventTypeEnum[keyof typeof FilterClickedEventTypeEnum];

/**
 * Boost the presence of certain tokens for fulltext (SPLADE) and keyword (BM25) search. I.e. boosting title phrases to priortize title matches or making sure that the listing for AirBNB itself ranks higher than companies who make software for AirBNB hosts by boosting the in-document-frequency of the AirBNB token (AKA word) for its official listing. Conceptually it multiples the in-document-importance second value in the tuples of the SPLADE or BM25 sparse vector of the chunk_html innerText for all tokens present in the boost phrase by the boost factor like so: (token, in-document-importance) -> (token, in-document-importance*boost_factor).
 * @export
 * @interface FullTextBoost
 */
export interface FullTextBoost {
    /**
     * Amount to multiplicatevly increase the frequency of the tokens in the phrase by
     * @type {number}
     * @memberof FullTextBoost
     */
    'boost_factor': number;
    /**
     * The phrase to boost in the fulltext document frequency index
     * @type {string}
     * @memberof FullTextBoost
     */
    'phrase': string;
}
/**
 * 
 * @export
 * @interface GenerateOffChunksReqPayload
 */
export interface GenerateOffChunksReqPayload {
    /**
     * The ids of the chunks to be retrieved and injected into the context window for RAG.
     * @type {Array<string>}
     * @memberof GenerateOffChunksReqPayload
     */
    'chunk_ids': Array<string>;
    /**
     * 
     * @type {ContextOptions}
     * @memberof GenerateOffChunksReqPayload
     */
    'context_options'?: ContextOptions | null;
    /**
     * Frequency penalty is a number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model\'s likelihood to repeat the same line verbatim. Default is 0.7.
     * @type {number}
     * @memberof GenerateOffChunksReqPayload
     */
    'frequency_penalty'?: number | null;
    /**
     * Set highlight_results to false for a slight latency improvement (1-10ms). If not specified, this defaults to true. This will add `<mark><b>` tags to the chunk_html of the chunks to highlight matching splits.
     * @type {boolean}
     * @memberof GenerateOffChunksReqPayload
     */
    'highlight_results'?: boolean | null;
    /**
     * 
     * @type {ImageConfig}
     * @memberof GenerateOffChunksReqPayload
     */
    'image_config'?: ImageConfig | null;
    /**
     * The maximum number of tokens to generate in the chat completion. Default is None.
     * @type {number}
     * @memberof GenerateOffChunksReqPayload
     */
    'max_tokens'?: number | null;
    /**
     * Presence penalty is a number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model\'s likelihood to talk about new topics. Default is 0.7.
     * @type {number}
     * @memberof GenerateOffChunksReqPayload
     */
    'presence_penalty'?: number | null;
    /**
     * The previous messages to be placed into the chat history. There must be at least one previous message.
     * @type {Array<ChatMessageProxy>}
     * @memberof GenerateOffChunksReqPayload
     */
    'prev_messages': Array<ChatMessageProxy>;
    /**
     * Prompt will be used to tell the model what to generate in the next message in the chat. The default is \'Respond to the previous instruction and include the doc numbers that you used in square brackets at the end of the sentences that you used the docs for:\'. You can also specify an empty string to leave the final message alone such that your user\'s final message can be used as the prompt. See docs.trieve.ai or contact us for more information.
     * @type {string}
     * @memberof GenerateOffChunksReqPayload
     */
    'prompt'?: string | null;
    /**
     * Stop tokens are up to 4 sequences where the API will stop generating further tokens. Default is None.
     * @type {Array<string>}
     * @memberof GenerateOffChunksReqPayload
     */
    'stop_tokens'?: Array<string> | null;
    /**
     * Whether or not to stream the response. If this is set to true or not included, the response will be a stream. If this is set to false, the response will be a normal JSON response. Default is true.
     * @type {boolean}
     * @memberof GenerateOffChunksReqPayload
     */
    'stream_response'?: boolean | null;
    /**
     * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. Default is 0.5.
     * @type {number}
     * @memberof GenerateOffChunksReqPayload
     */
    'temperature'?: number | null;
    /**
     * User ID is the id of the user who is making the request. This is used to track user interactions with the RAG results.
     * @type {string}
     * @memberof GenerateOffChunksReqPayload
     */
    'user_id'?: string | null;
}
/**
 * Location that you want to use as the center of the search.
 * @export
 * @interface GeoInfo
 */
export interface GeoInfo {
    /**
     * 
     * @type {GeoTypes}
     * @memberof GeoInfo
     */
    'lat': GeoTypes;
    /**
     * 
     * @type {GeoTypes}
     * @memberof GeoInfo
     */
    'lon': GeoTypes;
}
/**
 * Location bias lets you rank your results by distance from a location. If not specified, this has no effect. Bias allows you to determine how much of an effect the location of chunks will have on the search results. If not specified, this defaults to 0.0. We recommend setting this to 1.0 for a gentle reranking of the results, >3.0 for a strong reranking of the results.
 * @export
 * @interface GeoInfoWithBias
 */
export interface GeoInfoWithBias {
    /**
     * Bias lets you specify how much of an effect the location of chunks will have on the search results. If not specified, this defaults to 0.0. We recommend setting this to 1.0 for a gentle reranking of the results, >3.0 for a strong reranking of the results.
     * @type {number}
     * @memberof GeoInfoWithBias
     */
    'bias': number;
    /**
     * 
     * @type {GeoInfo}
     * @memberof GeoInfoWithBias
     */
    'location': GeoInfo;
}
/**
 * @type GeoTypes
 * @export
 */
export type GeoTypes = number;

/**
 * 
 * @export
 * @interface GetAllTagsReqPayload
 */
export interface GetAllTagsReqPayload {
    /**
     * Page number to return, 1-indexed. Default is 1.
     * @type {number}
     * @memberof GetAllTagsReqPayload
     */
    'page'?: number | null;
    /**
     * Number of items to return per page. Default is 20.
     * @type {number}
     * @memberof GetAllTagsReqPayload
     */
    'page_size'?: number | null;
}
/**
 * 
 * @export
 * @interface GetAllTagsResponse
 */
export interface GetAllTagsResponse {
    /**
     * 
     * @type {Array<TagsWithCount>}
     * @memberof GetAllTagsResponse
     */
    'tags': Array<TagsWithCount>;
    /**
     * 
     * @type {number}
     * @memberof GetAllTagsResponse
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface GetChunksData
 */
export interface GetChunksData {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetChunksData
     */
    'ids': Array<string>;
}
/**
 * @type GetChunksInGroupResponse
 * @export
 */
export type GetChunksInGroupResponse = GetChunksInGroupsResponseBody | GroupsBookmarkQueryResult;

/**
 * 
 * @export
 * @interface GetChunksInGroupsResponseBody
 */
export interface GetChunksInGroupsResponseBody {
    /**
     * 
     * @type {Array<ChunkMetadata>}
     * @memberof GetChunksInGroupsResponseBody
     */
    'chunks': Array<ChunkMetadata>;
    /**
     * 
     * @type {ChunkGroupAndFileId}
     * @memberof GetChunksInGroupsResponseBody
     */
    'group': ChunkGroupAndFileId;
    /**
     * 
     * @type {number}
     * @memberof GetChunksInGroupsResponseBody
     */
    'total_pages': number;
}
/**
 * 
 * @export
 * @interface GetCrawlOptionsResponse
 */
export interface GetCrawlOptionsResponse {
    /**
     * 
     * @type {CrawlOptions}
     * @memberof GetCrawlOptionsResponse
     */
    'crawl_options'?: CrawlOptions | null;
}
/**
 * 
 * @export
 * @interface GetDatasetsPagination
 */
export interface GetDatasetsPagination {
    /**
     * 
     * @type {number}
     * @memberof GetDatasetsPagination
     */
    'limit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GetDatasetsPagination
     */
    'offset'?: number | null;
}
/**
 * 
 * @export
 * @interface GetEventsData
 */
export interface GetEventsData {
    /**
     * The types of events to get. Leave undefined to get all events.
     * @type {Array<EventTypeRequest>}
     * @memberof GetEventsData
     */
    'event_types'?: Array<EventTypeRequest> | null;
    /**
     * The page number to get. Default is 1.
     * @type {number}
     * @memberof GetEventsData
     */
    'page'?: number | null;
    /**
     * The number of items per page. Default is 10.
     * @type {number}
     * @memberof GetEventsData
     */
    'page_size'?: number | null;
}
/**
 * 
 * @export
 * @interface GetEventsRequestBody
 */
export interface GetEventsRequestBody {
    /**
     * 
     * @type {EventAnalyticsFilter}
     * @memberof GetEventsRequestBody
     */
    'filter'?: EventAnalyticsFilter | null;
    /**
     * Page of results to return
     * @type {number}
     * @memberof GetEventsRequestBody
     */
    'page'?: number | null;
}
/**
 * Response body for the GetEvents endpoint
 * @export
 * @interface GetEventsResponseBody
 */
export interface GetEventsResponseBody {
    /**
     * 
     * @type {Array<EventData>}
     * @memberof GetEventsResponseBody
     */
    'events': Array<EventData>;
}
/**
 * 
 * @export
 * @interface GetGroupsForChunksReqPayload
 */
export interface GetGroupsForChunksReqPayload {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetGroupsForChunksReqPayload
     */
    'chunk_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface GetTopDatasetsRequestBody
 */
export interface GetTopDatasetsRequestBody {
    /**
     * 
     * @type {DateRange}
     * @memberof GetTopDatasetsRequestBody
     */
    'date_range'?: DateRange | null;
    /**
     * 
     * @type {TopDatasetsRequestTypes}
     * @memberof GetTopDatasetsRequestBody
     */
    'type': TopDatasetsRequestTypes;
}


/**
 * 
 * @export
 * @interface GetTrackingChunksData
 */
export interface GetTrackingChunksData {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetTrackingChunksData
     */
    'tracking_ids': Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Granularity = {
    Minute: 'minute',
    Second: 'second',
    Hour: 'hour',
    Day: 'day'
} as const;

export type Granularity = typeof Granularity[keyof typeof Granularity];


/**
 * 
 * @export
 * @interface GroupData
 */
export interface GroupData {
    /**
     * 
     * @type {Array<ChunkGroupAndFileId>}
     * @memberof GroupData
     */
    'groups': Array<ChunkGroupAndFileId>;
    /**
     * 
     * @type {number}
     * @memberof GroupData
     */
    'total_pages': number;
}
/**
 * 
 * @export
 * @interface GroupScoreChunk
 */
export interface GroupScoreChunk {
    /**
     * 
     * @type {string}
     * @memberof GroupScoreChunk
     */
    'file_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GroupScoreChunk
     */
    'group_created_at': string;
    /**
     * 
     * @type {string}
     * @memberof GroupScoreChunk
     */
    'group_dataset_id': string;
    /**
     * 
     * @type {string}
     * @memberof GroupScoreChunk
     */
    'group_description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GroupScoreChunk
     */
    'group_id': string;
    /**
     * 
     * @type {any}
     * @memberof GroupScoreChunk
     */
    'group_metadata'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof GroupScoreChunk
     */
    'group_name'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupScoreChunk
     */
    'group_tag_set'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof GroupScoreChunk
     */
    'group_tracking_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GroupScoreChunk
     */
    'group_updated_at': string;
    /**
     * 
     * @type {Array<ScoreChunkDTO>}
     * @memberof GroupScoreChunk
     */
    'metadata': Array<ScoreChunkDTO>;
}
/**
 * 
 * @export
 * @interface GroupsBookmarkQueryResult
 */
export interface GroupsBookmarkQueryResult {
    /**
     * 
     * @type {Array<ChunkMetadataStringTagSet>}
     * @memberof GroupsBookmarkQueryResult
     */
    'chunks': Array<ChunkMetadataStringTagSet>;
    /**
     * 
     * @type {ChunkGroupAndFileId}
     * @memberof GroupsBookmarkQueryResult
     */
    'group': ChunkGroupAndFileId;
    /**
     * 
     * @type {number}
     * @memberof GroupsBookmarkQueryResult
     */
    'total_pages': number;
}
/**
 * 
 * @export
 * @interface GroupsForChunk
 */
export interface GroupsForChunk {
    /**
     * 
     * @type {string}
     * @memberof GroupsForChunk
     */
    'chunk_uuid': string;
    /**
     * 
     * @type {Array<ChunkGroupAndFileId>}
     * @memberof GroupsForChunk
     */
    'slim_groups': Array<ChunkGroupAndFileId>;
}
/**
 * 
 * @export
 * @interface HasIDCondition
 */
export interface HasIDCondition {
    /**
     * 
     * @type {Array<string>}
     * @memberof HasIDCondition
     */
    'ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof HasIDCondition
     */
    'tracking_ids'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface HeadQueries
 */
export interface HeadQueries {
    /**
     * 
     * @type {number}
     * @memberof HeadQueries
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof HeadQueries
     */
    'query': string;
}
/**
 * 
 * @export
 * @interface HeadQueries1
 */
export interface HeadQueries1 {
    /**
     * 
     * @type {SearchAnalyticsFilter}
     * @memberof HeadQueries1
     */
    'filter'?: SearchAnalyticsFilter | null;
    /**
     * 
     * @type {number}
     * @memberof HeadQueries1
     */
    'page'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof HeadQueries1
     */
    'type': HeadQueries1TypeEnum;
}

export const HeadQueries1TypeEnum = {
    HeadQueries: 'head_queries'
} as const;

export type HeadQueries1TypeEnum = typeof HeadQueries1TypeEnum[keyof typeof HeadQueries1TypeEnum];

/**
 * 
 * @export
 * @interface HeadQueryResponse
 */
export interface HeadQueryResponse {
    /**
     * 
     * @type {Array<HeadQueries>}
     * @memberof HeadQueryResponse
     */
    'queries': Array<HeadQueries>;
}
/**
 * Highlight Options lets you specify different methods to highlight the chunks in the result set. If not specified, this defaults to the score of the chunks.
 * @export
 * @interface HighlightOptions
 */
export interface HighlightOptions {
    /**
     * Set highlight_delimiters to a list of strings to use as delimiters for highlighting. If not specified, this defaults to [\"?\", \",\", \".\", \"!\"]. These are the characters that will be used to split the chunk_html into splits for highlighting. These are the characters that will be used to split the chunk_html into splits for highlighting.
     * @type {Array<string>}
     * @memberof HighlightOptions
     */
    'highlight_delimiters'?: Array<string> | null;
    /**
     * Set highlight_max_length to control the maximum number of tokens (typically whitespace separated strings, but sometimes also word stems) which can be present within a single highlight. If not specified, this defaults to 8. This is useful to shorten large splits which may have low scores due to length compared to the query. Set to something very large like 100 to highlight entire splits.
     * @type {number}
     * @memberof HighlightOptions
     */
    'highlight_max_length'?: number | null;
    /**
     * Set highlight_max_num to control the maximum number of highlights per chunk. If not specified, this defaults to 3. It may be less than 3 if no snippets score above the highlight_threshold.
     * @type {number}
     * @memberof HighlightOptions
     */
    'highlight_max_num'?: number | null;
    /**
     * Set highlight_results to false for a slight latency improvement (1-10ms). If not specified, this defaults to true. This will add `<mark><b>` tags to the chunk_html of the chunks to highlight matching splits and return the highlights on each scored chunk in the response.
     * @type {boolean}
     * @memberof HighlightOptions
     */
    'highlight_results'?: boolean | null;
    /**
     * 
     * @type {HighlightStrategy}
     * @memberof HighlightOptions
     */
    'highlight_strategy'?: HighlightStrategy | null;
    /**
     * Set highlight_threshold to a lower or higher value to adjust the sensitivity of the highlights applied to the chunk html. If not specified, this defaults to 0.8. The range is 0.0 to 1.0.
     * @type {number}
     * @memberof HighlightOptions
     */
    'highlight_threshold'?: number | null;
    /**
     * Set highlight_window to a number to control the amount of words that are returned around the matched phrases. If not specified, this defaults to 0. This is useful for when you want to show more context around the matched words. When specified, window/2 whitespace separated words are added before and after each highlight in the response\'s highlights array. If an extended highlight overlaps with another highlight, the overlapping words are only included once. This parameter can be overriden to respect the highlight_max_length param.
     * @type {number}
     * @memberof HighlightOptions
     */
    'highlight_window'?: number | null;
    /**
     * Custom html tag which should appear after highlights. If not specified, this defaults to \'</mark></b>\'.
     * @type {string}
     * @memberof HighlightOptions
     */
    'post_tag'?: string | null;
    /**
     * Custom html tag which should appear before highlights. If not specified, this defaults to \'<mark><b>\'.
     * @type {string}
     * @memberof HighlightOptions
     */
    'pre_tag'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const HighlightStrategy = {
    Exactmatch: 'exactmatch',
    V1: 'v1'
} as const;

export type HighlightStrategy = typeof HighlightStrategy[keyof typeof HighlightStrategy];


/**
 * Configuration for sending images to the llm
 * @export
 * @interface ImageConfig
 */
export interface ImageConfig {
    /**
     * The number of Images to send to the llm per chunk that is fetched more images may slow down llm inference time. default: 5
     * @type {number}
     * @memberof ImageConfig
     */
    'images_per_chunk'?: number | null;
    /**
     * This sends images to the llm if chunk_metadata.image_urls has some value, the call will error if the model is not a vision LLM model. default: false
     * @type {boolean}
     * @memberof ImageConfig
     */
    'use_images'?: boolean | null;
}
/**
 * 
 * @export
 * @interface Invitation
 */
export interface Invitation {
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    'organization_id': string;
    /**
     * 
     * @type {number}
     * @memberof Invitation
     */
    'role': number;
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    'updated_at': string;
    /**
     * 
     * @type {boolean}
     * @memberof Invitation
     */
    'used': boolean;
}
/**
 * 
 * @export
 * @interface InvitationData
 */
export interface InvitationData {
    /**
     * The url of the app that the user will be directed to in order to set their password. Usually admin.trieve.ai, but may differ for local dev or self-hosted setups.
     * @type {string}
     * @memberof InvitationData
     */
    'app_url': string;
    /**
     * The email of the user to invite. Must be a valid email as they will be sent an email to register.
     * @type {string}
     * @memberof InvitationData
     */
    'email': string;
    /**
     * The url that the user will be redirected to after setting their password.
     * @type {string}
     * @memberof InvitationData
     */
    'redirect_uri': string;
    /**
     * The role the user will have in the organization. 0 = User, 1 = Admin, 2 = Owner.
     * @type {number}
     * @memberof InvitationData
     */
    'user_role': number;
}
/**
 * LLM options to use for the completion. If not specified, this defaults to the dataset\'s LLM options.
 * @export
 * @interface LLMOptions
 */
export interface LLMOptions {
    /**
     * Completion first decides whether the stream should contain the stream of the completion response or the chunks first. Default is false. Keep in mind that || is used to separate the chunks from the completion response. If || is in the completion then you may want to split on ||{ instead.
     * @type {boolean}
     * @memberof LLMOptions
     */
    'completion_first'?: boolean | null;
    /**
     * Frequency penalty is a number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model\'s likelihood to repeat the same line verbatim. Default is 0.7.
     * @type {number}
     * @memberof LLMOptions
     */
    'frequency_penalty'?: number | null;
    /**
     * 
     * @type {ImageConfig}
     * @memberof LLMOptions
     */
    'image_config'?: ImageConfig | null;
    /**
     * The maximum number of tokens to generate in the chat completion. Default is None.
     * @type {number}
     * @memberof LLMOptions
     */
    'max_tokens'?: number | null;
    /**
     * Presence penalty is a number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model\'s likelihood to talk about new topics. Default is 0.7.
     * @type {number}
     * @memberof LLMOptions
     */
    'presence_penalty'?: number | null;
    /**
     * Stop tokens are up to 4 sequences where the API will stop generating further tokens. Default is None.
     * @type {Array<string>}
     * @memberof LLMOptions
     */
    'stop_tokens'?: Array<string> | null;
    /**
     * Whether or not to stream the response. If this is set to true or not included, the response will be a stream. If this is set to false, the response will be a normal JSON response. Default is true.
     * @type {boolean}
     * @memberof LLMOptions
     */
    'stream_response'?: boolean | null;
    /**
     * Optionally, override the system prompt in dataset server settings.
     * @type {string}
     * @memberof LLMOptions
     */
    'system_prompt'?: string | null;
    /**
     * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. Default is 0.5.
     * @type {number}
     * @memberof LLMOptions
     */
    'temperature'?: number | null;
}
/**
 * 
 * @export
 * @interface LatencyGraph
 */
export interface LatencyGraph {
    /**
     * 
     * @type {SearchAnalyticsFilter}
     * @memberof LatencyGraph
     */
    'filter'?: SearchAnalyticsFilter | null;
    /**
     * 
     * @type {Granularity}
     * @memberof LatencyGraph
     */
    'granularity'?: Granularity | null;
    /**
     * 
     * @type {string}
     * @memberof LatencyGraph
     */
    'type': LatencyGraphTypeEnum;
}

export const LatencyGraphTypeEnum = {
    LatencyGraph: 'latency_graph'
} as const;

export type LatencyGraphTypeEnum = typeof LatencyGraphTypeEnum[keyof typeof LatencyGraphTypeEnum];

/**
 * 
 * @export
 * @interface LatencyGraphResponse
 */
export interface LatencyGraphResponse {
    /**
     * 
     * @type {Array<SearchLatencyGraph>}
     * @memberof LatencyGraphResponse
     */
    'latency_points': Array<SearchLatencyGraph>;
}
/**
 * 
 * @export
 * @interface LocationBoundingBox
 */
export interface LocationBoundingBox {
    /**
     * 
     * @type {GeoInfo}
     * @memberof LocationBoundingBox
     */
    'bottom_right': GeoInfo;
    /**
     * 
     * @type {GeoInfo}
     * @memberof LocationBoundingBox
     */
    'top_left': GeoInfo;
}
/**
 * 
 * @export
 * @interface LocationPolygon
 */
export interface LocationPolygon {
    /**
     * 
     * @type {Array<GeoInfo>}
     * @memberof LocationPolygon
     */
    'exterior': Array<GeoInfo>;
    /**
     * 
     * @type {Array<Array<GeoInfo>>}
     * @memberof LocationPolygon
     */
    'interior'?: Array<Array<GeoInfo>> | null;
}
/**
 * 
 * @export
 * @interface LocationRadius
 */
export interface LocationRadius {
    /**
     * 
     * @type {GeoInfo}
     * @memberof LocationRadius
     */
    'center': GeoInfo;
    /**
     * 
     * @type {number}
     * @memberof LocationRadius
     */
    'radius': number;
}
/**
 * 
 * @export
 * @interface LowConfidenceQueries
 */
export interface LowConfidenceQueries {
    /**
     * 
     * @type {SearchAnalyticsFilter}
     * @memberof LowConfidenceQueries
     */
    'filter'?: SearchAnalyticsFilter | null;
    /**
     * 
     * @type {number}
     * @memberof LowConfidenceQueries
     */
    'page'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof LowConfidenceQueries
     */
    'threshold'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof LowConfidenceQueries
     */
    'type': LowConfidenceQueriesTypeEnum;
}

export const LowConfidenceQueriesTypeEnum = {
    LowConfidenceQueries: 'low_confidence_queries'
} as const;

export type LowConfidenceQueriesTypeEnum = typeof LowConfidenceQueriesTypeEnum[keyof typeof LowConfidenceQueriesTypeEnum];

/**
 * 
 * @export
 * @interface LowConfidenceRecommendations
 */
export interface LowConfidenceRecommendations {
    /**
     * 
     * @type {RecommendationAnalyticsFilter}
     * @memberof LowConfidenceRecommendations
     */
    'filter'?: RecommendationAnalyticsFilter | null;
    /**
     * 
     * @type {number}
     * @memberof LowConfidenceRecommendations
     */
    'page'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof LowConfidenceRecommendations
     */
    'threshold'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof LowConfidenceRecommendations
     */
    'type': LowConfidenceRecommendationsTypeEnum;
}

export const LowConfidenceRecommendationsTypeEnum = {
    LowConfidenceRecommendations: 'low_confidence_recommendations'
} as const;

export type LowConfidenceRecommendationsTypeEnum = typeof LowConfidenceRecommendationsTypeEnum[keyof typeof LowConfidenceRecommendationsTypeEnum];

/**
 * @type MatchCondition
 * @export
 */
export type MatchCondition = number | string;

/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {number}
     * @memberof Message
     */
    'completion_tokens'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'dataset_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof Message
     */
    'deleted': boolean;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof Message
     */
    'prompt_tokens'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'role': string;
    /**
     * 
     * @type {number}
     * @memberof Message
     */
    'sort_order': number;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'topic_id': string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'dataset_id': string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'file_name': string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'link'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof ModelFile
     */
    'metadata'?: any | null;
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    'size': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModelFile
     */
    'tag_set'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'time_stamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'updated_at': string;
}
/**
 * MultiQuery allows you to construct a dense vector from multiple queries with a weighted sum. This is useful for when you want to emphasize certain features of the query. This only works with Semantic Search and is not compatible with cross encoder re-ranking or highlights.
 * @export
 * @interface MultiQuery
 */
export interface MultiQuery {
    /**
     * Query to embed for the final weighted sum vector.
     * @type {string}
     * @memberof MultiQuery
     */
    'query': string;
    /**
     * Float value which is applies as a multiplier to the query vector when summing.
     * @type {number}
     * @memberof MultiQuery
     */
    'weight': number;
}
/**
 * @type NewChunkMetadataTypes
 * @export
 */
export type NewChunkMetadataTypes = ChunkMetadata | ContentChunkMetadata | SlimChunkMetadataWithArrayTagSet;

/**
 * 
 * @export
 * @interface NoResultQueries
 */
export interface NoResultQueries {
    /**
     * 
     * @type {SearchAnalyticsFilter}
     * @memberof NoResultQueries
     */
    'filter'?: SearchAnalyticsFilter | null;
    /**
     * 
     * @type {number}
     * @memberof NoResultQueries
     */
    'page'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof NoResultQueries
     */
    'type': NoResultQueriesTypeEnum;
}

export const NoResultQueriesTypeEnum = {
    NoResultQueries: 'no_result_queries'
} as const;

export type NoResultQueriesTypeEnum = typeof NoResultQueriesTypeEnum[keyof typeof NoResultQueriesTypeEnum];

/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof Organization
     */
    'deleted': number;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof Organization
     */
    'registerable'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface OrganizationUsageCount
 */
export interface OrganizationUsageCount {
    /**
     * 
     * @type {number}
     * @memberof OrganizationUsageCount
     */
    'chunk_count': number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationUsageCount
     */
    'dataset_count': number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationUsageCount
     */
    'file_storage': number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUsageCount
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof OrganizationUsageCount
     */
    'message_count': number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUsageCount
     */
    'org_id': string;
    /**
     * 
     * @type {number}
     * @memberof OrganizationUsageCount
     */
    'user_count': number;
}
/**
 * 
 * @export
 * @interface OrganizationWithSubAndPlan
 */
export interface OrganizationWithSubAndPlan {
    /**
     * 
     * @type {Organization}
     * @memberof OrganizationWithSubAndPlan
     */
    'organization': Organization;
    /**
     * 
     * @type {StripePlan}
     * @memberof OrganizationWithSubAndPlan
     */
    'plan'?: StripePlan | null;
    /**
     * 
     * @type {StripeSubscription}
     * @memberof OrganizationWithSubAndPlan
     */
    'subscription'?: StripeSubscription | null;
}
/**
 * 
 * @export
 * @interface PopularFilters
 */
export interface PopularFilters {
    /**
     * 
     * @type {string}
     * @memberof PopularFilters
     */
    'clause': string;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof PopularFilters
     */
    'common_values': { [key: string]: number; };
    /**
     * 
     * @type {number}
     * @memberof PopularFilters
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PopularFilters
     */
    'field': string;
    /**
     * 
     * @type {string}
     * @memberof PopularFilters
     */
    'filter_type': string;
}
/**
 * 
 * @export
 * @interface PopularFilters1
 */
export interface PopularFilters1 {
    /**
     * 
     * @type {SearchAnalyticsFilter}
     * @memberof PopularFilters1
     */
    'filter'?: SearchAnalyticsFilter | null;
    /**
     * 
     * @type {string}
     * @memberof PopularFilters1
     */
    'type': PopularFilters1TypeEnum;
}

export const PopularFilters1TypeEnum = {
    PopularFilters: 'popular_filters'
} as const;

export type PopularFilters1TypeEnum = typeof PopularFilters1TypeEnum[keyof typeof PopularFilters1TypeEnum];

/**
 * 
 * @export
 * @interface PopularFiltersResponse
 */
export interface PopularFiltersResponse {
    /**
     * 
     * @type {Array<PopularFilters>}
     * @memberof PopularFiltersResponse
     */
    'popular_filters': Array<PopularFilters>;
}
/**
 * 
 * @export
 * @interface PublicDatasetOptions
 */
export interface PublicDatasetOptions {
    /**
     * 
     * @type {boolean}
     * @memberof PublicDatasetOptions
     */
    'enabled': boolean;
    /**
     * 
     * @type {PublicPageParameters}
     * @memberof PublicDatasetOptions
     */
    'extra_params'?: PublicPageParameters | null;
}
/**
 * 
 * @export
 * @interface PublicPageParameters
 */
export interface PublicPageParameters {
    /**
     * 
     * @type {string}
     * @memberof PublicPageParameters
     */
    'accentColor'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PublicPageParameters
     */
    'analytics'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PublicPageParameters
     */
    'apiKey'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PublicPageParameters
     */
    'baseUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PublicPageParameters
     */
    'brandLogoImgSrcUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PublicPageParameters
     */
    'brandName'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PublicPageParameters
     */
    'chat'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PublicPageParameters
     */
    'datasetId'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PublicPageParameters
     */
    'defaultAiQuestions'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PublicPageParameters
     */
    'defaultSearchQueries'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof PublicPageParameters
     */
    'placeholder'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PublicPageParameters
     */
    'problemLink'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PublicPageParameters
     */
    'responsive'?: boolean | null;
    /**
     * 
     * @type {PublicPageSearchOptions}
     * @memberof PublicPageParameters
     */
    'searchOptions'?: PublicPageSearchOptions | null;
    /**
     * 
     * @type {boolean}
     * @memberof PublicPageParameters
     */
    'suggestedQueries'?: boolean | null;
    /**
     * 
     * @type {PublicPageTheme}
     * @memberof PublicPageParameters
     */
    'theme'?: PublicPageTheme | null;
}


/**
 * 
 * @export
 * @interface PublicPageSearchOptions
 */
export interface PublicPageSearchOptions {
    /**
     * Set content_only to true to only returning the chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typically 10-50ms). Default is false.
     * @type {boolean}
     * @memberof PublicPageSearchOptions
     */
    'content_only'?: boolean | null;
    /**
     * 
     * @type {ChunkFilter}
     * @memberof PublicPageSearchOptions
     */
    'filters'?: ChunkFilter | null;
    /**
     * Get total page count for the query accounting for the applied filters. Defaults to false, but can be set to true when the latency penalty is acceptable (typically 50-200ms).
     * @type {boolean}
     * @memberof PublicPageSearchOptions
     */
    'get_total_pages'?: boolean | null;
    /**
     * Page of chunks to fetch. Page is 1-indexed.
     * @type {number}
     * @memberof PublicPageSearchOptions
     */
    'page'?: number | null;
    /**
     * Page size is the number of chunks to fetch. This can be used to fetch more than 10 chunks at a time.
     * @type {number}
     * @memberof PublicPageSearchOptions
     */
    'page_size'?: number | null;
    /**
     * If true, stop words (specified in server/src/stop-words.txt in the git repo) will be removed. Queries that are entirely stop words will be preserved.
     * @type {boolean}
     * @memberof PublicPageSearchOptions
     */
    'remove_stop_words'?: boolean | null;
    /**
     * Set score_threshold to a float to filter out chunks with a score below the threshold for cosine distance metric. For Manhattan Distance, Euclidean Distance, and Dot Product, it will filter out scores above the threshold distance. This threshold applies before weight and bias modifications. If not specified, this defaults to no threshold. A threshold of 0 will default to no threshold.
     * @type {number}
     * @memberof PublicPageSearchOptions
     */
    'score_threshold'?: number | null;
    /**
     * 
     * @type {ScoringOptions}
     * @memberof PublicPageSearchOptions
     */
    'scoring_options'?: ScoringOptions | null;
    /**
     * 
     * @type {SearchMethod}
     * @memberof PublicPageSearchOptions
     */
    'search_type'?: SearchMethod | null;
    /**
     * Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typically 10-50ms). Default is false.
     * @type {boolean}
     * @memberof PublicPageSearchOptions
     */
    'slim_chunks'?: boolean | null;
    /**
     * 
     * @type {SortOptions}
     * @memberof PublicPageSearchOptions
     */
    'sort_options'?: SortOptions | null;
    /**
     * 
     * @type {TypoOptions}
     * @memberof PublicPageSearchOptions
     */
    'typo_options'?: TypoOptions | null;
    /**
     * Enables autocomplete on the search modal.
     * @type {boolean}
     * @memberof PublicPageSearchOptions
     */
    'use_autocomplete'?: boolean | null;
    /**
     * If true, quoted and - prefixed words will be parsed from the queries and used as required and negated words respectively. Default is false.
     * @type {boolean}
     * @memberof PublicPageSearchOptions
     */
    'use_quote_negated_terms'?: boolean | null;
    /**
     * User ID is the id of the user who is making the request. This is used to track user interactions with the search results.
     * @type {string}
     * @memberof PublicPageSearchOptions
     */
    'user_id'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PublicPageTheme = {
    Light: 'light',
    Dark: 'dark'
} as const;

export type PublicPageTheme = typeof PublicPageTheme[keyof typeof PublicPageTheme];


/**
 * 
 * @export
 * @interface Purchase
 */
export interface Purchase {
    /**
     * The currency of the purchase
     * @type {string}
     * @memberof Purchase
     */
    'currency'?: string | null;
    /**
     * The name of the event
     * @type {string}
     * @memberof Purchase
     */
    'event_name': string;
    /**
     * 
     * @type {string}
     * @memberof Purchase
     */
    'event_type': PurchaseEventTypeEnum;
    /**
     * Whether the event is a conversion event
     * @type {boolean}
     * @memberof Purchase
     */
    'is_conversion'?: boolean | null;
    /**
     * The items that were purchased
     * @type {Array<string>}
     * @memberof Purchase
     */
    'items': Array<string>;
    /**
     * 
     * @type {RequestInfo}
     * @memberof Purchase
     */
    'request'?: RequestInfo | null;
    /**
     * The user id of the user who purchased the items
     * @type {string}
     * @memberof Purchase
     */
    'user_id'?: string | null;
    /**
     * The value of the purchase
     * @type {number}
     * @memberof Purchase
     */
    'value'?: number | null;
}

export const PurchaseEventTypeEnum = {
    Purchase: 'purchase'
} as const;

export type PurchaseEventTypeEnum = typeof PurchaseEventTypeEnum[keyof typeof PurchaseEventTypeEnum];

/**
 * @type QdrantSortBy
 * Sort by lets you specify a method to sort the results by. If not specified, this defaults to the score of the chunks. If specified, this can be any key in the chunk metadata. This key must be a numeric value within the payload.
 * @export
 */
export type QdrantSortBy = SortByField | SortBySearchType;

/**
 * 
 * @export
 * @interface QueryCountResponse
 */
export interface QueryCountResponse {
    /**
     * 
     * @type {Array<SearchTypeCount>}
     * @memberof QueryCountResponse
     */
    'total_queries': Array<SearchTypeCount>;
}
/**
 * 
 * @export
 * @interface QueryDetails
 */
export interface QueryDetails {
    /**
     * 
     * @type {string}
     * @memberof QueryDetails
     */
    'request_id': string;
    /**
     * 
     * @type {string}
     * @memberof QueryDetails
     */
    'type': QueryDetailsTypeEnum;
}

export const QueryDetailsTypeEnum = {
    RagQueryDetails: 'rag_query_details'
} as const;

export type QueryDetailsTypeEnum = typeof QueryDetailsTypeEnum[keyof typeof QueryDetailsTypeEnum];

/**
 * 
 * @export
 * @interface QueryDetails1
 */
export interface QueryDetails1 {
    /**
     * 
     * @type {string}
     * @memberof QueryDetails1
     */
    'request_id': string;
    /**
     * 
     * @type {string}
     * @memberof QueryDetails1
     */
    'type': QueryDetails1TypeEnum;
}

export const QueryDetails1TypeEnum = {
    QueryDetails: 'query_details'
} as const;

export type QueryDetails1TypeEnum = typeof QueryDetails1TypeEnum[keyof typeof QueryDetails1TypeEnum];

/**
 * @type QueryTypes
 * Query is the search query. This can be any string. The query will be used to create an embedding vector and/or SPLADE vector which will be used to find the result set.  You can either provide one query, or multiple with weights. Multi-query only works with Semantic Search and is not compatible with cross encoder re-ranking or highlights.
 * @export
 */
export type QueryTypes = Array<MultiQuery> | string;

/**
 * 
 * @export
 * @interface RAG
 */
export interface RAG {
    /**
     * 
     * @type {string}
     * @memberof RAG
     */
    'event_type': RAGEventTypeEnum;
    /**
     * The response from the LLM
     * @type {string}
     * @memberof RAG
     */
    'llm_response'?: string | null;
    /**
     * 
     * @type {SearchQueryRating}
     * @memberof RAG
     */
    'query_rating'?: SearchQueryRating | null;
    /**
     * 
     * @type {ClickhouseRagTypes}
     * @memberof RAG
     */
    'rag_type'?: ClickhouseRagTypes | null;
    /**
     * The results of the RAG event
     * @type {Array<any>}
     * @memberof RAG
     */
    'results'?: Array<any> | null;
    /**
     * The search id to associate the RAG event with a search
     * @type {string}
     * @memberof RAG
     */
    'search_id'?: string | null;
    /**
     * The user id of the user who made the RAG event
     * @type {string}
     * @memberof RAG
     */
    'user_id'?: string | null;
    /**
     * The user message
     * @type {string}
     * @memberof RAG
     */
    'user_message': string;
}

export const RAGEventTypeEnum = {
    Rag: 'rag'
} as const;

export type RAGEventTypeEnum = typeof RAGEventTypeEnum[keyof typeof RAGEventTypeEnum];

/**
 * @type RAGAnalytics
 * @export
 */
export type RAGAnalytics = QueryDetails | RAGQueries | RAGUsage | RAGUsageGraph;

/**
 * 
 * @export
 * @interface RAGAnalyticsFilter
 */
export interface RAGAnalyticsFilter {
    /**
     * 
     * @type {DateRange}
     * @memberof RAGAnalyticsFilter
     */
    'date_range'?: DateRange | null;
    /**
     * 
     * @type {RagTypes}
     * @memberof RAGAnalyticsFilter
     */
    'rag_type'?: RagTypes | null;
}


/**
 * @type RAGAnalyticsResponse
 * @export
 */
export type RAGAnalyticsResponse = RAGUsageGraphResponse | RAGUsageResponse | RagQueryEvent | RagQueryResponse;

/**
 * 
 * @export
 * @interface RAGQueries
 */
export interface RAGQueries {
    /**
     * 
     * @type {RAGAnalyticsFilter}
     * @memberof RAGQueries
     */
    'filter'?: RAGAnalyticsFilter | null;
    /**
     * 
     * @type {number}
     * @memberof RAGQueries
     */
    'page'?: number | null;
    /**
     * 
     * @type {RAGSortBy}
     * @memberof RAGQueries
     */
    'sort_by'?: RAGSortBy | null;
    /**
     * 
     * @type {SortOrder}
     * @memberof RAGQueries
     */
    'sort_order'?: SortOrder | null;
    /**
     * 
     * @type {string}
     * @memberof RAGQueries
     */
    'type': RAGQueriesTypeEnum;
}

export const RAGQueriesTypeEnum = {
    RagQueries: 'rag_queries'
} as const;

export type RAGQueriesTypeEnum = typeof RAGQueriesTypeEnum[keyof typeof RAGQueriesTypeEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const RAGSortBy = {
    CreatedAt: 'created_at',
    Latency: 'latency'
} as const;

export type RAGSortBy = typeof RAGSortBy[keyof typeof RAGSortBy];


/**
 * 
 * @export
 * @interface RAGUsage
 */
export interface RAGUsage {
    /**
     * 
     * @type {RAGAnalyticsFilter}
     * @memberof RAGUsage
     */
    'filter'?: RAGAnalyticsFilter | null;
    /**
     * 
     * @type {string}
     * @memberof RAGUsage
     */
    'type': RAGUsageTypeEnum;
}

export const RAGUsageTypeEnum = {
    RagUsage: 'rag_usage'
} as const;

export type RAGUsageTypeEnum = typeof RAGUsageTypeEnum[keyof typeof RAGUsageTypeEnum];

/**
 * 
 * @export
 * @interface RAGUsageGraph
 */
export interface RAGUsageGraph {
    /**
     * 
     * @type {RAGAnalyticsFilter}
     * @memberof RAGUsageGraph
     */
    'filter'?: RAGAnalyticsFilter | null;
    /**
     * 
     * @type {Granularity}
     * @memberof RAGUsageGraph
     */
    'granularity'?: Granularity | null;
    /**
     * 
     * @type {string}
     * @memberof RAGUsageGraph
     */
    'type': RAGUsageGraphTypeEnum;
}

export const RAGUsageGraphTypeEnum = {
    RagUsageGraph: 'rag_usage_graph'
} as const;

export type RAGUsageGraphTypeEnum = typeof RAGUsageGraphTypeEnum[keyof typeof RAGUsageGraphTypeEnum];

/**
 * 
 * @export
 * @interface RAGUsageGraphResponse
 */
export interface RAGUsageGraphResponse {
    /**
     * 
     * @type {Array<UsageGraphPoint>}
     * @memberof RAGUsageGraphResponse
     */
    'usage_points': Array<UsageGraphPoint>;
}
/**
 * 
 * @export
 * @interface RAGUsageResponse
 */
export interface RAGUsageResponse {
    /**
     * 
     * @type {number}
     * @memberof RAGUsageResponse
     */
    'total_queries': number;
}
/**
 * 
 * @export
 * @interface RagQueryEvent
 */
export interface RagQueryEvent {
    /**
     * 
     * @type {string}
     * @memberof RagQueryEvent
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof RagQueryEvent
     */
    'dataset_id': string;
    /**
     * 
     * @type {string}
     * @memberof RagQueryEvent
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RagQueryEvent
     */
    'llm_response': string;
    /**
     * 
     * @type {SearchQueryRating}
     * @memberof RagQueryEvent
     */
    'query_rating'?: SearchQueryRating | null;
    /**
     * 
     * @type {ClickhouseRagTypes}
     * @memberof RagQueryEvent
     */
    'rag_type': ClickhouseRagTypes;
    /**
     * 
     * @type {Array<any>}
     * @memberof RagQueryEvent
     */
    'results': Array<any>;
    /**
     * 
     * @type {string}
     * @memberof RagQueryEvent
     */
    'search_id': string;
    /**
     * 
     * @type {string}
     * @memberof RagQueryEvent
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof RagQueryEvent
     */
    'user_message': string;
}


/**
 * 
 * @export
 * @interface RagQueryResponse
 */
export interface RagQueryResponse {
    /**
     * 
     * @type {Array<RagQueryEvent>}
     * @memberof RagQueryResponse
     */
    'queries': Array<RagQueryEvent>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RagTypes = {
    ChosenChunks: 'chosen_chunks',
    AllChunks: 'all_chunks'
} as const;

export type RagTypes = typeof RagTypes[keyof typeof RagTypes];


/**
 * 
 * @export
 * @interface Range
 */
export interface Range {
    /**
     * 
     * @type {RangeCondition}
     * @memberof Range
     */
    'gt'?: RangeCondition | null;
    /**
     * 
     * @type {RangeCondition}
     * @memberof Range
     */
    'gte'?: RangeCondition | null;
    /**
     * 
     * @type {RangeCondition}
     * @memberof Range
     */
    'lt'?: RangeCondition | null;
    /**
     * 
     * @type {RangeCondition}
     * @memberof Range
     */
    'lte'?: RangeCondition | null;
}
/**
 * @type RangeCondition
 * @export
 */
export type RangeCondition = number;

/**
 * 
 * @export
 * @interface RateQueryRequest
 */
export interface RateQueryRequest {
    /**
     * 
     * @type {string}
     * @memberof RateQueryRequest
     */
    'note'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RateQueryRequest
     */
    'query_id': string;
    /**
     * 
     * @type {number}
     * @memberof RateQueryRequest
     */
    'rating': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ReRankOptions = {
    Semantic: 'semantic',
    Fulltext: 'fulltext',
    Bm25: 'bm25',
    CrossEncoder: 'cross_encoder'
} as const;

export type ReRankOptions = typeof ReRankOptions[keyof typeof ReRankOptions];


/**
 * 
 * @export
 * @interface RecommendChunksRequest
 */
export interface RecommendChunksRequest {
    /**
     * 
     * @type {ChunkFilter}
     * @memberof RecommendChunksRequest
     */
    'filters'?: ChunkFilter | null;
    /**
     * The number of chunks to return. This is the number of chunks which will be returned in the response. The default is 10.
     * @type {number}
     * @memberof RecommendChunksRequest
     */
    'limit'?: number | null;
    /**
     * The ids of the chunks to be used as negative examples for the recommendation. The chunks in this array will be used to filter out similar chunks.
     * @type {Array<string>}
     * @memberof RecommendChunksRequest
     */
    'negative_chunk_ids'?: Array<string> | null;
    /**
     * The tracking_ids of the chunks to be used as negative examples for the recommendation. The chunks in this array will be used to filter out similar chunks.
     * @type {Array<string>}
     * @memberof RecommendChunksRequest
     */
    'negative_tracking_ids'?: Array<string> | null;
    /**
     * The ids of the chunks to be used as positive examples for the recommendation. The chunks in this array will be used to find similar chunks.
     * @type {Array<string>}
     * @memberof RecommendChunksRequest
     */
    'positive_chunk_ids'?: Array<string> | null;
    /**
     * The tracking_ids of the chunks to be used as positive examples for the recommendation. The chunks in this array will be used to find similar chunks.
     * @type {Array<string>}
     * @memberof RecommendChunksRequest
     */
    'positive_tracking_ids'?: Array<string> | null;
    /**
     * 
     * @type {RecommendType}
     * @memberof RecommendChunksRequest
     */
    'recommend_type'?: RecommendType | null;
    /**
     * Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typicall 10-50ms). Default is false.
     * @type {boolean}
     * @memberof RecommendChunksRequest
     */
    'slim_chunks'?: boolean | null;
    /**
     * 
     * @type {RecommendationStrategy}
     * @memberof RecommendChunksRequest
     */
    'strategy'?: RecommendationStrategy | null;
    /**
     * User ID is the id of the user who is making the request. This is used to track user interactions with the recommendation results.
     * @type {string}
     * @memberof RecommendChunksRequest
     */
    'user_id'?: string | null;
}


/**
 * 
 * @export
 * @interface RecommendChunksResponseBody
 */
export interface RecommendChunksResponseBody {
    /**
     * 
     * @type {Array<ScoreChunk>}
     * @memberof RecommendChunksResponseBody
     */
    'chunks': Array<ScoreChunk>;
    /**
     * 
     * @type {string}
     * @memberof RecommendChunksResponseBody
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface RecommendGroupsReqPayload
 */
export interface RecommendGroupsReqPayload {
    /**
     * 
     * @type {ChunkFilter}
     * @memberof RecommendGroupsReqPayload
     */
    'filters'?: ChunkFilter | null;
    /**
     * The number of chunks to fetch for each group. This is the number of chunks which will be returned in the response for each group. The default is 3. If this is set to a large number, we recommend setting slim_chunks to true to avoid returning the content and chunk_html of the chunks so as to reduce latency due to content download and serialization.
     * @type {number}
     * @memberof RecommendGroupsReqPayload
     */
    'group_size'?: number | null;
    /**
     * The number of groups to return. This is the number of groups which will be returned in the response. The default is 10.
     * @type {number}
     * @memberof RecommendGroupsReqPayload
     */
    'limit'?: number | null;
    /**
     * The ids of the groups to be used as negative examples for the recommendation. The groups in this array will be used to filter out similar groups.
     * @type {Array<string>}
     * @memberof RecommendGroupsReqPayload
     */
    'negative_group_ids'?: Array<string> | null;
    /**
     * The ids of the groups to be used as negative examples for the recommendation. The groups in this array will be used to filter out similar groups.
     * @type {Array<string>}
     * @memberof RecommendGroupsReqPayload
     */
    'negative_group_tracking_ids'?: Array<string> | null;
    /**
     * The ids of the groups to be used as positive examples for the recommendation. The groups in this array will be used to find similar groups.
     * @type {Array<string>}
     * @memberof RecommendGroupsReqPayload
     */
    'positive_group_ids'?: Array<string> | null;
    /**
     * The ids of the groups to be used as positive examples for the recommendation. The groups in this array will be used to find similar groups.
     * @type {Array<string>}
     * @memberof RecommendGroupsReqPayload
     */
    'positive_group_tracking_ids'?: Array<string> | null;
    /**
     * 
     * @type {RecommendType}
     * @memberof RecommendGroupsReqPayload
     */
    'recommend_type'?: RecommendType | null;
    /**
     * Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typicall 10-50ms). Default is false.
     * @type {boolean}
     * @memberof RecommendGroupsReqPayload
     */
    'slim_chunks'?: boolean | null;
    /**
     * 
     * @type {RecommendationStrategy}
     * @memberof RecommendGroupsReqPayload
     */
    'strategy'?: RecommendationStrategy | null;
    /**
     * The user_id is the id of the user who is making the request. This is used to track user interactions with the rrecommendation results.
     * @type {string}
     * @memberof RecommendGroupsReqPayload
     */
    'user_id'?: string | null;
}


/**
 * @type RecommendGroupsResponse
 * @export
 */
export type RecommendGroupsResponse = GroupScoreChunk | RecommendGroupsResponseBody;

/**
 * 
 * @export
 * @interface RecommendGroupsResponseBody
 */
export interface RecommendGroupsResponseBody {
    /**
     * 
     * @type {string}
     * @memberof RecommendGroupsResponseBody
     */
    'id': string;
    /**
     * 
     * @type {Array<SearchOverGroupsResults>}
     * @memberof RecommendGroupsResponseBody
     */
    'results': Array<SearchOverGroupsResults>;
}
/**
 * @type RecommendResponseTypes
 * @export
 */
export type RecommendResponseTypes = Array<ChunkMetadataWithScore> | RecommendChunksResponseBody;

/**
 * The type of recommendation to make. This lets you choose whether to recommend based off of `semantic` or `fulltext` similarity. The default is `semantic`.
 * @export
 * @enum {string}
 */

export const RecommendType = {
    Semantic: 'semantic',
    Fulltext: 'fulltext',
    Bm25: 'bm25'
} as const;

export type RecommendType = typeof RecommendType[keyof typeof RecommendType];


/**
 * 
 * @export
 * @interface Recommendation
 */
export interface Recommendation {
    /**
     * 
     * @type {string}
     * @memberof Recommendation
     */
    'event_type': RecommendationEventTypeEnum;
    /**
     * Negative ids used for the recommendation
     * @type {Array<string>}
     * @memberof Recommendation
     */
    'negative_ids'?: Array<string> | null;
    /**
     * Negative tracking ids used for the recommendation
     * @type {Array<string>}
     * @memberof Recommendation
     */
    'negative_tracking_ids'?: Array<string> | null;
    /**
     * Positive ids used for the recommendation
     * @type {Array<string>}
     * @memberof Recommendation
     */
    'positive_ids'?: Array<string> | null;
    /**
     * Positive tracking ids used for the recommendation
     * @type {Array<string>}
     * @memberof Recommendation
     */
    'positive_tracking_ids'?: Array<string> | null;
    /**
     * 
     * @type {ClickhouseRecommendationTypes}
     * @memberof Recommendation
     */
    'recommendation_type'?: ClickhouseRecommendationTypes | null;
    /**
     * The request params of the recommendation
     * @type {any}
     * @memberof Recommendation
     */
    'request_params'?: any | null;
    /**
     * The results of the Recommendation event
     * @type {Array<any>}
     * @memberof Recommendation
     */
    'results'?: Array<any> | null;
    /**
     * Top score of the recommendation
     * @type {number}
     * @memberof Recommendation
     */
    'top_score'?: number | null;
    /**
     * The user id of the user who made the recommendation
     * @type {string}
     * @memberof Recommendation
     */
    'user_id'?: string | null;
}

export const RecommendationEventTypeEnum = {
    Recommendation: 'recommendation'
} as const;

export type RecommendationEventTypeEnum = typeof RecommendationEventTypeEnum[keyof typeof RecommendationEventTypeEnum];

/**
 * @type RecommendationAnalytics
 * @export
 */
export type RecommendationAnalytics = LowConfidenceRecommendations | QueryDetails1 | RecommendationQueries;

/**
 * 
 * @export
 * @interface RecommendationAnalyticsFilter
 */
export interface RecommendationAnalyticsFilter {
    /**
     * 
     * @type {DateRange}
     * @memberof RecommendationAnalyticsFilter
     */
    'date_range'?: DateRange | null;
    /**
     * 
     * @type {RecommendationType}
     * @memberof RecommendationAnalyticsFilter
     */
    'recommendation_type'?: RecommendationType | null;
}


/**
 * @type RecommendationAnalyticsResponse
 * @export
 */
export type RecommendationAnalyticsResponse = RecommendationEvent | RecommendationsEventResponse;

/**
 * 
 * @export
 * @interface RecommendationCTRMetrics
 */
export interface RecommendationCTRMetrics {
    /**
     * 
     * @type {number}
     * @memberof RecommendationCTRMetrics
     */
    'avg_position_of_click': number;
    /**
     * 
     * @type {number}
     * @memberof RecommendationCTRMetrics
     */
    'percent_recommendations_with_clicks': number;
    /**
     * 
     * @type {number}
     * @memberof RecommendationCTRMetrics
     */
    'percent_recommendations_without_clicks': number;
    /**
     * 
     * @type {number}
     * @memberof RecommendationCTRMetrics
     */
    'recommendations_with_clicks': number;
}
/**
 * 
 * @export
 * @interface RecommendationCTRMetrics1
 */
export interface RecommendationCTRMetrics1 {
    /**
     * 
     * @type {RecommendationAnalyticsFilter}
     * @memberof RecommendationCTRMetrics1
     */
    'filter'?: RecommendationAnalyticsFilter | null;
    /**
     * 
     * @type {string}
     * @memberof RecommendationCTRMetrics1
     */
    'type': RecommendationCTRMetrics1TypeEnum;
}

export const RecommendationCTRMetrics1TypeEnum = {
    RecommendationCtrMetrics: 'recommendation_ctr_metrics'
} as const;

export type RecommendationCTRMetrics1TypeEnum = typeof RecommendationCTRMetrics1TypeEnum[keyof typeof RecommendationCTRMetrics1TypeEnum];

/**
 * 
 * @export
 * @interface RecommendationEvent
 */
export interface RecommendationEvent {
    /**
     * 
     * @type {string}
     * @memberof RecommendationEvent
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof RecommendationEvent
     */
    'dataset_id': string;
    /**
     * 
     * @type {string}
     * @memberof RecommendationEvent
     */
    'id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RecommendationEvent
     */
    'negative_ids': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RecommendationEvent
     */
    'negative_tracking_ids': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RecommendationEvent
     */
    'positive_ids': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RecommendationEvent
     */
    'positive_tracking_ids': Array<string>;
    /**
     * 
     * @type {ClickhouseRecommendationTypes}
     * @memberof RecommendationEvent
     */
    'recommendation_type': ClickhouseRecommendationTypes;
    /**
     * 
     * @type {any}
     * @memberof RecommendationEvent
     */
    'request_params': any;
    /**
     * 
     * @type {Array<any>}
     * @memberof RecommendationEvent
     */
    'results': Array<any>;
    /**
     * 
     * @type {number}
     * @memberof RecommendationEvent
     */
    'top_score': number;
    /**
     * 
     * @type {string}
     * @memberof RecommendationEvent
     */
    'user_id': string;
}


/**
 * 
 * @export
 * @interface RecommendationQueries
 */
export interface RecommendationQueries {
    /**
     * 
     * @type {RecommendationAnalyticsFilter}
     * @memberof RecommendationQueries
     */
    'filter'?: RecommendationAnalyticsFilter | null;
    /**
     * 
     * @type {number}
     * @memberof RecommendationQueries
     */
    'page'?: number | null;
    /**
     * 
     * @type {SearchSortBy}
     * @memberof RecommendationQueries
     */
    'sort_by'?: SearchSortBy | null;
    /**
     * 
     * @type {SortOrder}
     * @memberof RecommendationQueries
     */
    'sort_order'?: SortOrder | null;
    /**
     * 
     * @type {string}
     * @memberof RecommendationQueries
     */
    'type': RecommendationQueriesTypeEnum;
}

export const RecommendationQueriesTypeEnum = {
    RecommendationQueries: 'recommendation_queries'
} as const;

export type RecommendationQueriesTypeEnum = typeof RecommendationQueriesTypeEnum[keyof typeof RecommendationQueriesTypeEnum];

/**
 * Strategy to use for recommendations, either \"average_vector\" or \"best_score\". The default is \"average_vector\". The \"average_vector\" strategy will construct a single average vector from the positive and negative samples then use it to perform a pseudo-search. The \"best_score\" strategy is more advanced and navigates the HNSW with a heuristic of picking edges where the point is closer to the positive samples than it is the negatives.
 * @export
 * @enum {string}
 */

export const RecommendationStrategy = {
    AverageVector: 'average_vector',
    BestScore: 'best_score'
} as const;

export type RecommendationStrategy = typeof RecommendationStrategy[keyof typeof RecommendationStrategy];


/**
 * 
 * @export
 * @enum {string}
 */

export const RecommendationType = {
    Chunk: 'Chunk',
    Group: 'Group'
} as const;

export type RecommendationType = typeof RecommendationType[keyof typeof RecommendationType];


/**
 * 
 * @export
 * @interface RecommendationsEventResponse
 */
export interface RecommendationsEventResponse {
    /**
     * 
     * @type {Array<RecommendationEvent>}
     * @memberof RecommendationsEventResponse
     */
    'queries': Array<RecommendationEvent>;
}
/**
 * 
 * @export
 * @interface RecommendationsWithClicks
 */
export interface RecommendationsWithClicks {
    /**
     * 
     * @type {RecommendationAnalyticsFilter}
     * @memberof RecommendationsWithClicks
     */
    'filter'?: RecommendationAnalyticsFilter | null;
    /**
     * 
     * @type {number}
     * @memberof RecommendationsWithClicks
     */
    'page'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RecommendationsWithClicks
     */
    'type': RecommendationsWithClicksTypeEnum;
}

export const RecommendationsWithClicksTypeEnum = {
    RecommendationsWithClicks: 'recommendations_with_clicks'
} as const;

export type RecommendationsWithClicksTypeEnum = typeof RecommendationsWithClicksTypeEnum[keyof typeof RecommendationsWithClicksTypeEnum];

/**
 * 
 * @export
 * @interface RecommendationsWithClicksCTRResponse
 */
export interface RecommendationsWithClicksCTRResponse {
    /**
     * 
     * @type {ChunkMetadataWithPosition}
     * @memberof RecommendationsWithClicksCTRResponse
     */
    'clicked_chunk': ChunkMetadataWithPosition;
    /**
     * 
     * @type {string}
     * @memberof RecommendationsWithClicksCTRResponse
     */
    'created_at': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RecommendationsWithClicksCTRResponse
     */
    'negative_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof RecommendationsWithClicksCTRResponse
     */
    'negative_tracking_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof RecommendationsWithClicksCTRResponse
     */
    'positive_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof RecommendationsWithClicksCTRResponse
     */
    'positive_tracking_ids'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof RecommendationsWithClicksCTRResponse
     */
    'request_id': string;
    /**
     * 
     * @type {Array<any>}
     * @memberof RecommendationsWithClicksCTRResponse
     */
    'results': Array<any>;
}
/**
 * 
 * @export
 * @interface RecommendationsWithoutClicks
 */
export interface RecommendationsWithoutClicks {
    /**
     * 
     * @type {RecommendationAnalyticsFilter}
     * @memberof RecommendationsWithoutClicks
     */
    'filter'?: RecommendationAnalyticsFilter | null;
    /**
     * 
     * @type {number}
     * @memberof RecommendationsWithoutClicks
     */
    'page'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RecommendationsWithoutClicks
     */
    'type': RecommendationsWithoutClicksTypeEnum;
}

export const RecommendationsWithoutClicksTypeEnum = {
    RecommendationsWithoutClicks: 'recommendations_without_clicks'
} as const;

export type RecommendationsWithoutClicksTypeEnum = typeof RecommendationsWithoutClicksTypeEnum[keyof typeof RecommendationsWithoutClicksTypeEnum];

/**
 * 
 * @export
 * @interface RecommendationsWithoutClicksCTRResponse
 */
export interface RecommendationsWithoutClicksCTRResponse {
    /**
     * 
     * @type {string}
     * @memberof RecommendationsWithoutClicksCTRResponse
     */
    'created_at': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RecommendationsWithoutClicksCTRResponse
     */
    'negative_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof RecommendationsWithoutClicksCTRResponse
     */
    'negative_tracking_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof RecommendationsWithoutClicksCTRResponse
     */
    'positive_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof RecommendationsWithoutClicksCTRResponse
     */
    'positive_tracking_ids'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof RecommendationsWithoutClicksCTRResponse
     */
    'request_id': string;
}
/**
 * 
 * @export
 * @interface RegenerateMessageReqPayload
 */
export interface RegenerateMessageReqPayload {
    /**
     * If concat user messages query is set to true, all of the user messages in the topic will be concatenated together and used as the search query. If not specified, this defaults to false. Default is false.
     * @type {boolean}
     * @memberof RegenerateMessageReqPayload
     */
    'concat_user_messages_query'?: boolean | null;
    /**
     * 
     * @type {ContextOptions}
     * @memberof RegenerateMessageReqPayload
     */
    'context_options'?: ContextOptions | null;
    /**
     * 
     * @type {ChunkFilter}
     * @memberof RegenerateMessageReqPayload
     */
    'filters'?: ChunkFilter | null;
    /**
     * 
     * @type {HighlightOptions}
     * @memberof RegenerateMessageReqPayload
     */
    'highlight_options'?: HighlightOptions | null;
    /**
     * 
     * @type {LLMOptions}
     * @memberof RegenerateMessageReqPayload
     */
    'llm_options'?: LLMOptions | null;
    /**
     * Page size is the number of chunks to fetch during RAG. If 0, then no search will be performed. If specified, this will override the N retrievals to include in the dataset configuration. Default is None.
     * @type {number}
     * @memberof RegenerateMessageReqPayload
     */
    'page_size'?: number | null;
    /**
     * Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.
     * @type {number}
     * @memberof RegenerateMessageReqPayload
     */
    'score_threshold'?: number | null;
    /**
     * Query is the search query. This can be any string. The search_query will be used to create a dense embedding vector and/or sparse vector which will be used to find the result set. If not specified, will default to the last user message or HyDE if HyDE is enabled in the dataset configuration. Default is None.
     * @type {string}
     * @memberof RegenerateMessageReqPayload
     */
    'search_query'?: string | null;
    /**
     * 
     * @type {SearchMethod}
     * @memberof RegenerateMessageReqPayload
     */
    'search_type'?: SearchMethod | null;
    /**
     * The id of the topic to regenerate the last message for.
     * @type {string}
     * @memberof RegenerateMessageReqPayload
     */
    'topic_id': string;
    /**
     * If use_group_search is set to true, the search will be conducted using the `search_over_groups` api. If not specified, this defaults to false.
     * @type {boolean}
     * @memberof RegenerateMessageReqPayload
     */
    'use_group_search'?: boolean | null;
    /**
     * The user_id is the id of the user who is making the request. This is used to track user interactions with the RAG results.
     * @type {string}
     * @memberof RegenerateMessageReqPayload
     */
    'user_id'?: string | null;
}


/**
 * 
 * @export
 * @interface RemoveChunkFromGroupReqPayload
 */
export interface RemoveChunkFromGroupReqPayload {
    /**
     * Id of the chunk to remove from the group.
     * @type {string}
     * @memberof RemoveChunkFromGroupReqPayload
     */
    'chunk_id': string;
}
/**
 * 
 * @export
 * @interface RequestInfo
 */
export interface RequestInfo {
    /**
     * 
     * @type {string}
     * @memberof RequestInfo
     */
    'request_id': string;
    /**
     * 
     * @type {CTRType}
     * @memberof RequestInfo
     */
    'request_type': CTRType;
}


/**
 * @type ReturnQueuedChunk
 * @export
 */
export type ReturnQueuedChunk = BatchQueuedChunkResponse | SingleQueuedChunkResponse;

/**
 * 
 * @export
 * @enum {string}
 */

export const RoleProxy = {
    System: 'system',
    User: 'user',
    Assistant: 'assistant'
} as const;

export type RoleProxy = typeof RoleProxy[keyof typeof RoleProxy];


/**
 * 
 * @export
 * @interface ScoreChunk
 */
export interface ScoreChunk {
    /**
     * 
     * @type {NewChunkMetadataTypes}
     * @memberof ScoreChunk
     */
    'chunk': NewChunkMetadataTypes;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScoreChunk
     */
    'highlights'?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof ScoreChunk
     */
    'score': number;
}
/**
 * 
 * @export
 * @interface ScoreChunkDTO
 */
export interface ScoreChunkDTO {
    /**
     * 
     * @type {Array<string>}
     * @memberof ScoreChunkDTO
     */
    'highlights'?: Array<string> | null;
    /**
     * 
     * @type {Array<ChunkMetadataTypes>}
     * @memberof ScoreChunkDTO
     */
    'metadata': Array<ChunkMetadataTypes>;
    /**
     * 
     * @type {number}
     * @memberof ScoreChunkDTO
     */
    'score': number;
}
/**
 * Scoring options provides ways to modify the sparse or dense vector created for the query in order to change how potential matches are scored. If not specified, this defaults to no modifications.
 * @export
 * @interface ScoringOptions
 */
export interface ScoringOptions {
    /**
     * 
     * @type {FullTextBoost}
     * @memberof ScoringOptions
     */
    'fulltext_boost'?: FullTextBoost | null;
    /**
     * 
     * @type {SemanticBoost}
     * @memberof ScoringOptions
     */
    'semantic_boost'?: SemanticBoost | null;
}
/**
 * @type ScrapeOptions
 * Options for including an openapi spec or shopify settigns
 * @export
 */
export type ScrapeOptions = ScrapeOptionsOneOf | ScrapeOptionsOneOf1;

/**
 * 
 * @export
 * @interface ScrapeOptionsOneOf
 */
export interface ScrapeOptionsOneOf {
    /**
     * OpenAPI json schema to be processed alongside the site crawl
     * @type {string}
     * @memberof ScrapeOptionsOneOf
     */
    'openapi_schema_url': string;
    /**
     * Tag to look for to determine if a page should create an openapi route chunk instead of chunks from heading-split of the HTML
     * @type {string}
     * @memberof ScrapeOptionsOneOf
     */
    'openapi_tag': string;
    /**
     * 
     * @type {string}
     * @memberof ScrapeOptionsOneOf
     */
    'type': ScrapeOptionsOneOfTypeEnum;
}

export const ScrapeOptionsOneOfTypeEnum = {
    Openapi: 'openapi'
} as const;

export type ScrapeOptionsOneOfTypeEnum = typeof ScrapeOptionsOneOfTypeEnum[keyof typeof ScrapeOptionsOneOfTypeEnum];

/**
 * 
 * @export
 * @interface ScrapeOptionsOneOf1
 */
export interface ScrapeOptionsOneOf1 {
    /**
     * This option will ingest all variants as individual chunks and place them in groups by product id. Turning this off will only scrape 1 variant per product. default: true
     * @type {boolean}
     * @memberof ScrapeOptionsOneOf1
     */
    'group_variants'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ScrapeOptionsOneOf1
     */
    'type': ScrapeOptionsOneOf1TypeEnum;
}

export const ScrapeOptionsOneOf1TypeEnum = {
    Shopify: 'shopify'
} as const;

export type ScrapeOptionsOneOf1TypeEnum = typeof ScrapeOptionsOneOf1TypeEnum[keyof typeof ScrapeOptionsOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface ScrollChunksReqPayload
 */
export interface ScrollChunksReqPayload {
    /**
     * 
     * @type {ChunkFilter}
     * @memberof ScrollChunksReqPayload
     */
    'filters'?: ChunkFilter | null;
    /**
     * Offset chunk id is the id of the chunk to start the page from. If not specified, this defaults to the first chunk in the dataset sorted by id ascending.
     * @type {string}
     * @memberof ScrollChunksReqPayload
     */
    'offset_chunk_id'?: string | null;
    /**
     * Page size is the number of chunks to fetch. This can be used to fetch more than 10 chunks at a time.
     * @type {number}
     * @memberof ScrollChunksReqPayload
     */
    'page_size'?: number | null;
    /**
     * 
     * @type {SortByField}
     * @memberof ScrollChunksReqPayload
     */
    'sort_by'?: SortByField | null;
}
/**
 * 
 * @export
 * @interface ScrollChunksResponseBody
 */
export interface ScrollChunksResponseBody {
    /**
     * 
     * @type {Array<ChunkMetadata>}
     * @memberof ScrollChunksResponseBody
     */
    'chunks': Array<ChunkMetadata>;
}
/**
 * 
 * @export
 * @interface Search
 */
export interface Search {
    /**
     * 
     * @type {string}
     * @memberof Search
     */
    'event_type': SearchEventTypeEnum;
    /**
     * Latency of the search
     * @type {number}
     * @memberof Search
     */
    'latency'?: number | null;
    /**
     * The search query
     * @type {string}
     * @memberof Search
     */
    'query': string;
    /**
     * 
     * @type {SearchQueryRating}
     * @memberof Search
     */
    'query_rating'?: SearchQueryRating | null;
    /**
     * The request params of the search
     * @type {any}
     * @memberof Search
     */
    'request_params'?: any | null;
    /**
     * The results of the search
     * @type {Array<any>}
     * @memberof Search
     */
    'results'?: Array<any> | null;
    /**
     * 
     * @type {ClickhouseSearchTypes}
     * @memberof Search
     */
    'search_type'?: ClickhouseSearchTypes | null;
    /**
     * The top score of the search
     * @type {number}
     * @memberof Search
     */
    'top_score'?: number | null;
    /**
     * The user id of the user who made the search
     * @type {string}
     * @memberof Search
     */
    'user_id'?: string | null;
}

export const SearchEventTypeEnum = {
    Search: 'search'
} as const;

export type SearchEventTypeEnum = typeof SearchEventTypeEnum[keyof typeof SearchEventTypeEnum];

/**
 * @type SearchAnalytics
 * @export
 */
export type SearchAnalytics = CountQueries | HeadQueries1 | LatencyGraph | LowConfidenceQueries | NoResultQueries | PopularFilters1 | QueryDetails1 | SearchMetrics | SearchQueries | SearchUsageGraph;

/**
 * 
 * @export
 * @interface SearchAnalyticsFilter
 */
export interface SearchAnalyticsFilter {
    /**
     * 
     * @type {DateRange}
     * @memberof SearchAnalyticsFilter
     */
    'date_range'?: DateRange | null;
    /**
     * 
     * @type {SearchMethod}
     * @memberof SearchAnalyticsFilter
     */
    'search_method'?: SearchMethod | null;
    /**
     * 
     * @type {SearchType}
     * @memberof SearchAnalyticsFilter
     */
    'search_type'?: SearchType | null;
}


/**
 * @type SearchAnalyticsResponse
 * @export
 */
export type SearchAnalyticsResponse = DatasetAnalytics | HeadQueryResponse | LatencyGraphResponse | PopularFiltersResponse | QueryCountResponse | SearchQueryEvent | SearchQueryResponse | SearchUsageGraphResponse;

/**
 * 
 * @export
 * @interface SearchCTRMetrics
 */
export interface SearchCTRMetrics {
    /**
     * 
     * @type {number}
     * @memberof SearchCTRMetrics
     */
    'avg_position_of_click': number;
    /**
     * 
     * @type {number}
     * @memberof SearchCTRMetrics
     */
    'percent_searches_with_clicks': number;
    /**
     * 
     * @type {number}
     * @memberof SearchCTRMetrics
     */
    'percent_searches_without_clicks': number;
    /**
     * 
     * @type {number}
     * @memberof SearchCTRMetrics
     */
    'searches_with_clicks': number;
}
/**
 * 
 * @export
 * @interface SearchCTRMetrics1
 */
export interface SearchCTRMetrics1 {
    /**
     * 
     * @type {SearchAnalyticsFilter}
     * @memberof SearchCTRMetrics1
     */
    'filter'?: SearchAnalyticsFilter | null;
    /**
     * 
     * @type {string}
     * @memberof SearchCTRMetrics1
     */
    'type': SearchCTRMetrics1TypeEnum;
}

export const SearchCTRMetrics1TypeEnum = {
    SearchCtrMetrics: 'search_ctr_metrics'
} as const;

export type SearchCTRMetrics1TypeEnum = typeof SearchCTRMetrics1TypeEnum[keyof typeof SearchCTRMetrics1TypeEnum];

/**
 * 
 * @export
 * @interface SearchChunkQueryResponseBody
 */
export interface SearchChunkQueryResponseBody {
    /**
     * 
     * @type {string}
     * @memberof SearchChunkQueryResponseBody
     */
    'corrected_query'?: string | null;
    /**
     * 
     * @type {Array<ScoreChunkDTO>}
     * @memberof SearchChunkQueryResponseBody
     */
    'score_chunks': Array<ScoreChunkDTO>;
    /**
     * 
     * @type {number}
     * @memberof SearchChunkQueryResponseBody
     */
    'total_chunk_pages': number;
}
/**
 * 
 * @export
 * @interface SearchChunksReqPayload
 */
export interface SearchChunksReqPayload {
    /**
     * Set content_only to true to only returning the chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typically 10-50ms). Default is false.
     * @type {boolean}
     * @memberof SearchChunksReqPayload
     */
    'content_only'?: boolean | null;
    /**
     * 
     * @type {ChunkFilter}
     * @memberof SearchChunksReqPayload
     */
    'filters'?: ChunkFilter | null;
    /**
     * Get total page count for the query accounting for the applied filters. Defaults to false, but can be set to true when the latency penalty is acceptable (typically 50-200ms).
     * @type {boolean}
     * @memberof SearchChunksReqPayload
     */
    'get_total_pages'?: boolean | null;
    /**
     * 
     * @type {HighlightOptions}
     * @memberof SearchChunksReqPayload
     */
    'highlight_options'?: HighlightOptions | null;
    /**
     * Page of chunks to fetch. Page is 1-indexed.
     * @type {number}
     * @memberof SearchChunksReqPayload
     */
    'page'?: number | null;
    /**
     * Page size is the number of chunks to fetch. This can be used to fetch more than 10 chunks at a time.
     * @type {number}
     * @memberof SearchChunksReqPayload
     */
    'page_size'?: number | null;
    /**
     * 
     * @type {QueryTypes}
     * @memberof SearchChunksReqPayload
     */
    'query': QueryTypes;
    /**
     * If true, stop words (specified in server/src/stop-words.txt in the git repo) will be removed. Queries that are entirely stop words will be preserved.
     * @type {boolean}
     * @memberof SearchChunksReqPayload
     */
    'remove_stop_words'?: boolean | null;
    /**
     * Set score_threshold to a float to filter out chunks with a score below the threshold for cosine distance metric. For Manhattan Distance, Euclidean Distance, and Dot Product, it will filter out scores above the threshold distance. This threshold applies before weight and bias modifications. If not specified, this defaults to no threshold. A threshold of 0 will default to no threshold.
     * @type {number}
     * @memberof SearchChunksReqPayload
     */
    'score_threshold'?: number | null;
    /**
     * 
     * @type {ScoringOptions}
     * @memberof SearchChunksReqPayload
     */
    'scoring_options'?: ScoringOptions | null;
    /**
     * 
     * @type {SearchMethod}
     * @memberof SearchChunksReqPayload
     */
    'search_type': SearchMethod;
    /**
     * Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typically 10-50ms). Default is false.
     * @type {boolean}
     * @memberof SearchChunksReqPayload
     */
    'slim_chunks'?: boolean | null;
    /**
     * 
     * @type {SortOptions}
     * @memberof SearchChunksReqPayload
     */
    'sort_options'?: SortOptions | null;
    /**
     * 
     * @type {TypoOptions}
     * @memberof SearchChunksReqPayload
     */
    'typo_options'?: TypoOptions | null;
    /**
     * If true, quoted and - prefixed words will be parsed from the queries and used as required and negated words respectively. Default is false.
     * @type {boolean}
     * @memberof SearchChunksReqPayload
     */
    'use_quote_negated_terms'?: boolean | null;
    /**
     * User ID is the id of the user who is making the request. This is used to track user interactions with the search results.
     * @type {string}
     * @memberof SearchChunksReqPayload
     */
    'user_id'?: string | null;
}


/**
 * 
 * @export
 * @interface SearchClusterResponse
 */
export interface SearchClusterResponse {
    /**
     * 
     * @type {Array<SearchClusterTopics>}
     * @memberof SearchClusterResponse
     */
    'clusters': Array<SearchClusterTopics>;
}
/**
 * 
 * @export
 * @interface SearchClusterTopics
 */
export interface SearchClusterTopics {
    /**
     * 
     * @type {number}
     * @memberof SearchClusterTopics
     */
    'avg_score': number;
    /**
     * 
     * @type {string}
     * @memberof SearchClusterTopics
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof SearchClusterTopics
     */
    'dataset_id': string;
    /**
     * 
     * @type {number}
     * @memberof SearchClusterTopics
     */
    'density': number;
    /**
     * 
     * @type {string}
     * @memberof SearchClusterTopics
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SearchClusterTopics
     */
    'topic': string;
}
/**
 * @type SearchGroupResponseTypes
 * @export
 */
export type SearchGroupResponseTypes = SearchWithinGroupResponseBody | SearchWithinGroupResults;

/**
 * 
 * @export
 * @interface SearchLatencyGraph
 */
export interface SearchLatencyGraph {
    /**
     * 
     * @type {number}
     * @memberof SearchLatencyGraph
     */
    'average_latency': number;
    /**
     * 
     * @type {string}
     * @memberof SearchLatencyGraph
     */
    'time_stamp': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SearchMethod = {
    Fulltext: 'fulltext',
    Semantic: 'semantic',
    Hybrid: 'hybrid',
    Bm25: 'bm25'
} as const;

export type SearchMethod = typeof SearchMethod[keyof typeof SearchMethod];


/**
 * 
 * @export
 * @interface SearchMetrics
 */
export interface SearchMetrics {
    /**
     * 
     * @type {SearchAnalyticsFilter}
     * @memberof SearchMetrics
     */
    'filter'?: SearchAnalyticsFilter | null;
    /**
     * 
     * @type {string}
     * @memberof SearchMetrics
     */
    'type': SearchMetricsTypeEnum;
}

export const SearchMetricsTypeEnum = {
    SearchMetrics: 'search_metrics'
} as const;

export type SearchMetricsTypeEnum = typeof SearchMetricsTypeEnum[keyof typeof SearchMetricsTypeEnum];

/**
 * 
 * @export
 * @interface SearchOverGroupsReqPayload
 */
export interface SearchOverGroupsReqPayload {
    /**
     * 
     * @type {ChunkFilter}
     * @memberof SearchOverGroupsReqPayload
     */
    'filters'?: ChunkFilter | null;
    /**
     * Get total page count for the query accounting for the applied filters. Defaults to false, but can be set to true when the latency penalty is acceptable (typically 50-200ms).
     * @type {boolean}
     * @memberof SearchOverGroupsReqPayload
     */
    'get_total_pages'?: boolean | null;
    /**
     * Group_size is the number of chunks to fetch for each group. The default is 3. If a group has less than group_size chunks, all chunks will be returned. If this is set to a large number, we recommend setting slim_chunks to true to avoid returning the content and chunk_html of the chunks so as to lower the amount of time required for content download and serialization.
     * @type {number}
     * @memberof SearchOverGroupsReqPayload
     */
    'group_size'?: number | null;
    /**
     * 
     * @type {HighlightOptions}
     * @memberof SearchOverGroupsReqPayload
     */
    'highlight_options'?: HighlightOptions | null;
    /**
     * Page of group results to fetch. Page is 1-indexed.
     * @type {number}
     * @memberof SearchOverGroupsReqPayload
     */
    'page'?: number | null;
    /**
     * Page size is the number of group results to fetch. The default is 10.
     * @type {number}
     * @memberof SearchOverGroupsReqPayload
     */
    'page_size'?: number | null;
    /**
     * 
     * @type {QueryTypes}
     * @memberof SearchOverGroupsReqPayload
     */
    'query': QueryTypes;
    /**
     * If true, stop words (specified in server/src/stop-words.txt in the git repo) will be removed. Queries that are entirely stop words will be preserved.
     * @type {boolean}
     * @memberof SearchOverGroupsReqPayload
     */
    'remove_stop_words'?: boolean | null;
    /**
     * Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.
     * @type {number}
     * @memberof SearchOverGroupsReqPayload
     */
    'score_threshold'?: number | null;
    /**
     * 
     * @type {SearchMethod}
     * @memberof SearchOverGroupsReqPayload
     */
    'search_type': SearchMethod;
    /**
     * Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typicall 10-50ms). Default is false.
     * @type {boolean}
     * @memberof SearchOverGroupsReqPayload
     */
    'slim_chunks'?: boolean | null;
    /**
     * 
     * @type {TypoOptions}
     * @memberof SearchOverGroupsReqPayload
     */
    'typo_options'?: TypoOptions | null;
    /**
     * If true, quoted and - prefixed words will be parsed from the queries and used as required and negated words respectively. Default is false.
     * @type {boolean}
     * @memberof SearchOverGroupsReqPayload
     */
    'use_quote_negated_terms'?: boolean | null;
    /**
     * The user_id is the id of the user who is making the request. This is used to track user interactions with the search results.
     * @type {string}
     * @memberof SearchOverGroupsReqPayload
     */
    'user_id'?: string | null;
}


/**
 * 
 * @export
 * @interface SearchOverGroupsResponseBody
 */
export interface SearchOverGroupsResponseBody {
    /**
     * 
     * @type {string}
     * @memberof SearchOverGroupsResponseBody
     */
    'corrected_query'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchOverGroupsResponseBody
     */
    'id': string;
    /**
     * 
     * @type {Array<SearchOverGroupsResults>}
     * @memberof SearchOverGroupsResponseBody
     */
    'results': Array<SearchOverGroupsResults>;
    /**
     * 
     * @type {number}
     * @memberof SearchOverGroupsResponseBody
     */
    'total_pages': number;
}
/**
 * @type SearchOverGroupsResponseTypes
 * @export
 */
export type SearchOverGroupsResponseTypes = DeprecatedSearchOverGroupsResponseBody | SearchOverGroupsResponseBody;

/**
 * 
 * @export
 * @interface SearchOverGroupsResults
 */
export interface SearchOverGroupsResults {
    /**
     * 
     * @type {Array<ScoreChunk>}
     * @memberof SearchOverGroupsResults
     */
    'chunks': Array<ScoreChunk>;
    /**
     * 
     * @type {string}
     * @memberof SearchOverGroupsResults
     */
    'file_id'?: string | null;
    /**
     * 
     * @type {ChunkGroup}
     * @memberof SearchOverGroupsResults
     */
    'group': ChunkGroup;
}
/**
 * 
 * @export
 * @interface SearchQueries
 */
export interface SearchQueries {
    /**
     * 
     * @type {SearchAnalyticsFilter}
     * @memberof SearchQueries
     */
    'filter'?: SearchAnalyticsFilter | null;
    /**
     * 
     * @type {number}
     * @memberof SearchQueries
     */
    'page'?: number | null;
    /**
     * 
     * @type {SearchSortBy}
     * @memberof SearchQueries
     */
    'sort_by'?: SearchSortBy | null;
    /**
     * 
     * @type {SortOrder}
     * @memberof SearchQueries
     */
    'sort_order'?: SortOrder | null;
    /**
     * 
     * @type {string}
     * @memberof SearchQueries
     */
    'type': SearchQueriesTypeEnum;
}

export const SearchQueriesTypeEnum = {
    SearchQueries: 'search_queries'
} as const;

export type SearchQueriesTypeEnum = typeof SearchQueriesTypeEnum[keyof typeof SearchQueriesTypeEnum];

/**
 * 
 * @export
 * @interface SearchQueriesWithClicksCTRResponse
 */
export interface SearchQueriesWithClicksCTRResponse {
    /**
     * 
     * @type {ChunkMetadataWithPosition}
     * @memberof SearchQueriesWithClicksCTRResponse
     */
    'clicked_chunk': ChunkMetadataWithPosition;
    /**
     * 
     * @type {string}
     * @memberof SearchQueriesWithClicksCTRResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof SearchQueriesWithClicksCTRResponse
     */
    'query': string;
    /**
     * 
     * @type {string}
     * @memberof SearchQueriesWithClicksCTRResponse
     */
    'request_id': string;
    /**
     * 
     * @type {Array<any>}
     * @memberof SearchQueriesWithClicksCTRResponse
     */
    'results': Array<any>;
}
/**
 * 
 * @export
 * @interface SearchQueriesWithoutClicksCTRResponse
 */
export interface SearchQueriesWithoutClicksCTRResponse {
    /**
     * 
     * @type {string}
     * @memberof SearchQueriesWithoutClicksCTRResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof SearchQueriesWithoutClicksCTRResponse
     */
    'query': string;
    /**
     * 
     * @type {string}
     * @memberof SearchQueriesWithoutClicksCTRResponse
     */
    'request_id': string;
}
/**
 * 
 * @export
 * @interface SearchQueryEvent
 */
export interface SearchQueryEvent {
    /**
     * 
     * @type {string}
     * @memberof SearchQueryEvent
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof SearchQueryEvent
     */
    'dataset_id': string;
    /**
     * 
     * @type {string}
     * @memberof SearchQueryEvent
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof SearchQueryEvent
     */
    'latency': number;
    /**
     * 
     * @type {string}
     * @memberof SearchQueryEvent
     */
    'query': string;
    /**
     * 
     * @type {SearchQueryRating}
     * @memberof SearchQueryEvent
     */
    'query_rating'?: SearchQueryRating | null;
    /**
     * 
     * @type {any}
     * @memberof SearchQueryEvent
     */
    'request_params': any;
    /**
     * 
     * @type {Array<any>}
     * @memberof SearchQueryEvent
     */
    'results': Array<any>;
    /**
     * 
     * @type {ClickhouseSearchTypes}
     * @memberof SearchQueryEvent
     */
    'search_type': ClickhouseSearchTypes;
    /**
     * 
     * @type {number}
     * @memberof SearchQueryEvent
     */
    'top_score': number;
    /**
     * 
     * @type {string}
     * @memberof SearchQueryEvent
     */
    'user_id': string;
}


/**
 * 
 * @export
 * @interface SearchQueryRating
 */
export interface SearchQueryRating {
    /**
     * 
     * @type {string}
     * @memberof SearchQueryRating
     */
    'note'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SearchQueryRating
     */
    'rating': number;
}
/**
 * 
 * @export
 * @interface SearchQueryResponse
 */
export interface SearchQueryResponse {
    /**
     * 
     * @type {Array<SearchQueryEvent>}
     * @memberof SearchQueryResponse
     */
    'queries': Array<SearchQueryEvent>;
}
/**
 * 
 * @export
 * @interface SearchResponseBody
 */
export interface SearchResponseBody {
    /**
     * 
     * @type {Array<ScoreChunk>}
     * @memberof SearchResponseBody
     */
    'chunks': Array<ScoreChunk>;
    /**
     * 
     * @type {string}
     * @memberof SearchResponseBody
     */
    'corrected_query'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchResponseBody
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof SearchResponseBody
     */
    'total_pages': number;
}
/**
 * @type SearchResponseTypes
 * @export
 */
export type SearchResponseTypes = SearchChunkQueryResponseBody | SearchResponseBody;

/**
 * @type SearchResultType
 * @export
 */
export type SearchResultType = GroupScoreChunk | ScoreChunkDTO;

/**
 * 
 * @export
 * @enum {string}
 */

export const SearchSortBy = {
    CreatedAt: 'created_at',
    Latency: 'latency',
    TopScore: 'top_score'
} as const;

export type SearchSortBy = typeof SearchSortBy[keyof typeof SearchSortBy];


/**
 * 
 * @export
 * @enum {string}
 */

export const SearchType = {
    Search: 'search',
    Autocomplete: 'autocomplete',
    SearchOverGroups: 'search_over_groups',
    SearchWithinGroups: 'search_within_groups'
} as const;

export type SearchType = typeof SearchType[keyof typeof SearchType];


/**
 * 
 * @export
 * @interface SearchTypeCount
 */
export interface SearchTypeCount {
    /**
     * 
     * @type {number}
     * @memberof SearchTypeCount
     */
    'search_count': number;
    /**
     * 
     * @type {string}
     * @memberof SearchTypeCount
     */
    'search_method': string;
    /**
     * 
     * @type {string}
     * @memberof SearchTypeCount
     */
    'search_type': string;
}
/**
 * 
 * @export
 * @interface SearchUsageGraph
 */
export interface SearchUsageGraph {
    /**
     * 
     * @type {SearchAnalyticsFilter}
     * @memberof SearchUsageGraph
     */
    'filter'?: SearchAnalyticsFilter | null;
    /**
     * 
     * @type {Granularity}
     * @memberof SearchUsageGraph
     */
    'granularity'?: Granularity | null;
    /**
     * 
     * @type {string}
     * @memberof SearchUsageGraph
     */
    'type': SearchUsageGraphTypeEnum;
}

export const SearchUsageGraphTypeEnum = {
    SearchUsageGraph: 'search_usage_graph'
} as const;

export type SearchUsageGraphTypeEnum = typeof SearchUsageGraphTypeEnum[keyof typeof SearchUsageGraphTypeEnum];

/**
 * 
 * @export
 * @interface SearchUsageGraphResponse
 */
export interface SearchUsageGraphResponse {
    /**
     * 
     * @type {Array<UsageGraphPoint>}
     * @memberof SearchUsageGraphResponse
     */
    'usage_points': Array<UsageGraphPoint>;
}
/**
 * 
 * @export
 * @interface SearchWithinGroupReqPayload
 */
export interface SearchWithinGroupReqPayload {
    /**
     * Set content_only to true to only returning the chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typically 10-50ms). Default is false.
     * @type {boolean}
     * @memberof SearchWithinGroupReqPayload
     */
    'content_only'?: boolean | null;
    /**
     * 
     * @type {ChunkFilter}
     * @memberof SearchWithinGroupReqPayload
     */
    'filters'?: ChunkFilter | null;
    /**
     * Get total page count for the query accounting for the applied filters. Defaults to false, but can be set to true when the latency penalty is acceptable (typically 50-200ms).
     * @type {boolean}
     * @memberof SearchWithinGroupReqPayload
     */
    'get_total_pages'?: boolean | null;
    /**
     * Group specifies the group to search within. Results will only consist of chunks which are bookmarks within the specified group.
     * @type {string}
     * @memberof SearchWithinGroupReqPayload
     */
    'group_id'?: string | null;
    /**
     * Group_tracking_id specifies the group to search within by tracking id. Results will only consist of chunks which are bookmarks within the specified group. If both group_id and group_tracking_id are provided, group_id will be used.
     * @type {string}
     * @memberof SearchWithinGroupReqPayload
     */
    'group_tracking_id'?: string | null;
    /**
     * 
     * @type {HighlightOptions}
     * @memberof SearchWithinGroupReqPayload
     */
    'highlight_options'?: HighlightOptions | null;
    /**
     * The page of chunks to fetch. Page is 1-indexed.
     * @type {number}
     * @memberof SearchWithinGroupReqPayload
     */
    'page'?: number | null;
    /**
     * The page size is the number of chunks to fetch. This can be used to fetch more than 10 chunks at a time.
     * @type {number}
     * @memberof SearchWithinGroupReqPayload
     */
    'page_size'?: number | null;
    /**
     * 
     * @type {QueryTypes}
     * @memberof SearchWithinGroupReqPayload
     */
    'query': QueryTypes;
    /**
     * If true, stop words (specified in server/src/stop-words.txt in the git repo) will be removed. Queries that are entirely stop words will be preserved.
     * @type {boolean}
     * @memberof SearchWithinGroupReqPayload
     */
    'remove_stop_words'?: boolean | null;
    /**
     * Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.
     * @type {number}
     * @memberof SearchWithinGroupReqPayload
     */
    'score_threshold'?: number | null;
    /**
     * 
     * @type {SearchMethod}
     * @memberof SearchWithinGroupReqPayload
     */
    'search_type': SearchMethod;
    /**
     * Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typicall 10-50ms). Default is false.
     * @type {boolean}
     * @memberof SearchWithinGroupReqPayload
     */
    'slim_chunks'?: boolean | null;
    /**
     * 
     * @type {SortOptions}
     * @memberof SearchWithinGroupReqPayload
     */
    'sort_options'?: SortOptions | null;
    /**
     * 
     * @type {TypoOptions}
     * @memberof SearchWithinGroupReqPayload
     */
    'typo_options'?: TypoOptions | null;
    /**
     * If true, quoted and - prefixed words will be parsed from the queries and used as required and negated words respectively. Default is false.
     * @type {boolean}
     * @memberof SearchWithinGroupReqPayload
     */
    'use_quote_negated_terms'?: boolean | null;
    /**
     * The user_id is the id of the user who is making the request. This is used to track user interactions with the search results.
     * @type {string}
     * @memberof SearchWithinGroupReqPayload
     */
    'user_id'?: string | null;
}


/**
 * 
 * @export
 * @interface SearchWithinGroupResponseBody
 */
export interface SearchWithinGroupResponseBody {
    /**
     * 
     * @type {Array<ScoreChunk>}
     * @memberof SearchWithinGroupResponseBody
     */
    'chunks': Array<ScoreChunk>;
    /**
     * 
     * @type {string}
     * @memberof SearchWithinGroupResponseBody
     */
    'corrected_query'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchWithinGroupResponseBody
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof SearchWithinGroupResponseBody
     */
    'total_pages': number;
}
/**
 * 
 * @export
 * @interface SearchWithinGroupResults
 */
export interface SearchWithinGroupResults {
    /**
     * 
     * @type {Array<ScoreChunkDTO>}
     * @memberof SearchWithinGroupResults
     */
    'bookmarks': Array<ScoreChunkDTO>;
    /**
     * 
     * @type {string}
     * @memberof SearchWithinGroupResults
     */
    'corrected_query'?: string | null;
    /**
     * 
     * @type {ChunkGroupAndFileId}
     * @memberof SearchWithinGroupResults
     */
    'group': ChunkGroupAndFileId;
    /**
     * 
     * @type {number}
     * @memberof SearchWithinGroupResults
     */
    'total_pages': number;
}
/**
 * 
 * @export
 * @interface SearchesWithClicks
 */
export interface SearchesWithClicks {
    /**
     * 
     * @type {SearchAnalyticsFilter}
     * @memberof SearchesWithClicks
     */
    'filter'?: SearchAnalyticsFilter | null;
    /**
     * 
     * @type {number}
     * @memberof SearchesWithClicks
     */
    'page'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SearchesWithClicks
     */
    'type': SearchesWithClicksTypeEnum;
}

export const SearchesWithClicksTypeEnum = {
    SearchesWithClicks: 'searches_with_clicks'
} as const;

export type SearchesWithClicksTypeEnum = typeof SearchesWithClicksTypeEnum[keyof typeof SearchesWithClicksTypeEnum];

/**
 * 
 * @export
 * @interface SearchesWithoutClicks
 */
export interface SearchesWithoutClicks {
    /**
     * 
     * @type {SearchAnalyticsFilter}
     * @memberof SearchesWithoutClicks
     */
    'filter'?: SearchAnalyticsFilter | null;
    /**
     * 
     * @type {number}
     * @memberof SearchesWithoutClicks
     */
    'page'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SearchesWithoutClicks
     */
    'type': SearchesWithoutClicksTypeEnum;
}

export const SearchesWithoutClicksTypeEnum = {
    SearchesWithoutClicks: 'searches_without_clicks'
} as const;

export type SearchesWithoutClicksTypeEnum = typeof SearchesWithoutClicksTypeEnum[keyof typeof SearchesWithoutClicksTypeEnum];

/**
 * Semantic boosting moves the dense vector of the chunk in the direction of the distance phrase for semantic search. I.e. you can force a cluster by moving every chunk for a PDF closer to its title or push a chunk with a chunk_html of \"iphone\" 25% closer to the term \"flagship\" by using the distance phrase \"flagship\" and a distance factor of 0.25. Conceptually it\'s drawing a line (euclidean/L2 distance) between the vector for the innerText of the chunk_html and distance_phrase then moving the vector of the chunk_html distance_factor*L2Distance closer to or away from the distance_phrase point along the line between the two points.
 * @export
 * @interface SemanticBoost
 */
export interface SemanticBoost {
    /**
     * Arbitrary float (positive or negative) specifying the multiplicate factor to apply before summing the phrase vector with the chunk_html embedding vector
     * @type {number}
     * @memberof SemanticBoost
     */
    'distance_factor': number;
    /**
     * Terms to embed in order to create the vector which is weighted summed with the chunk_html embedding vector
     * @type {string}
     * @memberof SemanticBoost
     */
    'phrase': string;
}
/**
 * 
 * @export
 * @interface SetUserApiKeyRequest
 */
export interface SetUserApiKeyRequest {
    /**
     * The dataset ids which the api key will have access to. If not provided or empty, the api key will have access to all datasets the auth\'ed user has access to. If both dataset_ids and organization_ids are provided, the api key will have access to the intersection of the datasets and organizations.
     * @type {Array<string>}
     * @memberof SetUserApiKeyRequest
     */
    'dataset_ids'?: Array<string> | null;
    /**
     * The name which will be assigned to the new api key.
     * @type {string}
     * @memberof SetUserApiKeyRequest
     */
    'name': string;
    /**
     * The organization ids which the api key will have access to. If not provided or empty, the api key will have access to all organizations the auth\'ed user has access to.
     * @type {Array<string>}
     * @memberof SetUserApiKeyRequest
     */
    'organization_ids'?: Array<string> | null;
    /**
     * The role which will be assigned to the new api key. Either 0 (read), 1 (read and write at the level of the currently auth\'ed user). The auth\'ed user must have a role greater than or equal to the role being assigned which means they must be an admin (1) or owner (2) of the organization to assign write permissions with a role of 1.
     * @type {number}
     * @memberof SetUserApiKeyRequest
     */
    'role': number;
    /**
     * The routes which the api key will have access to. If not provided or empty, the api key will have access to all routes the auth\'ed user has access to. Specify the routes as a list of strings. For example, [\"GET /api/dataset\", \"POST /api/dataset\"].
     * @type {Array<string>}
     * @memberof SetUserApiKeyRequest
     */
    'scopes'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface SetUserApiKeyResponse
 */
export interface SetUserApiKeyResponse {
    /**
     * The api key which was created. This is the value which should be used in the Authorization header.
     * @type {string}
     * @memberof SetUserApiKeyResponse
     */
    'api_key': string;
}
/**
 * 
 * @export
 * @interface SingleQueuedChunkResponse
 */
export interface SingleQueuedChunkResponse {
    /**
     * 
     * @type {ChunkMetadata}
     * @memberof SingleQueuedChunkResponse
     */
    'chunk_metadata': ChunkMetadata;
    /**
     * The current position the last access item is in the queue
     * @type {number}
     * @memberof SingleQueuedChunkResponse
     */
    'pos_in_queue': number;
}
/**
 * 
 * @export
 * @interface SlimChunkMetadata
 */
export interface SlimChunkMetadata {
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadata
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadata
     */
    'dataset_id': string;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadata
     */
    'id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SlimChunkMetadata
     */
    'image_urls'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadata
     */
    'link'?: string | null;
    /**
     * 
     * @type {GeoInfo}
     * @memberof SlimChunkMetadata
     */
    'location'?: GeoInfo | null;
    /**
     * 
     * @type {any}
     * @memberof SlimChunkMetadata
     */
    'metadata'?: any | null;
    /**
     * 
     * @type {number}
     * @memberof SlimChunkMetadata
     */
    'num_value'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadata
     */
    'tag_set'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadata
     */
    'time_stamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadata
     */
    'tracking_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadata
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof SlimChunkMetadata
     */
    'weight': number;
}
/**
 * 
 * @export
 * @interface SlimChunkMetadataWithArrayTagSet
 */
export interface SlimChunkMetadataWithArrayTagSet {
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadataWithArrayTagSet
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadataWithArrayTagSet
     */
    'dataset_id': string;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadataWithArrayTagSet
     */
    'id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SlimChunkMetadataWithArrayTagSet
     */
    'image_urls'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadataWithArrayTagSet
     */
    'link'?: string | null;
    /**
     * 
     * @type {GeoInfo}
     * @memberof SlimChunkMetadataWithArrayTagSet
     */
    'location'?: GeoInfo | null;
    /**
     * 
     * @type {any}
     * @memberof SlimChunkMetadataWithArrayTagSet
     */
    'metadata'?: any | null;
    /**
     * 
     * @type {number}
     * @memberof SlimChunkMetadataWithArrayTagSet
     */
    'num_value'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof SlimChunkMetadataWithArrayTagSet
     */
    'tag_set'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadataWithArrayTagSet
     */
    'time_stamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadataWithArrayTagSet
     */
    'tracking_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadataWithArrayTagSet
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof SlimChunkMetadataWithArrayTagSet
     */
    'weight': number;
}
/**
 * 
 * @export
 * @interface SlimChunkMetadataWithScore
 */
export interface SlimChunkMetadataWithScore {
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadataWithScore
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadataWithScore
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadataWithScore
     */
    'link'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof SlimChunkMetadataWithScore
     */
    'metadata'?: any | null;
    /**
     * 
     * @type {number}
     * @memberof SlimChunkMetadataWithScore
     */
    'score': number;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadataWithScore
     */
    'tag_set'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadataWithScore
     */
    'time_stamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadataWithScore
     */
    'tracking_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadataWithScore
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof SlimChunkMetadataWithScore
     */
    'weight': number;
}
/**
 * 
 * @export
 * @interface SlimUser
 */
export interface SlimUser {
    /**
     * 
     * @type {string}
     * @memberof SlimUser
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof SlimUser
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SlimUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SlimUser
     */
    'name'?: string | null;
    /**
     * 
     * @type {Array<Organization>}
     * @memberof SlimUser
     */
    'orgs': Array<Organization>;
    /**
     * 
     * @type {Array<UserOrganization>}
     * @memberof SlimUser
     */
    'user_orgs': Array<UserOrganization>;
}
/**
 * 
 * @export
 * @interface SortByField
 */
export interface SortByField {
    /**
     * 
     * @type {SortOrder}
     * @memberof SortByField
     */
    'direction'?: SortOrder | null;
    /**
     * Field to sort by. This has to be a numeric field with a Qdrant `Range` index on it. i.e. num_value and timestamp
     * @type {string}
     * @memberof SortByField
     */
    'field': string;
    /**
     * How many results to pull in before the sort
     * @type {number}
     * @memberof SortByField
     */
    'prefetch_amount'?: number | null;
}


/**
 * 
 * @export
 * @interface SortBySearchType
 */
export interface SortBySearchType {
    /**
     * How many results to pull in before the rerabj
     * @type {number}
     * @memberof SortBySearchType
     */
    'prefetch_amount'?: number | null;
    /**
     * Query to use for prefetching defaults to the search query
     * @type {string}
     * @memberof SortBySearchType
     */
    'rerank_query'?: string | null;
    /**
     * 
     * @type {ReRankOptions}
     * @memberof SortBySearchType
     */
    'rerank_type': ReRankOptions;
}


/**
 * Sort Options lets you specify different methods to rerank the chunks in the result set. If not specified, this defaults to the score of the chunks.
 * @export
 * @interface SortOptions
 */
export interface SortOptions {
    /**
     * 
     * @type {GeoInfoWithBias}
     * @memberof SortOptions
     */
    'location_bias'?: GeoInfoWithBias | null;
    /**
     * 
     * @type {QdrantSortBy}
     * @memberof SortOptions
     */
    'sort_by'?: QdrantSortBy | null;
    /**
     * Tag weights is a JSON object which can be used to boost the ranking of chunks with certain tags. This is useful for when you want to be able to bias towards chunks with a certain tag on the fly. The keys are the tag names and the values are the weights.
     * @type {{ [key: string]: number; }}
     * @memberof SortOptions
     */
    'tag_weights'?: { [key: string]: number; } | null;
    /**
     * Set use_weights to true to use the weights of the chunks in the result set in order to sort them. If not specified, this defaults to true.
     * @type {boolean}
     * @memberof SortOptions
     */
    'use_weights'?: boolean | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SortOrder = {
    Desc: 'desc',
    Asc: 'asc'
} as const;

export type SortOrder = typeof SortOrder[keyof typeof SortOrder];


/**
 * 
 * @export
 * @interface StripeInvoice
 */
export interface StripeInvoice {
    /**
     * 
     * @type {string}
     * @memberof StripeInvoice
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof StripeInvoice
     */
    'hosted_invoice_url': string;
    /**
     * 
     * @type {string}
     * @memberof StripeInvoice
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StripeInvoice
     */
    'org_id': string;
    /**
     * 
     * @type {string}
     * @memberof StripeInvoice
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof StripeInvoice
     */
    'stripe_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof StripeInvoice
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface StripePlan
 */
export interface StripePlan {
    /**
     * 
     * @type {number}
     * @memberof StripePlan
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof StripePlan
     */
    'chunk_count': number;
    /**
     * 
     * @type {string}
     * @memberof StripePlan
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof StripePlan
     */
    'dataset_count': number;
    /**
     * 
     * @type {number}
     * @memberof StripePlan
     */
    'file_storage': number;
    /**
     * 
     * @type {string}
     * @memberof StripePlan
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof StripePlan
     */
    'message_count': number;
    /**
     * 
     * @type {string}
     * @memberof StripePlan
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StripePlan
     */
    'stripe_id': string;
    /**
     * 
     * @type {string}
     * @memberof StripePlan
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof StripePlan
     */
    'user_count': number;
}
/**
 * 
 * @export
 * @interface StripeSubscription
 */
export interface StripeSubscription {
    /**
     * 
     * @type {string}
     * @memberof StripeSubscription
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof StripeSubscription
     */
    'current_period_end'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StripeSubscription
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StripeSubscription
     */
    'organization_id': string;
    /**
     * 
     * @type {string}
     * @memberof StripeSubscription
     */
    'plan_id': string;
    /**
     * 
     * @type {string}
     * @memberof StripeSubscription
     */
    'stripe_id': string;
    /**
     * 
     * @type {string}
     * @memberof StripeSubscription
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SuggestType = {
    Question: 'question',
    Keyword: 'keyword',
    Semantic: 'semantic'
} as const;

export type SuggestType = typeof SuggestType[keyof typeof SuggestType];


/**
 * 
 * @export
 * @interface SuggestedQueriesReqPayload
 */
export interface SuggestedQueriesReqPayload {
    /**
     * Context is the context of the query. This can be any string under 15 words and 200 characters. The context will be used to generate the suggested queries. Defaults to None.
     * @type {string}
     * @memberof SuggestedQueriesReqPayload
     */
    'context'?: string | null;
    /**
     * 
     * @type {ChunkFilter}
     * @memberof SuggestedQueriesReqPayload
     */
    'filters'?: ChunkFilter | null;
    /**
     * The query to base the generated suggested queries off of using RAG. A hybrid search for 10 chunks from your dataset using this query will be performed and the context of the chunks will be used to generate the suggested queries.
     * @type {string}
     * @memberof SuggestedQueriesReqPayload
     */
    'query'?: string | null;
    /**
     * 
     * @type {SearchMethod}
     * @memberof SuggestedQueriesReqPayload
     */
    'search_type'?: SearchMethod | null;
    /**
     * 
     * @type {SuggestType}
     * @memberof SuggestedQueriesReqPayload
     */
    'suggestion_type'?: SuggestType | null;
}


/**
 * 
 * @export
 * @interface SuggestedQueriesResponse
 */
export interface SuggestedQueriesResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof SuggestedQueriesResponse
     */
    'queries': Array<string>;
}
/**
 * 
 * @export
 * @interface TagsWithCount
 */
export interface TagsWithCount {
    /**
     * 
     * @type {number}
     * @memberof TagsWithCount
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof TagsWithCount
     */
    'tag': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TopDatasetsRequestTypes = {
    Search: 'search',
    Rag: 'rag',
    Recommendation: 'recommendation'
} as const;

export type TopDatasetsRequestTypes = typeof TopDatasetsRequestTypes[keyof typeof TopDatasetsRequestTypes];


/**
 * 
 * @export
 * @interface TopDatasetsResponse
 */
export interface TopDatasetsResponse {
    /**
     * 
     * @type {string}
     * @memberof TopDatasetsResponse
     */
    'dataset_id': string;
    /**
     * 
     * @type {string}
     * @memberof TopDatasetsResponse
     */
    'dataset_tracking_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TopDatasetsResponse
     */
    'total_queries': number;
}
/**
 * 
 * @export
 * @interface Topic
 */
export interface Topic {
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'dataset_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof Topic
     */
    'deleted': boolean;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'owner_id': string;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'updated_at': string;
}
/**
 * Typo Options lets you specify different methods to correct typos in the query. If not specified, typos will not be corrected.
 * @export
 * @interface TypoOptions
 */
export interface TypoOptions {
    /**
     * Set correct_typos to true to correct typos in the query. If not specified, this defaults to false.
     * @type {boolean}
     * @memberof TypoOptions
     */
    'correct_typos'?: boolean | null;
    /**
     * Words that should not be corrected. If not specified, this defaults to an empty list.
     * @type {Array<string>}
     * @memberof TypoOptions
     */
    'disable_on_word'?: Array<string> | null;
    /**
     * 
     * @type {TypoRange}
     * @memberof TypoOptions
     */
    'one_typo_word_range'?: TypoRange | null;
    /**
     * Auto-require non-english words present in the dataset to exist in each results chunk_html text. If not specified, this defaults to true.
     * @type {boolean}
     * @memberof TypoOptions
     */
    'prioritize_domain_specifc_words'?: boolean | null;
    /**
     * 
     * @type {TypoRange}
     * @memberof TypoOptions
     */
    'two_typo_word_range'?: TypoRange | null;
}
/**
 * The TypoRange struct is used to specify the range of which the query will be corrected if it has a typo.
 * @export
 * @interface TypoRange
 */
export interface TypoRange {
    /**
     * The maximum number of characters that the query will be corrected if it has a typo. If not specified, this defaults to 8.
     * @type {number}
     * @memberof TypoRange
     */
    'max'?: number | null;
    /**
     * The minimum number of characters that the query will be corrected if it has a typo. If not specified, this defaults to 5.
     * @type {number}
     * @memberof TypoRange
     */
    'min': number;
}
/**
 * 
 * @export
 * @interface UpdateAllOrgDatasetConfigsReqPayload
 */
export interface UpdateAllOrgDatasetConfigsReqPayload {
    /**
     * The new configuration for all datasets in the organization. Only the specified keys in the configuration object will be changed per dataset such that you can preserve dataset unique values.
     * @type {any}
     * @memberof UpdateAllOrgDatasetConfigsReqPayload
     */
    'dataset_config': any;
}
/**
 * 
 * @export
 * @interface UpdateChunkByTrackingIdData
 */
export interface UpdateChunkByTrackingIdData {
    /**
     * HTML content of the chunk you want to update. This can also be plaintext. The innerText of the HTML will be used to create the embedding vector. The point of using HTML is for convienience, as some users have applications where users submit HTML content. If no chunk_html is provided, the existing chunk_html will be used.
     * @type {string}
     * @memberof UpdateChunkByTrackingIdData
     */
    'chunk_html'?: string | null;
    /**
     * Convert HTML to raw text before processing to avoid adding noise to the vector embeddings. By default this is true. If you are using HTML content that you want to be included in the vector embeddings, set this to false.
     * @type {boolean}
     * @memberof UpdateChunkByTrackingIdData
     */
    'convert_html_to_text'?: boolean | null;
    /**
     * Group ids are the ids of the groups that the chunk should be placed into. This is useful for when you want to update a chunk and add it to a group or multiple groups in one request.
     * @type {Array<string>}
     * @memberof UpdateChunkByTrackingIdData
     */
    'group_ids'?: Array<string> | null;
    /**
     * Group tracking_ids are the tracking_ids of the groups that the chunk should be placed into. This is useful for when you want to update a chunk and add it to a group or multiple groups in one request.
     * @type {Array<string>}
     * @memberof UpdateChunkByTrackingIdData
     */
    'group_tracking_ids'?: Array<string> | null;
    /**
     * Link of the chunk you want to update. This can also be any string. Frequently, this is a link to the source of the chunk. The link value will not affect the embedding creation. If no link is provided, the existing link will be used.
     * @type {string}
     * @memberof UpdateChunkByTrackingIdData
     */
    'link'?: string | null;
    /**
     * The metadata is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata. If no metadata is provided, the existing metadata will be used.
     * @type {any}
     * @memberof UpdateChunkByTrackingIdData
     */
    'metadata'?: any | null;
    /**
     * Time_stamp should be an ISO 8601 combined date and time without timezone. It is used for time window filtering and recency-biasing search results. If no time_stamp is provided, the existing time_stamp will be used.
     * @type {string}
     * @memberof UpdateChunkByTrackingIdData
     */
    'time_stamp'?: string | null;
    /**
     * Tracking_id of the chunk you want to update. This is required to match an existing chunk.
     * @type {string}
     * @memberof UpdateChunkByTrackingIdData
     */
    'tracking_id': string;
    /**
     * Weight is a float which can be used to bias search results. This is useful for when you want to bias search results for a chunk. The magnitude only matters relative to other chunks in the chunk\'s dataset dataset. If no weight is provided, the existing weight will be used.
     * @type {number}
     * @memberof UpdateChunkByTrackingIdData
     */
    'weight'?: number | null;
}
/**
 * 
 * @export
 * @interface UpdateChunkGroupReqPayload
 */
export interface UpdateChunkGroupReqPayload {
    /**
     * Description to assign to the chunk_group. Convenience field for you to avoid having to remember what the group is for. If not provided, the description will not be updated.
     * @type {string}
     * @memberof UpdateChunkGroupReqPayload
     */
    'description'?: string | null;
    /**
     * Id of the chunk_group to update.
     * @type {string}
     * @memberof UpdateChunkGroupReqPayload
     */
    'group_id'?: string | null;
    /**
     * Optional metadata to assign to the chunk_group. This is a JSON object that can store any additional information you want to associate with the chunks inside of the chunk_group.
     * @type {any}
     * @memberof UpdateChunkGroupReqPayload
     */
    'metadata'?: any | null;
    /**
     * Name to assign to the chunk_group. Does not need to be unique. If not provided, the name will not be updated.
     * @type {string}
     * @memberof UpdateChunkGroupReqPayload
     */
    'name'?: string | null;
    /**
     * Optional tags to assign to the chunk_group. This is a list of strings that can be used to categorize the chunks inside the chunk_group.
     * @type {Array<string>}
     * @memberof UpdateChunkGroupReqPayload
     */
    'tag_set'?: Array<string> | null;
    /**
     * Tracking Id of the chunk_group to update.
     * @type {string}
     * @memberof UpdateChunkGroupReqPayload
     */
    'tracking_id'?: string | null;
    /**
     * Flag to update the chunks in the group. If true, each chunk in the group will be updated by appending the group\'s tags to the chunk\'s tags. Default is false.
     * @type {boolean}
     * @memberof UpdateChunkGroupReqPayload
     */
    'update_chunks'?: boolean | null;
}
/**
 * 
 * @export
 * @interface UpdateChunkReqPayload
 */
export interface UpdateChunkReqPayload {
    /**
     * HTML content of the chunk you want to update. This can also be plaintext. The innerText of the HTML will be used to create the embedding vector. The point of using HTML is for convienience, as some users have applications where users submit HTML content. If no chunk_html is provided, the existing chunk_html will be used.
     * @type {string}
     * @memberof UpdateChunkReqPayload
     */
    'chunk_html'?: string | null;
    /**
     * Id of the chunk you want to update. You can provide either the chunk_id or the tracking_id. If both are provided, the chunk_id will be used.
     * @type {string}
     * @memberof UpdateChunkReqPayload
     */
    'chunk_id'?: string | null;
    /**
     * Convert HTML to raw text before processing to avoid adding noise to the vector embeddings. By default this is true. If you are using HTML content that you want to be included in the vector embeddings, set this to false.
     * @type {boolean}
     * @memberof UpdateChunkReqPayload
     */
    'convert_html_to_text'?: boolean | null;
    /**
     * 
     * @type {FullTextBoost}
     * @memberof UpdateChunkReqPayload
     */
    'fulltext_boost'?: FullTextBoost | null;
    /**
     * Group ids are the ids of the groups that the chunk should be placed into. This is useful for when you want to update a chunk and add it to a group or multiple groups in one request.
     * @type {Array<string>}
     * @memberof UpdateChunkReqPayload
     */
    'group_ids'?: Array<string> | null;
    /**
     * Group tracking_ids are the tracking_ids of the groups that the chunk should be placed into. This is useful for when you want to update a chunk and add it to a group or multiple groups in one request.
     * @type {Array<string>}
     * @memberof UpdateChunkReqPayload
     */
    'group_tracking_ids'?: Array<string> | null;
    /**
     * Image urls are a list of urls to images that are associated with the chunk. This is useful for when you want to associate images with a chunk. If no image_urls are provided, the existing image_urls will be used.
     * @type {Array<string>}
     * @memberof UpdateChunkReqPayload
     */
    'image_urls'?: Array<string> | null;
    /**
     * Link of the chunk you want to update. This can also be any string. Frequently, this is a link to the source of the chunk. The link value will not affect the embedding creation. If no link is provided, the existing link will be used.
     * @type {string}
     * @memberof UpdateChunkReqPayload
     */
    'link'?: string | null;
    /**
     * 
     * @type {GeoInfo}
     * @memberof UpdateChunkReqPayload
     */
    'location'?: GeoInfo | null;
    /**
     * The metadata is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata. If no metadata is provided, the existing metadata will be used.
     * @type {any}
     * @memberof UpdateChunkReqPayload
     */
    'metadata'?: any | null;
    /**
     * Num value is an arbitrary numerical value that can be used to filter chunks. This is useful for when you want to filter chunks by numerical value. If no num_value is provided, the existing num_value will be used.
     * @type {number}
     * @memberof UpdateChunkReqPayload
     */
    'num_value'?: number | null;
    /**
     * 
     * @type {SemanticBoost}
     * @memberof UpdateChunkReqPayload
     */
    'semantic_boost'?: SemanticBoost | null;
    /**
     * Tag set is a list of tags. This can be used to filter chunks by tag. Unlike with metadata filtering, HNSW indices will exist for each tag such that there is not a performance hit for filtering on them. If no tag_set is provided, the existing tag_set will be used.
     * @type {Array<string>}
     * @memberof UpdateChunkReqPayload
     */
    'tag_set'?: Array<string> | null;
    /**
     * Time_stamp should be an ISO 8601 combined date and time without timezone. It is used for time window filtering and recency-biasing search results. If no time_stamp is provided, the existing time_stamp will be used.
     * @type {string}
     * @memberof UpdateChunkReqPayload
     */
    'time_stamp'?: string | null;
    /**
     * Tracking_id of the chunk you want to update. This is required to match an existing chunk.
     * @type {string}
     * @memberof UpdateChunkReqPayload
     */
    'tracking_id'?: string | null;
    /**
     * Weight is a float which can be used to bias search results. This is useful for when you want to bias search results for a chunk. The magnitude only matters relative to other chunks in the chunk\'s dataset dataset. If no weight is provided, the existing weight will be used.
     * @type {number}
     * @memberof UpdateChunkReqPayload
     */
    'weight'?: number | null;
}
/**
 * 
 * @export
 * @interface UpdateDatasetRequest
 */
export interface UpdateDatasetRequest {
    /**
     * 
     * @type {CrawlOptions}
     * @memberof UpdateDatasetRequest
     */
    'crawl_options'?: CrawlOptions | null;
    /**
     * The id of the dataset you want to update.
     * @type {string}
     * @memberof UpdateDatasetRequest
     */
    'dataset_id'?: string | null;
    /**
     * The new name of the dataset. Must be unique within the organization. If not provided, the name will not be updated.
     * @type {string}
     * @memberof UpdateDatasetRequest
     */
    'dataset_name'?: string | null;
    /**
     * Optional new tracking ID for the dataset. Can be used to track the dataset in external systems. Must be unique within the organization. If not provided, the tracking ID will not be updated. Strongly recommended to not use a valid uuid value as that will not work with the TR-Dataset header.
     * @type {string}
     * @memberof UpdateDatasetRequest
     */
    'new_tracking_id'?: string | null;
    /**
     * 
     * @type {DatasetConfigurationDTO}
     * @memberof UpdateDatasetRequest
     */
    'server_configuration'?: DatasetConfigurationDTO | null;
    /**
     * The tracking ID of the dataset you want to update.
     * @type {string}
     * @memberof UpdateDatasetRequest
     */
    'tracking_id'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateGroupByTrackingIDReqPayload
 */
export interface UpdateGroupByTrackingIDReqPayload {
    /**
     * Description to assign to the chunk_group. Convenience field for you to avoid having to remember what the group is for. If not provided, the description will not be updated.
     * @type {string}
     * @memberof UpdateGroupByTrackingIDReqPayload
     */
    'description'?: string | null;
    /**
     * Optional metadata to assign to the chunk_group. This is a JSON object that can store any additional information you want to associate with the chunks inside of the chunk_group.
     * @type {any}
     * @memberof UpdateGroupByTrackingIDReqPayload
     */
    'metadata'?: any | null;
    /**
     * Name to assign to the chunk_group. Does not need to be unique. If not provided, the name will not be updated.
     * @type {string}
     * @memberof UpdateGroupByTrackingIDReqPayload
     */
    'name'?: string | null;
    /**
     * Optional tags to assign to the chunk_group. This is a list of strings that can be used to categorize the chunks inside the chunk_group.
     * @type {Array<string>}
     * @memberof UpdateGroupByTrackingIDReqPayload
     */
    'tag_set'?: Array<string> | null;
    /**
     * Tracking Id of the chunk_group to update.
     * @type {string}
     * @memberof UpdateGroupByTrackingIDReqPayload
     */
    'tracking_id': string;
}
/**
 * 
 * @export
 * @interface UpdateOrganizationReqPayload
 */
export interface UpdateOrganizationReqPayload {
    /**
     * The new name of the organization. If not provided, the name will not be updated.
     * @type {string}
     * @memberof UpdateOrganizationReqPayload
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateTopicReqPayload
 */
export interface UpdateTopicReqPayload {
    /**
     * The new name of the topic. A name is not generated from this field, it is used as-is.
     * @type {string}
     * @memberof UpdateTopicReqPayload
     */
    'name': string;
    /**
     * The id of the topic to target.
     * @type {string}
     * @memberof UpdateTopicReqPayload
     */
    'topic_id': string;
}
/**
 * 
 * @export
 * @interface UpdateUserOrgRoleData
 */
export interface UpdateUserOrgRoleData {
    /**
     * Either 0 (user), 1 (admin), or 2 (owner). If not provided, the current role will be used. The auth\'ed user must have a role greater than or equal to the role being assigned.
     * @type {number}
     * @memberof UpdateUserOrgRoleData
     */
    'role': number;
    /**
     * The id of the user to update, if not provided, the auth\'ed user will be updated. If provided, the role of the auth\'ed user or api key must be an admin (1) or owner (2) of the organization.
     * @type {string}
     * @memberof UpdateUserOrgRoleData
     */
    'user_id'?: string | null;
}
/**
 * 
 * @export
 * @interface UploadFileReqPayload
 */
export interface UploadFileReqPayload {
    /**
     * Base64 encoded file. This is the standard base64url encoding.
     * @type {string}
     * @memberof UploadFileReqPayload
     */
    'base64_file': string;
    /**
     * Create chunks is a boolean which determines whether or not to create chunks from the file. If false, you can manually chunk the file and send the chunks to the create_chunk endpoint with the file_id to associate chunks with the file. Meant mostly for advanced users.
     * @type {boolean}
     * @memberof UploadFileReqPayload
     */
    'create_chunks'?: boolean | null;
    /**
     * Description is an optional convience field so you do not have to remember what the file contains or is about. It will be included on the group resulting from the file which will hold its chunk.
     * @type {string}
     * @memberof UploadFileReqPayload
     */
    'description'?: string | null;
    /**
     * Name of the file being uploaded, including the extension.
     * @type {string}
     * @memberof UploadFileReqPayload
     */
    'file_name': string;
    /**
     * Group tracking id is an optional field which allows you to specify the tracking id of the group that is created from the file. Chunks created will be created with the tracking id of `group_tracking_id|<index of chunk>`
     * @type {string}
     * @memberof UploadFileReqPayload
     */
    'group_tracking_id'?: string | null;
    /**
     * Link to the file. This can also be any string. This can be used to filter when searching for the file\'s resulting chunks. The link value will not affect embedding creation.
     * @type {string}
     * @memberof UploadFileReqPayload
     */
    'link'?: string | null;
    /**
     * Metadata is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata. Will be passed down to the file\'s chunks.
     * @type {any}
     * @memberof UploadFileReqPayload
     */
    'metadata'?: any | null;
    /**
     * Rebalance chunks is an optional field which allows you to specify whether or not to rebalance the chunks created from the file. If not specified, the default true is used. If true, Trieve will evenly distribute remainder splits across chunks such that 66 splits with a `target_splits_per_chunk` of 20 will result in 3 chunks with 22 splits each.
     * @type {boolean}
     * @memberof UploadFileReqPayload
     */
    'rebalance_chunks'?: boolean | null;
    /**
     * Split delimiters is an optional field which allows you to specify the delimiters to use when splitting the file before chunking the text. If not specified, the default [.!?\\n] are used to split into sentences. However, you may want to use spaces or other delimiters.
     * @type {Array<string>}
     * @memberof UploadFileReqPayload
     */
    'split_delimiters'?: Array<string> | null;
    /**
     * Tag set is a comma separated list of tags which will be passed down to the chunks made from the file. Tags are used to filter chunks when searching. HNSW indices are created for each tag such that there is no performance loss when filtering on them.
     * @type {Array<string>}
     * @memberof UploadFileReqPayload
     */
    'tag_set'?: Array<string> | null;
    /**
     * Target splits per chunk. This is an optional field which allows you to specify the number of splits you want per chunk. If not specified, the default 20 is used. However, you may want to use a different number.
     * @type {number}
     * @memberof UploadFileReqPayload
     */
    'target_splits_per_chunk'?: number | null;
    /**
     * Time stamp should be an ISO 8601 combined date and time without timezone. Time_stamp is used for time window filtering and recency-biasing search results. Will be passed down to the file\'s chunks.
     * @type {string}
     * @memberof UploadFileReqPayload
     */
    'time_stamp'?: string | null;
}
/**
 * 
 * @export
 * @interface UploadFileResult
 */
export interface UploadFileResult {
    /**
     * 
     * @type {any}
     * @memberof UploadFileResult
     */
    'file_metadata': any;
}
/**
 * 
 * @export
 * @interface UsageGraphPoint
 */
export interface UsageGraphPoint {
    /**
     * 
     * @type {number}
     * @memberof UsageGraphPoint
     */
    'requests': number;
    /**
     * 
     * @type {string}
     * @memberof UsageGraphPoint
     */
    'time_stamp': string;
}
/**
 * 
 * @export
 * @interface UserOrganization
 */
export interface UserOrganization {
    /**
     * 
     * @type {string}
     * @memberof UserOrganization
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof UserOrganization
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserOrganization
     */
    'organization_id': string;
    /**
     * 
     * @type {number}
     * @memberof UserOrganization
     */
    'role': number;
    /**
     * 
     * @type {string}
     * @memberof UserOrganization
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof UserOrganization
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * The name of the event
     * @type {string}
     * @memberof View
     */
    'event_name': string;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'event_type': ViewEventTypeEnum;
    /**
     * The items that were viewed
     * @type {Array<string>}
     * @memberof View
     */
    'items': Array<string>;
    /**
     * Any other metadata associated with the event
     * @type {any}
     * @memberof View
     */
    'metadata'?: any | null;
    /**
     * 
     * @type {RequestInfo}
     * @memberof View
     */
    'request'?: RequestInfo | null;
    /**
     * The user id of the user who viewed the items
     * @type {string}
     * @memberof View
     */
    'user_id'?: string | null;
}

export const ViewEventTypeEnum = {
    View: 'view'
} as const;

export type ViewEventTypeEnum = typeof ViewEventTypeEnum[keyof typeof ViewEventTypeEnum];

/**
 * 
 * @export
 * @interface WorkerEvent
 */
export interface WorkerEvent {
    /**
     * 
     * @type {string}
     * @memberof WorkerEvent
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof WorkerEvent
     */
    'dataset_id': string;
    /**
     * 
     * @type {string}
     * @memberof WorkerEvent
     */
    'event_data': string;
    /**
     * 
     * @type {string}
     * @memberof WorkerEvent
     */
    'event_type': string;
    /**
     * 
     * @type {string}
     * @memberof WorkerEvent
     */
    'id': string;
}

/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This route allows you to view all user events.
         * @summary Get All User Events
         * @param {GetEventsRequestBody} getEventsRequestBody JSON request payload to filter the events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEvents: async (getEventsRequestBody: GetEventsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getEventsRequestBody' is not null or undefined
            assertParamExists('getAllEvents', 'getEventsRequestBody', getEventsRequestBody)
            const localVarPath = `/api/analytics/events/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEventsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route allows you to view the cluster analytics for a dataset.
         * @summary Get Cluster Analytics
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {ClusterAnalytics} clusterAnalytics JSON request payload to filter the graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterAnalytics: async (tRDataset: string, clusterAnalytics: ClusterAnalytics, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getClusterAnalytics', 'tRDataset', tRDataset)
            // verify required parameter 'clusterAnalytics' is not null or undefined
            assertParamExists('getClusterAnalytics', 'clusterAnalytics', clusterAnalytics)
            const localVarPath = `/api/analytics/search/cluster`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterAnalytics, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route allows you to view the CTR analytics for a dataset.
         * @summary Get CTR Analytics
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {CTRAnalytics} cTRAnalytics JSON request payload to filter the graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCtrAnalytics: async (tRDataset: string, cTRAnalytics: CTRAnalytics, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getCtrAnalytics', 'tRDataset', tRDataset)
            // verify required parameter 'cTRAnalytics' is not null or undefined
            assertParamExists('getCtrAnalytics', 'cTRAnalytics', cTRAnalytics)
            const localVarPath = `/api/analytics/events/ctr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cTRAnalytics, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route allows you to view an user event by its ID. You can pass in any type of event and get the details for that event.
         * @summary Get User Event By ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} eventId The event id to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventById: async (tRDataset: string, eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getEventById', 'tRDataset', tRDataset)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventById', 'eventId', eventId)
            const localVarPath = `/api/analytics/events/{event_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route allows you to view the RAG analytics for a dataset.
         * @summary Get RAG Analytics
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {RAGAnalytics} rAGAnalytics JSON request payload to filter the graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRagAnalytics: async (tRDataset: string, rAGAnalytics: RAGAnalytics, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getRagAnalytics', 'tRDataset', tRDataset)
            // verify required parameter 'rAGAnalytics' is not null or undefined
            assertParamExists('getRagAnalytics', 'rAGAnalytics', rAGAnalytics)
            const localVarPath = `/api/analytics/rag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rAGAnalytics, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route allows you to view the recommendation analytics for a dataset.
         * @summary Get Recommendation Analytics
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {RecommendationAnalytics} recommendationAnalytics JSON request payload to filter the graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendationAnalytics: async (tRDataset: string, recommendationAnalytics: RecommendationAnalytics, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getRecommendationAnalytics', 'tRDataset', tRDataset)
            // verify required parameter 'recommendationAnalytics' is not null or undefined
            assertParamExists('getRecommendationAnalytics', 'recommendationAnalytics', recommendationAnalytics)
            const localVarPath = `/api/analytics/recommendations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recommendationAnalytics, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route allows you to view the search analytics for a dataset.
         * @summary Get Search Analytics
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {SearchAnalytics} searchAnalytics JSON request payload to filter the graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchAnalytics: async (tRDataset: string, searchAnalytics: SearchAnalytics, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getSearchAnalytics', 'tRDataset', tRDataset)
            // verify required parameter 'searchAnalytics' is not null or undefined
            assertParamExists('getSearchAnalytics', 'searchAnalytics', searchAnalytics)
            const localVarPath = `/api/analytics/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchAnalytics, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route allows you to view the top datasets for a given type.
         * @summary Get Top Datasets
         * @param {string} tROrganization The organization id to use for the request
         * @param {GetTopDatasetsRequestBody} getTopDatasetsRequestBody JSON request payload to filter the top datasets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopDatasets: async (tROrganization: string, getTopDatasetsRequestBody: GetTopDatasetsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('getTopDatasets', 'tROrganization', tROrganization)
            // verify required parameter 'getTopDatasetsRequestBody' is not null or undefined
            assertParamExists('getTopDatasets', 'getTopDatasetsRequestBody', getTopDatasetsRequestBody)
            const localVarPath = `/api/analytics/top`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getTopDatasetsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route allows you to send clickstream data to the system. Clickstream data is used to fine-tune the re-ranking of search results and recommendations.
         * @summary Send CTR Data
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {CTRDataRequestBody} cTRDataRequestBody JSON request payload to send CTR data
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        sendCtrData: async (tRDataset: string, cTRDataRequestBody: CTRDataRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('sendCtrData', 'tRDataset', tRDataset)
            // verify required parameter 'cTRDataRequestBody' is not null or undefined
            assertParamExists('sendCtrData', 'cTRDataRequestBody', cTRDataRequestBody)
            const localVarPath = `/api/analytics/ctr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cTRDataRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route allows you to send user event data to the system.
         * @summary Send User Event Data
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {EventTypes} eventTypes JSON request payload to send event data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEventData: async (tRDataset: string, eventTypes: EventTypes, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('sendEventData', 'tRDataset', tRDataset)
            // verify required parameter 'eventTypes' is not null or undefined
            assertParamExists('sendEventData', 'eventTypes', eventTypes)
            const localVarPath = `/api/analytics/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventTypes, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route allows you to Rate a RAG query.
         * @summary Rate RAG
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {RateQueryRequest} rateQueryRequest JSON request payload to rate a RAG query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRagQueryRating: async (tRDataset: string, rateQueryRequest: RateQueryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('setRagQueryRating', 'tRDataset', tRDataset)
            // verify required parameter 'rateQueryRequest' is not null or undefined
            assertParamExists('setRagQueryRating', 'rateQueryRequest', rateQueryRequest)
            const localVarPath = `/api/analytics/rag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rateQueryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route allows you to Rate a search query.
         * @summary Rate Search
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {RateQueryRequest} rateQueryRequest JSON request payload to rate a search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSearchQueryRating: async (tRDataset: string, rateQueryRequest: RateQueryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('setSearchQueryRating', 'tRDataset', tRDataset)
            // verify required parameter 'rateQueryRequest' is not null or undefined
            assertParamExists('setSearchQueryRating', 'rateQueryRequest', rateQueryRequest)
            const localVarPath = `/api/analytics/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rateQueryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * This route allows you to view all user events.
         * @summary Get All User Events
         * @param {GetEventsRequestBody} getEventsRequestBody JSON request payload to filter the events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEvents(getEventsRequestBody: GetEventsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEvents(getEventsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getAllEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This route allows you to view the cluster analytics for a dataset.
         * @summary Get Cluster Analytics
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {ClusterAnalytics} clusterAnalytics JSON request payload to filter the graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterAnalytics(tRDataset: string, clusterAnalytics: ClusterAnalytics, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterAnalyticsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterAnalytics(tRDataset, clusterAnalytics, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getClusterAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This route allows you to view the CTR analytics for a dataset.
         * @summary Get CTR Analytics
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {CTRAnalytics} cTRAnalytics JSON request payload to filter the graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCtrAnalytics(tRDataset: string, cTRAnalytics: CTRAnalytics, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CTRAnalyticsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCtrAnalytics(tRDataset, cTRAnalytics, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getCtrAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This route allows you to view an user event by its ID. You can pass in any type of event and get the details for that event.
         * @summary Get User Event By ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} eventId The event id to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventById(tRDataset: string, eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventById(tRDataset, eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getEventById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This route allows you to view the RAG analytics for a dataset.
         * @summary Get RAG Analytics
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {RAGAnalytics} rAGAnalytics JSON request payload to filter the graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRagAnalytics(tRDataset: string, rAGAnalytics: RAGAnalytics, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RAGAnalyticsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRagAnalytics(tRDataset, rAGAnalytics, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getRagAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This route allows you to view the recommendation analytics for a dataset.
         * @summary Get Recommendation Analytics
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {RecommendationAnalytics} recommendationAnalytics JSON request payload to filter the graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendationAnalytics(tRDataset: string, recommendationAnalytics: RecommendationAnalytics, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecommendationAnalyticsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendationAnalytics(tRDataset, recommendationAnalytics, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getRecommendationAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This route allows you to view the search analytics for a dataset.
         * @summary Get Search Analytics
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {SearchAnalytics} searchAnalytics JSON request payload to filter the graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSearchAnalytics(tRDataset: string, searchAnalytics: SearchAnalytics, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchAnalyticsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSearchAnalytics(tRDataset, searchAnalytics, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getSearchAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This route allows you to view the top datasets for a given type.
         * @summary Get Top Datasets
         * @param {string} tROrganization The organization id to use for the request
         * @param {GetTopDatasetsRequestBody} getTopDatasetsRequestBody JSON request payload to filter the top datasets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopDatasets(tROrganization: string, getTopDatasetsRequestBody: GetTopDatasetsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TopDatasetsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopDatasets(tROrganization, getTopDatasetsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getTopDatasets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This route allows you to send clickstream data to the system. Clickstream data is used to fine-tune the re-ranking of search results and recommendations.
         * @summary Send CTR Data
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {CTRDataRequestBody} cTRDataRequestBody JSON request payload to send CTR data
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async sendCtrData(tRDataset: string, cTRDataRequestBody: CTRDataRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendCtrData(tRDataset, cTRDataRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.sendCtrData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This route allows you to send user event data to the system.
         * @summary Send User Event Data
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {EventTypes} eventTypes JSON request payload to send event data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendEventData(tRDataset: string, eventTypes: EventTypes, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendEventData(tRDataset, eventTypes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.sendEventData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This route allows you to Rate a RAG query.
         * @summary Rate RAG
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {RateQueryRequest} rateQueryRequest JSON request payload to rate a RAG query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRagQueryRating(tRDataset: string, rateQueryRequest: RateQueryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRagQueryRating(tRDataset, rateQueryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.setRagQueryRating']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This route allows you to Rate a search query.
         * @summary Rate Search
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {RateQueryRequest} rateQueryRequest JSON request payload to rate a search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSearchQueryRating(tRDataset: string, rateQueryRequest: RateQueryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSearchQueryRating(tRDataset, rateQueryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.setSearchQueryRating']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsApiFp(configuration)
    return {
        /**
         * This route allows you to view all user events.
         * @summary Get All User Events
         * @param {GetEventsRequestBody} getEventsRequestBody JSON request payload to filter the events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEvents(getEventsRequestBody: GetEventsRequestBody, options?: any): AxiosPromise<GetEventsResponseBody> {
            return localVarFp.getAllEvents(getEventsRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This route allows you to view the cluster analytics for a dataset.
         * @summary Get Cluster Analytics
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {ClusterAnalytics} clusterAnalytics JSON request payload to filter the graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterAnalytics(tRDataset: string, clusterAnalytics: ClusterAnalytics, options?: any): AxiosPromise<ClusterAnalyticsResponse> {
            return localVarFp.getClusterAnalytics(tRDataset, clusterAnalytics, options).then((request) => request(axios, basePath));
        },
        /**
         * This route allows you to view the CTR analytics for a dataset.
         * @summary Get CTR Analytics
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {CTRAnalytics} cTRAnalytics JSON request payload to filter the graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCtrAnalytics(tRDataset: string, cTRAnalytics: CTRAnalytics, options?: any): AxiosPromise<CTRAnalyticsResponse> {
            return localVarFp.getCtrAnalytics(tRDataset, cTRAnalytics, options).then((request) => request(axios, basePath));
        },
        /**
         * This route allows you to view an user event by its ID. You can pass in any type of event and get the details for that event.
         * @summary Get User Event By ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} eventId The event id to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventById(tRDataset: string, eventId: string, options?: any): AxiosPromise<EventData> {
            return localVarFp.getEventById(tRDataset, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * This route allows you to view the RAG analytics for a dataset.
         * @summary Get RAG Analytics
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {RAGAnalytics} rAGAnalytics JSON request payload to filter the graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRagAnalytics(tRDataset: string, rAGAnalytics: RAGAnalytics, options?: any): AxiosPromise<RAGAnalyticsResponse> {
            return localVarFp.getRagAnalytics(tRDataset, rAGAnalytics, options).then((request) => request(axios, basePath));
        },
        /**
         * This route allows you to view the recommendation analytics for a dataset.
         * @summary Get Recommendation Analytics
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {RecommendationAnalytics} recommendationAnalytics JSON request payload to filter the graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendationAnalytics(tRDataset: string, recommendationAnalytics: RecommendationAnalytics, options?: any): AxiosPromise<RecommendationAnalyticsResponse> {
            return localVarFp.getRecommendationAnalytics(tRDataset, recommendationAnalytics, options).then((request) => request(axios, basePath));
        },
        /**
         * This route allows you to view the search analytics for a dataset.
         * @summary Get Search Analytics
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {SearchAnalytics} searchAnalytics JSON request payload to filter the graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchAnalytics(tRDataset: string, searchAnalytics: SearchAnalytics, options?: any): AxiosPromise<SearchAnalyticsResponse> {
            return localVarFp.getSearchAnalytics(tRDataset, searchAnalytics, options).then((request) => request(axios, basePath));
        },
        /**
         * This route allows you to view the top datasets for a given type.
         * @summary Get Top Datasets
         * @param {string} tROrganization The organization id to use for the request
         * @param {GetTopDatasetsRequestBody} getTopDatasetsRequestBody JSON request payload to filter the top datasets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopDatasets(tROrganization: string, getTopDatasetsRequestBody: GetTopDatasetsRequestBody, options?: any): AxiosPromise<Array<TopDatasetsResponse>> {
            return localVarFp.getTopDatasets(tROrganization, getTopDatasetsRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This route allows you to send clickstream data to the system. Clickstream data is used to fine-tune the re-ranking of search results and recommendations.
         * @summary Send CTR Data
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {CTRDataRequestBody} cTRDataRequestBody JSON request payload to send CTR data
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        sendCtrData(tRDataset: string, cTRDataRequestBody: CTRDataRequestBody, options?: any): AxiosPromise<void> {
            return localVarFp.sendCtrData(tRDataset, cTRDataRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This route allows you to send user event data to the system.
         * @summary Send User Event Data
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {EventTypes} eventTypes JSON request payload to send event data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEventData(tRDataset: string, eventTypes: EventTypes, options?: any): AxiosPromise<void> {
            return localVarFp.sendEventData(tRDataset, eventTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * This route allows you to Rate a RAG query.
         * @summary Rate RAG
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {RateQueryRequest} rateQueryRequest JSON request payload to rate a RAG query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRagQueryRating(tRDataset: string, rateQueryRequest: RateQueryRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setRagQueryRating(tRDataset, rateQueryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This route allows you to Rate a search query.
         * @summary Rate Search
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {RateQueryRequest} rateQueryRequest JSON request payload to rate a search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSearchQueryRating(tRDataset: string, rateQueryRequest: RateQueryRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setSearchQueryRating(tRDataset, rateQueryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
    /**
     * This route allows you to view all user events.
     * @summary Get All User Events
     * @param {GetEventsRequestBody} getEventsRequestBody JSON request payload to filter the events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getAllEvents(getEventsRequestBody: GetEventsRequestBody, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getAllEvents(getEventsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route allows you to view the cluster analytics for a dataset.
     * @summary Get Cluster Analytics
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {ClusterAnalytics} clusterAnalytics JSON request payload to filter the graph
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getClusterAnalytics(tRDataset: string, clusterAnalytics: ClusterAnalytics, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getClusterAnalytics(tRDataset, clusterAnalytics, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route allows you to view the CTR analytics for a dataset.
     * @summary Get CTR Analytics
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {CTRAnalytics} cTRAnalytics JSON request payload to filter the graph
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getCtrAnalytics(tRDataset: string, cTRAnalytics: CTRAnalytics, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getCtrAnalytics(tRDataset, cTRAnalytics, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route allows you to view an user event by its ID. You can pass in any type of event and get the details for that event.
     * @summary Get User Event By ID
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} eventId The event id to use for the request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getEventById(tRDataset: string, eventId: string, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getEventById(tRDataset, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route allows you to view the RAG analytics for a dataset.
     * @summary Get RAG Analytics
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {RAGAnalytics} rAGAnalytics JSON request payload to filter the graph
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getRagAnalytics(tRDataset: string, rAGAnalytics: RAGAnalytics, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getRagAnalytics(tRDataset, rAGAnalytics, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route allows you to view the recommendation analytics for a dataset.
     * @summary Get Recommendation Analytics
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {RecommendationAnalytics} recommendationAnalytics JSON request payload to filter the graph
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getRecommendationAnalytics(tRDataset: string, recommendationAnalytics: RecommendationAnalytics, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getRecommendationAnalytics(tRDataset, recommendationAnalytics, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route allows you to view the search analytics for a dataset.
     * @summary Get Search Analytics
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {SearchAnalytics} searchAnalytics JSON request payload to filter the graph
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getSearchAnalytics(tRDataset: string, searchAnalytics: SearchAnalytics, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getSearchAnalytics(tRDataset, searchAnalytics, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route allows you to view the top datasets for a given type.
     * @summary Get Top Datasets
     * @param {string} tROrganization The organization id to use for the request
     * @param {GetTopDatasetsRequestBody} getTopDatasetsRequestBody JSON request payload to filter the top datasets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getTopDatasets(tROrganization: string, getTopDatasetsRequestBody: GetTopDatasetsRequestBody, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getTopDatasets(tROrganization, getTopDatasetsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route allows you to send clickstream data to the system. Clickstream data is used to fine-tune the re-ranking of search results and recommendations.
     * @summary Send CTR Data
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {CTRDataRequestBody} cTRDataRequestBody JSON request payload to send CTR data
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public sendCtrData(tRDataset: string, cTRDataRequestBody: CTRDataRequestBody, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).sendCtrData(tRDataset, cTRDataRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route allows you to send user event data to the system.
     * @summary Send User Event Data
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {EventTypes} eventTypes JSON request payload to send event data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public sendEventData(tRDataset: string, eventTypes: EventTypes, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).sendEventData(tRDataset, eventTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route allows you to Rate a RAG query.
     * @summary Rate RAG
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {RateQueryRequest} rateQueryRequest JSON request payload to rate a RAG query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public setRagQueryRating(tRDataset: string, rateQueryRequest: RateQueryRequest, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).setRagQueryRating(tRDataset, rateQueryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route allows you to Rate a search query.
     * @summary Rate Search
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {RateQueryRequest} rateQueryRequest JSON request payload to rate a search query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public setSearchQueryRating(tRDataset: string, rateQueryRequest: RateQueryRequest, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).setSearchQueryRating(tRDataset, rateQueryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This is the callback route for the OAuth provider, it should not be called directly. Redirects to browser with set-cookie header.
         * @summary OpenID Connect callback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callback: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the user corresponding to your current auth credentials.
         * @summary Get Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will redirect you to the OAuth provider for authentication with email/pass, SSO, Google, Github, etc.
         * @summary Login
         * @param {string | null} [organizationId] ID of organization to authenticate into
         * @param {string | null} [redirectUri] URL to redirect to after successful login
         * @param {string | null} [invCode] Code sent via email as a result of successful call to send_invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (organizationId?: string | null, redirectUri?: string | null, invCode?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (organizationId !== undefined) {
                localVarQueryParameter['organization_id'] = organizationId;
            }

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (invCode !== undefined) {
                localVarQueryParameter['inv_code'] = invCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalidate your current auth credential stored typically stored in a cookie. This does not invalidate your API key.
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * This is the callback route for the OAuth provider, it should not be called directly. Redirects to browser with set-cookie header.
         * @summary OpenID Connect callback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callback(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SlimUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callback(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.callback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the user corresponding to your current auth credentials.
         * @summary Get Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SlimUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This will redirect you to the OAuth provider for authentication with email/pass, SSO, Google, Github, etc.
         * @summary Login
         * @param {string | null} [organizationId] ID of organization to authenticate into
         * @param {string | null} [redirectUri] URL to redirect to after successful login
         * @param {string | null} [invCode] Code sent via email as a result of successful call to send_invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(organizationId?: string | null, redirectUri?: string | null, invCode?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(organizationId, redirectUri, invCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invalidate your current auth credential stored typically stored in a cookie. This does not invalidate your API key.
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * This is the callback route for the OAuth provider, it should not be called directly. Redirects to browser with set-cookie header.
         * @summary OpenID Connect callback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callback(options?: any): AxiosPromise<SlimUser> {
            return localVarFp.callback(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the user corresponding to your current auth credentials.
         * @summary Get Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: any): AxiosPromise<SlimUser> {
            return localVarFp.getMe(options).then((request) => request(axios, basePath));
        },
        /**
         * This will redirect you to the OAuth provider for authentication with email/pass, SSO, Google, Github, etc.
         * @summary Login
         * @param {string | null} [organizationId] ID of organization to authenticate into
         * @param {string | null} [redirectUri] URL to redirect to after successful login
         * @param {string | null} [invCode] Code sent via email as a result of successful call to send_invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(organizationId?: string | null, redirectUri?: string | null, invCode?: string | null, options?: any): AxiosPromise<void> {
            return localVarFp.login(organizationId, redirectUri, invCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Invalidate your current auth credential stored typically stored in a cookie. This does not invalidate your API key.
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<void> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * This is the callback route for the OAuth provider, it should not be called directly. Redirects to browser with set-cookie header.
     * @summary OpenID Connect callback
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public callback(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).callback(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the user corresponding to your current auth credentials.
     * @summary Get Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getMe(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will redirect you to the OAuth provider for authentication with email/pass, SSO, Google, Github, etc.
     * @summary Login
     * @param {string | null} [organizationId] ID of organization to authenticate into
     * @param {string | null} [redirectUri] URL to redirect to after successful login
     * @param {string | null} [invCode] Code sent via email as a result of successful call to send_invitation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(organizationId?: string | null, redirectUri?: string | null, invCode?: string | null, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(organizationId, redirectUri, invCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalidate your current auth credential stored typically stored in a cookie. This does not invalidate your API key.
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logout(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChunkApi - axios parameter creator
 * @export
 */
export const ChunkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This route provides the primary autocomplete functionality for the API. This prioritize prefix matching with semantic or full-text search.
         * @summary Autocomplete
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {AutocompleteReqPayload} autocompleteReqPayload JSON request payload to semantically search for chunks (chunks)
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocomplete: async (tRDataset: string, autocompleteReqPayload: AutocompleteReqPayload, xAPIVersion?: APIVersion | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('autocomplete', 'tRDataset', tRDataset)
            // verify required parameter 'autocompleteReqPayload' is not null or undefined
            assertParamExists('autocomplete', 'autocompleteReqPayload', autocompleteReqPayload)
            const localVarPath = `/api/chunk/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }

            if (xAPIVersion != null) {
                localVarHeaderParameter['X-API-Version'] = typeof xAPIVersion === 'string'
                    ? xAPIVersion
                    : JSON.stringify(xAPIVersion);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autocompleteReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete multiple chunks using a filter. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Bulk Delete Chunks
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {BulkDeleteChunkPayload} bulkDeleteChunkPayload JSON request payload to speicy a filter to bulk delete chunks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteChunk: async (tRDataset: string, bulkDeleteChunkPayload: BulkDeleteChunkPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('bulkDeleteChunk', 'tRDataset', tRDataset)
            // verify required parameter 'bulkDeleteChunkPayload' is not null or undefined
            assertParamExists('bulkDeleteChunk', 'bulkDeleteChunkPayload', bulkDeleteChunkPayload)
            const localVarPath = `/api/chunk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkDeleteChunkPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route can be used to determine the number of chunk results that match a search query including score threshold and filters. It may be high latency for large limits. There is a dataset configuration imposed restriction on the maximum limit value (default 10,000) which is used to prevent DDOS attacks. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Count chunks above threshold
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {CountChunksReqPayload} countChunksReqPayload JSON request payload to count chunks for a search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countChunks: async (tRDataset: string, countChunksReqPayload: CountChunksReqPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('countChunks', 'tRDataset', tRDataset)
            // verify required parameter 'countChunksReqPayload' is not null or undefined
            assertParamExists('countChunks', 'countChunksReqPayload', countChunksReqPayload)
            const localVarPath = `/api/chunk/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(countChunksReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new chunk(s). If the chunk has the same tracking_id as an existing chunk, the request will fail. Once a chunk is created, it can be searched for using the search endpoint. If uploading in bulk, the maximum amount of chunks that can be uploaded at once is 120 chunks. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Create or Upsert Chunk or Chunks
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {CreateChunkReqPayloadEnum} createChunkReqPayloadEnum JSON request payload to create a new chunk (chunk)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChunk: async (tRDataset: string, createChunkReqPayloadEnum: CreateChunkReqPayloadEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('createChunk', 'tRDataset', tRDataset)
            // verify required parameter 'createChunkReqPayloadEnum' is not null or undefined
            assertParamExists('createChunk', 'createChunkReqPayloadEnum', createChunkReqPayloadEnum)
            const localVarPath = `/api/chunk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createChunkReqPayloadEnum, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a chunk by its id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Delete Chunk
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} chunkId Id of the chunk you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChunk: async (tRDataset: string, chunkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('deleteChunk', 'tRDataset', tRDataset)
            // verify required parameter 'chunkId' is not null or undefined
            assertParamExists('deleteChunk', 'chunkId', chunkId)
            const localVarPath = `/api/chunk/{chunk_id}`
                .replace(`{${"chunk_id"}}`, encodeURIComponent(String(chunkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Delete Chunk By Tracking Id
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} trackingId tracking_id of the chunk you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChunkByTrackingId: async (tRDataset: string, trackingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('deleteChunkByTrackingId', 'tRDataset', tRDataset)
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('deleteChunkByTrackingId', 'trackingId', trackingId)
            const localVarPath = `/api/chunk/tracking_id/{tracking_id}`
                .replace(`{${"tracking_id"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint exists as an alternative to the topic+message resource pattern where our Trieve handles chat memory. With this endpoint, the user is responsible for providing the context window and the prompt and the conversation is ephemeral.
         * @summary RAG on Specified Chunks
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {GenerateOffChunksReqPayload} generateOffChunksReqPayload JSON request payload to perform RAG on some chunks (chunks)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateOffChunks: async (tRDataset: string, generateOffChunksReqPayload: GenerateOffChunksReqPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('generateOffChunks', 'tRDataset', tRDataset)
            // verify required parameter 'generateOffChunksReqPayload' is not null or undefined
            assertParamExists('generateOffChunks', 'generateOffChunksReqPayload', generateOffChunksReqPayload)
            const localVarPath = `/api/chunk/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateOffChunksReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a singular chunk by id.
         * @summary Get Chunk By Id
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} chunkId Id of the chunk you want to fetch.
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunkById: async (tRDataset: string, chunkId: string, xAPIVersion?: APIVersion | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getChunkById', 'tRDataset', tRDataset)
            // verify required parameter 'chunkId' is not null or undefined
            assertParamExists('getChunkById', 'chunkId', chunkId)
            const localVarPath = `/api/chunk/{chunk_id}`
                .replace(`{${"chunk_id"}}`, encodeURIComponent(String(chunkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }

            if (xAPIVersion != null) {
                localVarHeaderParameter['X-API-Version'] = typeof xAPIVersion === 'string'
                    ? xAPIVersion
                    : JSON.stringify(xAPIVersion);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a singular chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use your own id as the primary reference for a chunk.
         * @summary Get Chunk By Tracking Id
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} trackingId tracking_id of the chunk you want to fetch
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunkByTrackingId: async (tRDataset: string, trackingId: string, xAPIVersion?: APIVersion | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getChunkByTrackingId', 'tRDataset', tRDataset)
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('getChunkByTrackingId', 'trackingId', trackingId)
            const localVarPath = `/api/chunk/tracking_id/{tracking_id}`
                .replace(`{${"tracking_id"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }

            if (xAPIVersion != null) {
                localVarHeaderParameter['X-API-Version'] = typeof xAPIVersion === 'string'
                    ? xAPIVersion
                    : JSON.stringify(xAPIVersion);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get multiple chunks by multiple ids.
         * @summary Get Chunks By Ids
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {GetChunksData} getChunksData JSON request payload to get the chunks in the request
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunksByIds: async (tRDataset: string, getChunksData: GetChunksData, xAPIVersion?: APIVersion | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getChunksByIds', 'tRDataset', tRDataset)
            // verify required parameter 'getChunksData' is not null or undefined
            assertParamExists('getChunksByIds', 'getChunksData', getChunksData)
            const localVarPath = `/api/chunks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }

            if (xAPIVersion != null) {
                localVarHeaderParameter['X-API-Version'] = typeof xAPIVersion === 'string'
                    ? xAPIVersion
                    : JSON.stringify(xAPIVersion);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getChunksData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get multiple chunks by ids.
         * @summary Get Chunks By Tracking Ids
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {GetTrackingChunksData} getTrackingChunksData JSON request payload to get the chunks in the request
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunksByTrackingIds: async (tRDataset: string, getTrackingChunksData: GetTrackingChunksData, xAPIVersion?: APIVersion | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getChunksByTrackingIds', 'tRDataset', tRDataset)
            // verify required parameter 'getTrackingChunksData' is not null or undefined
            assertParamExists('getChunksByTrackingIds', 'getTrackingChunksData', getTrackingChunksData)
            const localVarPath = `/api/chunks/tracking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }

            if (xAPIVersion != null) {
                localVarHeaderParameter['X-API-Version'] = typeof xAPIVersion === 'string'
                    ? xAPIVersion
                    : JSON.stringify(xAPIVersion);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getTrackingChunksData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recommendations of chunks similar to the positive samples in the request and dissimilar to the negative.
         * @summary Get Recommended Chunks
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {RecommendChunksRequest} recommendChunksRequest JSON request payload to get recommendations of chunks similar to the chunks in the request
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedChunks: async (tRDataset: string, recommendChunksRequest: RecommendChunksRequest, xAPIVersion?: APIVersion | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getRecommendedChunks', 'tRDataset', tRDataset)
            // verify required parameter 'recommendChunksRequest' is not null or undefined
            assertParamExists('getRecommendedChunks', 'recommendChunksRequest', recommendChunksRequest)
            const localVarPath = `/api/chunk/recommend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }

            if (xAPIVersion != null) {
                localVarHeaderParameter['X-API-Version'] = typeof xAPIVersion === 'string'
                    ? xAPIVersion
                    : JSON.stringify(xAPIVersion);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recommendChunksRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will generate 3 suggested queries based off a hybrid search using RAG with the query provided in the request body and return them as a JSON object.
         * @summary Generate suggested queries
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {SuggestedQueriesReqPayload} suggestedQueriesReqPayload JSON request payload to get alternative suggested queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestedQueries: async (tRDataset: string, suggestedQueriesReqPayload: SuggestedQueriesReqPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getSuggestedQueries', 'tRDataset', tRDataset)
            // verify required parameter 'suggestedQueriesReqPayload' is not null or undefined
            assertParamExists('getSuggestedQueries', 'suggestedQueriesReqPayload', suggestedQueriesReqPayload)
            const localVarPath = `/api/chunk/suggestions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(suggestedQueriesReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get paginated chunks from your dataset with filters and custom sorting. If sort by is not specified, the results will sort by the id\'s of the chunks in ascending order. Sort by and offset_chunk_id cannot be used together; if you want to scroll with a sort by then you need to use a must_not filter with the ids you have already seen. There is a limit of 1000 id\'s in a must_not filter at a time.
         * @summary Scroll Chunks
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {ScrollChunksReqPayload} scrollChunksReqPayload JSON request payload to scroll through chunks (chunks)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scrollDatasetChunks: async (tRDataset: string, scrollChunksReqPayload: ScrollChunksReqPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('scrollDatasetChunks', 'tRDataset', tRDataset)
            // verify required parameter 'scrollChunksReqPayload' is not null or undefined
            assertParamExists('scrollDatasetChunks', 'scrollChunksReqPayload', scrollChunksReqPayload)
            const localVarPath = `/api/chunks/scroll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scrollChunksReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route provides the primary search functionality for the API. It can be used to search for chunks by semantic similarity, full-text similarity, or a combination of both. Results\' `chunk_html` values will be modified with `<mark><b>` or custom specified tags for sub-sentence highlighting.
         * @summary Search
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {SearchChunksReqPayload} searchChunksReqPayload JSON request payload to semantically search for chunks (chunks)
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchChunks: async (tRDataset: string, searchChunksReqPayload: SearchChunksReqPayload, xAPIVersion?: APIVersion | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('searchChunks', 'tRDataset', tRDataset)
            // verify required parameter 'searchChunksReqPayload' is not null or undefined
            assertParamExists('searchChunks', 'searchChunksReqPayload', searchChunksReqPayload)
            const localVarPath = `/api/chunk/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }

            if (xAPIVersion != null) {
                localVarHeaderParameter['X-API-Version'] = typeof xAPIVersion === 'string'
                    ? xAPIVersion
                    : JSON.stringify(xAPIVersion);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchChunksReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a chunk. If you try to change the tracking_id of the chunk to have the same tracking_id as an existing chunk, the request will fail. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Update Chunk
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {UpdateChunkReqPayload} updateChunkReqPayload JSON request payload to update a chunk (chunk)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChunk: async (tRDataset: string, updateChunkReqPayload: UpdateChunkReqPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('updateChunk', 'tRDataset', tRDataset)
            // verify required parameter 'updateChunkReqPayload' is not null or undefined
            assertParamExists('updateChunk', 'updateChunkReqPayload', updateChunkReqPayload)
            const localVarPath = `/api/chunk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateChunkReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Update Chunk By Tracking Id
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {UpdateChunkByTrackingIdData} updateChunkByTrackingIdData JSON request payload to update a chunk by tracking_id (chunks)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateChunkByTrackingId: async (tRDataset: string, updateChunkByTrackingIdData: UpdateChunkByTrackingIdData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('updateChunkByTrackingId', 'tRDataset', tRDataset)
            // verify required parameter 'updateChunkByTrackingIdData' is not null or undefined
            assertParamExists('updateChunkByTrackingId', 'updateChunkByTrackingIdData', updateChunkByTrackingIdData)
            const localVarPath = `/api/chunk/tracking_id/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateChunkByTrackingIdData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChunkApi - functional programming interface
 * @export
 */
export const ChunkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChunkApiAxiosParamCreator(configuration)
    return {
        /**
         * This route provides the primary autocomplete functionality for the API. This prioritize prefix matching with semantic or full-text search.
         * @summary Autocomplete
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {AutocompleteReqPayload} autocompleteReqPayload JSON request payload to semantically search for chunks (chunks)
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autocomplete(tRDataset: string, autocompleteReqPayload: AutocompleteReqPayload, xAPIVersion?: APIVersion | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResponseTypes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autocomplete(tRDataset, autocompleteReqPayload, xAPIVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.autocomplete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete multiple chunks using a filter. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Bulk Delete Chunks
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {BulkDeleteChunkPayload} bulkDeleteChunkPayload JSON request payload to speicy a filter to bulk delete chunks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkDeleteChunk(tRDataset: string, bulkDeleteChunkPayload: BulkDeleteChunkPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDeleteChunk(tRDataset, bulkDeleteChunkPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.bulkDeleteChunk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This route can be used to determine the number of chunk results that match a search query including score threshold and filters. It may be high latency for large limits. There is a dataset configuration imposed restriction on the maximum limit value (default 10,000) which is used to prevent DDOS attacks. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Count chunks above threshold
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {CountChunksReqPayload} countChunksReqPayload JSON request payload to count chunks for a search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countChunks(tRDataset: string, countChunksReqPayload: CountChunksReqPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountChunkQueryResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countChunks(tRDataset, countChunksReqPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.countChunks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create new chunk(s). If the chunk has the same tracking_id as an existing chunk, the request will fail. Once a chunk is created, it can be searched for using the search endpoint. If uploading in bulk, the maximum amount of chunks that can be uploaded at once is 120 chunks. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Create or Upsert Chunk or Chunks
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {CreateChunkReqPayloadEnum} createChunkReqPayloadEnum JSON request payload to create a new chunk (chunk)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChunk(tRDataset: string, createChunkReqPayloadEnum: CreateChunkReqPayloadEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReturnQueuedChunk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChunk(tRDataset, createChunkReqPayloadEnum, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.createChunk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a chunk by its id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Delete Chunk
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} chunkId Id of the chunk you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChunk(tRDataset: string, chunkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChunk(tRDataset, chunkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.deleteChunk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Delete Chunk By Tracking Id
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} trackingId tracking_id of the chunk you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChunkByTrackingId(tRDataset: string, trackingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChunkByTrackingId(tRDataset, trackingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.deleteChunkByTrackingId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint exists as an alternative to the topic+message resource pattern where our Trieve handles chat memory. With this endpoint, the user is responsible for providing the context window and the prompt and the conversation is ephemeral.
         * @summary RAG on Specified Chunks
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {GenerateOffChunksReqPayload} generateOffChunksReqPayload JSON request payload to perform RAG on some chunks (chunks)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateOffChunks(tRDataset: string, generateOffChunksReqPayload: GenerateOffChunksReqPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateOffChunks(tRDataset, generateOffChunksReqPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.generateOffChunks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a singular chunk by id.
         * @summary Get Chunk By Id
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} chunkId Id of the chunk you want to fetch.
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChunkById(tRDataset: string, chunkId: string, xAPIVersion?: APIVersion | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChunkReturnTypes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChunkById(tRDataset, chunkId, xAPIVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.getChunkById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a singular chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use your own id as the primary reference for a chunk.
         * @summary Get Chunk By Tracking Id
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} trackingId tracking_id of the chunk you want to fetch
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChunkByTrackingId(tRDataset: string, trackingId: string, xAPIVersion?: APIVersion | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChunkReturnTypes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChunkByTrackingId(tRDataset, trackingId, xAPIVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.getChunkByTrackingId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get multiple chunks by multiple ids.
         * @summary Get Chunks By Ids
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {GetChunksData} getChunksData JSON request payload to get the chunks in the request
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChunksByIds(tRDataset: string, getChunksData: GetChunksData, xAPIVersion?: APIVersion | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChunkReturnTypes>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChunksByIds(tRDataset, getChunksData, xAPIVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.getChunksByIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get multiple chunks by ids.
         * @summary Get Chunks By Tracking Ids
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {GetTrackingChunksData} getTrackingChunksData JSON request payload to get the chunks in the request
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChunksByTrackingIds(tRDataset: string, getTrackingChunksData: GetTrackingChunksData, xAPIVersion?: APIVersion | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChunkReturnTypes>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChunksByTrackingIds(tRDataset, getTrackingChunksData, xAPIVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.getChunksByTrackingIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get recommendations of chunks similar to the positive samples in the request and dissimilar to the negative.
         * @summary Get Recommended Chunks
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {RecommendChunksRequest} recommendChunksRequest JSON request payload to get recommendations of chunks similar to the chunks in the request
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendedChunks(tRDataset: string, recommendChunksRequest: RecommendChunksRequest, xAPIVersion?: APIVersion | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecommendResponseTypes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendedChunks(tRDataset, recommendChunksRequest, xAPIVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.getRecommendedChunks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint will generate 3 suggested queries based off a hybrid search using RAG with the query provided in the request body and return them as a JSON object.
         * @summary Generate suggested queries
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {SuggestedQueriesReqPayload} suggestedQueriesReqPayload JSON request payload to get alternative suggested queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSuggestedQueries(tRDataset: string, suggestedQueriesReqPayload: SuggestedQueriesReqPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuggestedQueriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSuggestedQueries(tRDataset, suggestedQueriesReqPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.getSuggestedQueries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get paginated chunks from your dataset with filters and custom sorting. If sort by is not specified, the results will sort by the id\'s of the chunks in ascending order. Sort by and offset_chunk_id cannot be used together; if you want to scroll with a sort by then you need to use a must_not filter with the ids you have already seen. There is a limit of 1000 id\'s in a must_not filter at a time.
         * @summary Scroll Chunks
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {ScrollChunksReqPayload} scrollChunksReqPayload JSON request payload to scroll through chunks (chunks)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scrollDatasetChunks(tRDataset: string, scrollChunksReqPayload: ScrollChunksReqPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScrollChunksResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scrollDatasetChunks(tRDataset, scrollChunksReqPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.scrollDatasetChunks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This route provides the primary search functionality for the API. It can be used to search for chunks by semantic similarity, full-text similarity, or a combination of both. Results\' `chunk_html` values will be modified with `<mark><b>` or custom specified tags for sub-sentence highlighting.
         * @summary Search
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {SearchChunksReqPayload} searchChunksReqPayload JSON request payload to semantically search for chunks (chunks)
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchChunks(tRDataset: string, searchChunksReqPayload: SearchChunksReqPayload, xAPIVersion?: APIVersion | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResponseTypes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchChunks(tRDataset, searchChunksReqPayload, xAPIVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.searchChunks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a chunk. If you try to change the tracking_id of the chunk to have the same tracking_id as an existing chunk, the request will fail. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Update Chunk
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {UpdateChunkReqPayload} updateChunkReqPayload JSON request payload to update a chunk (chunk)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateChunk(tRDataset: string, updateChunkReqPayload: UpdateChunkReqPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateChunk(tRDataset, updateChunkReqPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.updateChunk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Update Chunk By Tracking Id
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {UpdateChunkByTrackingIdData} updateChunkByTrackingIdData JSON request payload to update a chunk by tracking_id (chunks)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateChunkByTrackingId(tRDataset: string, updateChunkByTrackingIdData: UpdateChunkByTrackingIdData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateChunkByTrackingId(tRDataset, updateChunkByTrackingIdData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.updateChunkByTrackingId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChunkApi - factory interface
 * @export
 */
export const ChunkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChunkApiFp(configuration)
    return {
        /**
         * This route provides the primary autocomplete functionality for the API. This prioritize prefix matching with semantic or full-text search.
         * @summary Autocomplete
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {AutocompleteReqPayload} autocompleteReqPayload JSON request payload to semantically search for chunks (chunks)
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocomplete(tRDataset: string, autocompleteReqPayload: AutocompleteReqPayload, xAPIVersion?: APIVersion | null, options?: any): AxiosPromise<SearchResponseTypes> {
            return localVarFp.autocomplete(tRDataset, autocompleteReqPayload, xAPIVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete multiple chunks using a filter. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Bulk Delete Chunks
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {BulkDeleteChunkPayload} bulkDeleteChunkPayload JSON request payload to speicy a filter to bulk delete chunks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteChunk(tRDataset: string, bulkDeleteChunkPayload: BulkDeleteChunkPayload, options?: any): AxiosPromise<void> {
            return localVarFp.bulkDeleteChunk(tRDataset, bulkDeleteChunkPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * This route can be used to determine the number of chunk results that match a search query including score threshold and filters. It may be high latency for large limits. There is a dataset configuration imposed restriction on the maximum limit value (default 10,000) which is used to prevent DDOS attacks. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Count chunks above threshold
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {CountChunksReqPayload} countChunksReqPayload JSON request payload to count chunks for a search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countChunks(tRDataset: string, countChunksReqPayload: CountChunksReqPayload, options?: any): AxiosPromise<CountChunkQueryResponseBody> {
            return localVarFp.countChunks(tRDataset, countChunksReqPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new chunk(s). If the chunk has the same tracking_id as an existing chunk, the request will fail. Once a chunk is created, it can be searched for using the search endpoint. If uploading in bulk, the maximum amount of chunks that can be uploaded at once is 120 chunks. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Create or Upsert Chunk or Chunks
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {CreateChunkReqPayloadEnum} createChunkReqPayloadEnum JSON request payload to create a new chunk (chunk)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChunk(tRDataset: string, createChunkReqPayloadEnum: CreateChunkReqPayloadEnum, options?: any): AxiosPromise<ReturnQueuedChunk> {
            return localVarFp.createChunk(tRDataset, createChunkReqPayloadEnum, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a chunk by its id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Delete Chunk
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} chunkId Id of the chunk you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChunk(tRDataset: string, chunkId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteChunk(tRDataset, chunkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Delete Chunk By Tracking Id
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} trackingId tracking_id of the chunk you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChunkByTrackingId(tRDataset: string, trackingId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteChunkByTrackingId(tRDataset, trackingId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint exists as an alternative to the topic+message resource pattern where our Trieve handles chat memory. With this endpoint, the user is responsible for providing the context window and the prompt and the conversation is ephemeral.
         * @summary RAG on Specified Chunks
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {GenerateOffChunksReqPayload} generateOffChunksReqPayload JSON request payload to perform RAG on some chunks (chunks)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateOffChunks(tRDataset: string, generateOffChunksReqPayload: GenerateOffChunksReqPayload, options?: any): AxiosPromise<string> {
            return localVarFp.generateOffChunks(tRDataset, generateOffChunksReqPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a singular chunk by id.
         * @summary Get Chunk By Id
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} chunkId Id of the chunk you want to fetch.
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunkById(tRDataset: string, chunkId: string, xAPIVersion?: APIVersion | null, options?: any): AxiosPromise<ChunkReturnTypes> {
            return localVarFp.getChunkById(tRDataset, chunkId, xAPIVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a singular chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use your own id as the primary reference for a chunk.
         * @summary Get Chunk By Tracking Id
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} trackingId tracking_id of the chunk you want to fetch
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunkByTrackingId(tRDataset: string, trackingId: string, xAPIVersion?: APIVersion | null, options?: any): AxiosPromise<ChunkReturnTypes> {
            return localVarFp.getChunkByTrackingId(tRDataset, trackingId, xAPIVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Get multiple chunks by multiple ids.
         * @summary Get Chunks By Ids
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {GetChunksData} getChunksData JSON request payload to get the chunks in the request
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunksByIds(tRDataset: string, getChunksData: GetChunksData, xAPIVersion?: APIVersion | null, options?: any): AxiosPromise<Array<ChunkReturnTypes>> {
            return localVarFp.getChunksByIds(tRDataset, getChunksData, xAPIVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Get multiple chunks by ids.
         * @summary Get Chunks By Tracking Ids
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {GetTrackingChunksData} getTrackingChunksData JSON request payload to get the chunks in the request
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunksByTrackingIds(tRDataset: string, getTrackingChunksData: GetTrackingChunksData, xAPIVersion?: APIVersion | null, options?: any): AxiosPromise<Array<ChunkReturnTypes>> {
            return localVarFp.getChunksByTrackingIds(tRDataset, getTrackingChunksData, xAPIVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recommendations of chunks similar to the positive samples in the request and dissimilar to the negative.
         * @summary Get Recommended Chunks
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {RecommendChunksRequest} recommendChunksRequest JSON request payload to get recommendations of chunks similar to the chunks in the request
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedChunks(tRDataset: string, recommendChunksRequest: RecommendChunksRequest, xAPIVersion?: APIVersion | null, options?: any): AxiosPromise<RecommendResponseTypes> {
            return localVarFp.getRecommendedChunks(tRDataset, recommendChunksRequest, xAPIVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will generate 3 suggested queries based off a hybrid search using RAG with the query provided in the request body and return them as a JSON object.
         * @summary Generate suggested queries
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {SuggestedQueriesReqPayload} suggestedQueriesReqPayload JSON request payload to get alternative suggested queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestedQueries(tRDataset: string, suggestedQueriesReqPayload: SuggestedQueriesReqPayload, options?: any): AxiosPromise<SuggestedQueriesResponse> {
            return localVarFp.getSuggestedQueries(tRDataset, suggestedQueriesReqPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Get paginated chunks from your dataset with filters and custom sorting. If sort by is not specified, the results will sort by the id\'s of the chunks in ascending order. Sort by and offset_chunk_id cannot be used together; if you want to scroll with a sort by then you need to use a must_not filter with the ids you have already seen. There is a limit of 1000 id\'s in a must_not filter at a time.
         * @summary Scroll Chunks
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {ScrollChunksReqPayload} scrollChunksReqPayload JSON request payload to scroll through chunks (chunks)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scrollDatasetChunks(tRDataset: string, scrollChunksReqPayload: ScrollChunksReqPayload, options?: any): AxiosPromise<ScrollChunksResponseBody> {
            return localVarFp.scrollDatasetChunks(tRDataset, scrollChunksReqPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * This route provides the primary search functionality for the API. It can be used to search for chunks by semantic similarity, full-text similarity, or a combination of both. Results\' `chunk_html` values will be modified with `<mark><b>` or custom specified tags for sub-sentence highlighting.
         * @summary Search
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {SearchChunksReqPayload} searchChunksReqPayload JSON request payload to semantically search for chunks (chunks)
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchChunks(tRDataset: string, searchChunksReqPayload: SearchChunksReqPayload, xAPIVersion?: APIVersion | null, options?: any): AxiosPromise<SearchResponseTypes> {
            return localVarFp.searchChunks(tRDataset, searchChunksReqPayload, xAPIVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a chunk. If you try to change the tracking_id of the chunk to have the same tracking_id as an existing chunk, the request will fail. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Update Chunk
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {UpdateChunkReqPayload} updateChunkReqPayload JSON request payload to update a chunk (chunk)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChunk(tRDataset: string, updateChunkReqPayload: UpdateChunkReqPayload, options?: any): AxiosPromise<void> {
            return localVarFp.updateChunk(tRDataset, updateChunkReqPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Update Chunk By Tracking Id
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {UpdateChunkByTrackingIdData} updateChunkByTrackingIdData JSON request payload to update a chunk by tracking_id (chunks)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateChunkByTrackingId(tRDataset: string, updateChunkByTrackingIdData: UpdateChunkByTrackingIdData, options?: any): AxiosPromise<void> {
            return localVarFp.updateChunkByTrackingId(tRDataset, updateChunkByTrackingIdData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChunkApi - object-oriented interface
 * @export
 * @class ChunkApi
 * @extends {BaseAPI}
 */
export class ChunkApi extends BaseAPI {
    /**
     * This route provides the primary autocomplete functionality for the API. This prioritize prefix matching with semantic or full-text search.
     * @summary Autocomplete
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {AutocompleteReqPayload} autocompleteReqPayload JSON request payload to semantically search for chunks (chunks)
     * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public autocomplete(tRDataset: string, autocompleteReqPayload: AutocompleteReqPayload, xAPIVersion?: APIVersion | null, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).autocomplete(tRDataset, autocompleteReqPayload, xAPIVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete multiple chunks using a filter. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Bulk Delete Chunks
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {BulkDeleteChunkPayload} bulkDeleteChunkPayload JSON request payload to speicy a filter to bulk delete chunks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public bulkDeleteChunk(tRDataset: string, bulkDeleteChunkPayload: BulkDeleteChunkPayload, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).bulkDeleteChunk(tRDataset, bulkDeleteChunkPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route can be used to determine the number of chunk results that match a search query including score threshold and filters. It may be high latency for large limits. There is a dataset configuration imposed restriction on the maximum limit value (default 10,000) which is used to prevent DDOS attacks. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Count chunks above threshold
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {CountChunksReqPayload} countChunksReqPayload JSON request payload to count chunks for a search query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public countChunks(tRDataset: string, countChunksReqPayload: CountChunksReqPayload, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).countChunks(tRDataset, countChunksReqPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new chunk(s). If the chunk has the same tracking_id as an existing chunk, the request will fail. Once a chunk is created, it can be searched for using the search endpoint. If uploading in bulk, the maximum amount of chunks that can be uploaded at once is 120 chunks. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Create or Upsert Chunk or Chunks
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {CreateChunkReqPayloadEnum} createChunkReqPayloadEnum JSON request payload to create a new chunk (chunk)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public createChunk(tRDataset: string, createChunkReqPayloadEnum: CreateChunkReqPayloadEnum, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).createChunk(tRDataset, createChunkReqPayloadEnum, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a chunk by its id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Delete Chunk
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} chunkId Id of the chunk you want to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public deleteChunk(tRDataset: string, chunkId: string, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).deleteChunk(tRDataset, chunkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Delete Chunk By Tracking Id
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} trackingId tracking_id of the chunk you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public deleteChunkByTrackingId(tRDataset: string, trackingId: string, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).deleteChunkByTrackingId(tRDataset, trackingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint exists as an alternative to the topic+message resource pattern where our Trieve handles chat memory. With this endpoint, the user is responsible for providing the context window and the prompt and the conversation is ephemeral.
     * @summary RAG on Specified Chunks
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {GenerateOffChunksReqPayload} generateOffChunksReqPayload JSON request payload to perform RAG on some chunks (chunks)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public generateOffChunks(tRDataset: string, generateOffChunksReqPayload: GenerateOffChunksReqPayload, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).generateOffChunks(tRDataset, generateOffChunksReqPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a singular chunk by id.
     * @summary Get Chunk By Id
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} chunkId Id of the chunk you want to fetch.
     * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public getChunkById(tRDataset: string, chunkId: string, xAPIVersion?: APIVersion | null, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).getChunkById(tRDataset, chunkId, xAPIVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a singular chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use your own id as the primary reference for a chunk.
     * @summary Get Chunk By Tracking Id
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} trackingId tracking_id of the chunk you want to fetch
     * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public getChunkByTrackingId(tRDataset: string, trackingId: string, xAPIVersion?: APIVersion | null, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).getChunkByTrackingId(tRDataset, trackingId, xAPIVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get multiple chunks by multiple ids.
     * @summary Get Chunks By Ids
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {GetChunksData} getChunksData JSON request payload to get the chunks in the request
     * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public getChunksByIds(tRDataset: string, getChunksData: GetChunksData, xAPIVersion?: APIVersion | null, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).getChunksByIds(tRDataset, getChunksData, xAPIVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get multiple chunks by ids.
     * @summary Get Chunks By Tracking Ids
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {GetTrackingChunksData} getTrackingChunksData JSON request payload to get the chunks in the request
     * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public getChunksByTrackingIds(tRDataset: string, getTrackingChunksData: GetTrackingChunksData, xAPIVersion?: APIVersion | null, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).getChunksByTrackingIds(tRDataset, getTrackingChunksData, xAPIVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recommendations of chunks similar to the positive samples in the request and dissimilar to the negative.
     * @summary Get Recommended Chunks
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {RecommendChunksRequest} recommendChunksRequest JSON request payload to get recommendations of chunks similar to the chunks in the request
     * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public getRecommendedChunks(tRDataset: string, recommendChunksRequest: RecommendChunksRequest, xAPIVersion?: APIVersion | null, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).getRecommendedChunks(tRDataset, recommendChunksRequest, xAPIVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will generate 3 suggested queries based off a hybrid search using RAG with the query provided in the request body and return them as a JSON object.
     * @summary Generate suggested queries
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {SuggestedQueriesReqPayload} suggestedQueriesReqPayload JSON request payload to get alternative suggested queries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public getSuggestedQueries(tRDataset: string, suggestedQueriesReqPayload: SuggestedQueriesReqPayload, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).getSuggestedQueries(tRDataset, suggestedQueriesReqPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get paginated chunks from your dataset with filters and custom sorting. If sort by is not specified, the results will sort by the id\'s of the chunks in ascending order. Sort by and offset_chunk_id cannot be used together; if you want to scroll with a sort by then you need to use a must_not filter with the ids you have already seen. There is a limit of 1000 id\'s in a must_not filter at a time.
     * @summary Scroll Chunks
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {ScrollChunksReqPayload} scrollChunksReqPayload JSON request payload to scroll through chunks (chunks)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public scrollDatasetChunks(tRDataset: string, scrollChunksReqPayload: ScrollChunksReqPayload, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).scrollDatasetChunks(tRDataset, scrollChunksReqPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route provides the primary search functionality for the API. It can be used to search for chunks by semantic similarity, full-text similarity, or a combination of both. Results\' `chunk_html` values will be modified with `<mark><b>` or custom specified tags for sub-sentence highlighting.
     * @summary Search
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {SearchChunksReqPayload} searchChunksReqPayload JSON request payload to semantically search for chunks (chunks)
     * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public searchChunks(tRDataset: string, searchChunksReqPayload: SearchChunksReqPayload, xAPIVersion?: APIVersion | null, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).searchChunks(tRDataset, searchChunksReqPayload, xAPIVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a chunk. If you try to change the tracking_id of the chunk to have the same tracking_id as an existing chunk, the request will fail. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Update Chunk
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {UpdateChunkReqPayload} updateChunkReqPayload JSON request payload to update a chunk (chunk)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public updateChunk(tRDataset: string, updateChunkReqPayload: UpdateChunkReqPayload, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).updateChunk(tRDataset, updateChunkReqPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Update Chunk By Tracking Id
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {UpdateChunkByTrackingIdData} updateChunkByTrackingIdData JSON request payload to update a chunk by tracking_id (chunks)
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public updateChunkByTrackingId(tRDataset: string, updateChunkByTrackingIdData: UpdateChunkByTrackingIdData, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).updateChunkByTrackingId(tRDataset, updateChunkByTrackingIdData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChunkGroupApi - axios parameter creator
 * @export
 */
export const ChunkGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Route to add a chunk to a group. One of chunk_id or chunk_tracking_id must be provided. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Add Chunk to Group
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} groupId Id of the group to add the chunk to as a bookmark
         * @param {AddChunkToGroupReqPayload} addChunkToGroupReqPayload JSON request payload to add a chunk to a group (bookmark it)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addChunkToGroup: async (tRDataset: string, groupId: string, addChunkToGroupReqPayload: AddChunkToGroupReqPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('addChunkToGroup', 'tRDataset', tRDataset)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('addChunkToGroup', 'groupId', groupId)
            // verify required parameter 'addChunkToGroupReqPayload' is not null or undefined
            assertParamExists('addChunkToGroup', 'addChunkToGroupReqPayload', addChunkToGroupReqPayload)
            const localVarPath = `/api/chunk_group/chunk/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addChunkToGroupReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Route to add a chunk to a group by tracking id. One of chunk_id or chunk_tracking_id must be provided. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Add Chunk to Group by Tracking ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} trackingId Tracking id of the group to add the chunk to as a bookmark
         * @param {AddChunkToGroupReqPayload} addChunkToGroupReqPayload JSON request payload to add a chunk to a group via tracking_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addChunkToGroupByTrackingId: async (tRDataset: string, trackingId: string, addChunkToGroupReqPayload: AddChunkToGroupReqPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('addChunkToGroupByTrackingId', 'tRDataset', tRDataset)
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('addChunkToGroupByTrackingId', 'trackingId', trackingId)
            // verify required parameter 'addChunkToGroupReqPayload' is not null or undefined
            assertParamExists('addChunkToGroupByTrackingId', 'addChunkToGroupReqPayload', addChunkToGroupReqPayload)
            const localVarPath = `/api/chunk_group/tracking_id/{tracking_id}`
                .replace(`{${"tracking_id"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addChunkToGroupReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new chunk_group(s). This is a way to group chunks together. If you try to create a chunk_group with the same tracking_id as an existing chunk_group, this operation will fail. Only 1000 chunk groups can be created at a time. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Create or Upsert Group or Groups
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {CreateChunkGroupReqPayloadEnum} createChunkGroupReqPayloadEnum JSON request payload to cretea a chunk_group(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChunkGroup: async (tRDataset: string, createChunkGroupReqPayloadEnum: CreateChunkGroupReqPayloadEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('createChunkGroup', 'tRDataset', tRDataset)
            // verify required parameter 'createChunkGroupReqPayloadEnum' is not null or undefined
            assertParamExists('createChunkGroup', 'createChunkGroupReqPayloadEnum', createChunkGroupReqPayloadEnum)
            const localVarPath = `/api/chunk_group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createChunkGroupReqPayloadEnum, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will delete a chunk_group. If you set delete_chunks to true, it will also delete the chunks within the group. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Delete Group
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} groupId Id of the group you want to fetch.
         * @param {boolean} deleteChunks Delete the chunks within the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChunkGroup: async (tRDataset: string, groupId: string, deleteChunks: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('deleteChunkGroup', 'tRDataset', tRDataset)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteChunkGroup', 'groupId', groupId)
            // verify required parameter 'deleteChunks' is not null or undefined
            assertParamExists('deleteChunkGroup', 'deleteChunks', deleteChunks)
            const localVarPath = `/api/chunk_group/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (deleteChunks !== undefined) {
                localVarQueryParameter['delete_chunks'] = deleteChunks;
            }

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a chunk_group with the given tracking id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Delete Group by Tracking ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} trackingId Tracking id of the chunk_group to delete
         * @param {boolean} deleteChunks Delete the chunks within the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupByTrackingId: async (tRDataset: string, trackingId: string, deleteChunks: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('deleteGroupByTrackingId', 'tRDataset', tRDataset)
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('deleteGroupByTrackingId', 'trackingId', trackingId)
            // verify required parameter 'deleteChunks' is not null or undefined
            assertParamExists('deleteGroupByTrackingId', 'deleteChunks', deleteChunks)
            const localVarPath = `/api/chunk_group/tracking_id/{tracking_id}`
                .replace(`{${"tracking_id"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (deleteChunks !== undefined) {
                localVarQueryParameter['delete_chunks'] = deleteChunks;
            }

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the group with the given id.
         * @summary Get Group
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} groupId Id of the group you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunkGroup: async (tRDataset: string, groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getChunkGroup', 'tRDataset', tRDataset)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getChunkGroup', 'groupId', groupId)
            const localVarPath = `/api/chunk_group/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Page is 1-indexed.
         * @summary Get Chunks in Group
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} groupId Id of the group you want to fetch.
         * @param {number | null} page The page of chunks to get from the group
         * @param {APIVersion | null} [xAPIVersion] The version of the API to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunksInGroup: async (tRDataset: string, groupId: string, page: number | null, xAPIVersion?: APIVersion | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getChunksInGroup', 'tRDataset', tRDataset)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getChunksInGroup', 'groupId', groupId)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getChunksInGroup', 'page', page)
            const localVarPath = `/api/chunk_group/{group_id}/{page}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"page"}}`, encodeURIComponent(String(page)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }

            if (xAPIVersion != null) {
                localVarHeaderParameter['X-API-Version'] = typeof xAPIVersion === 'string'
                    ? xAPIVersion
                    : JSON.stringify(xAPIVersion);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Support for custom page size is coming soon. Page is 1-indexed.
         * @summary Get Chunks in Group by Tracking ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} groupTrackingId The id of the group to get the chunks from
         * @param {number} page The page of chunks to get from the group
         * @param {APIVersion | null} [xAPIVersion] The version of the API to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunksInGroupByTrackingId: async (tRDataset: string, groupTrackingId: string, page: number, xAPIVersion?: APIVersion | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getChunksInGroupByTrackingId', 'tRDataset', tRDataset)
            // verify required parameter 'groupTrackingId' is not null or undefined
            assertParamExists('getChunksInGroupByTrackingId', 'groupTrackingId', groupTrackingId)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getChunksInGroupByTrackingId', 'page', page)
            const localVarPath = `/api/chunk_group/tracking_id/{group_tracking_id}/{page}`
                .replace(`{${"group_tracking_id"}}`, encodeURIComponent(String(groupTrackingId)))
                .replace(`{${"page"}}`, encodeURIComponent(String(page)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }

            if (xAPIVersion != null) {
                localVarHeaderParameter['X-API-Version'] = typeof xAPIVersion === 'string'
                    ? xAPIVersion
                    : JSON.stringify(xAPIVersion);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the group with the given tracking id. get_group_by_tracking_id
         * @summary Get Group by Tracking ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} trackingId The tracking id of the group to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupByTrackingId: async (tRDataset: string, trackingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getGroupByTrackingId', 'tRDataset', tRDataset)
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('getGroupByTrackingId', 'trackingId', trackingId)
            const localVarPath = `/api/chunk_group/tracking_id/{tracking_id}`
                .replace(`{${"tracking_id"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Route to get the groups that a chunk is in.
         * @summary Get Groups for Chunks
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {GetGroupsForChunksReqPayload} getGroupsForChunksReqPayload JSON request payload to get the groups that a chunk is in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsForChunks: async (tRDataset: string, getGroupsForChunksReqPayload: GetGroupsForChunksReqPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getGroupsForChunks', 'tRDataset', tRDataset)
            // verify required parameter 'getGroupsForChunksReqPayload' is not null or undefined
            assertParamExists('getGroupsForChunks', 'getGroupsForChunksReqPayload', getGroupsForChunksReqPayload)
            const localVarPath = `/api/chunk_group/chunks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getGroupsForChunksReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the groups which belong to a dataset specified by its id.
         * @summary Get Groups for Dataset
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} datasetId The id of the dataset to fetch groups for.
         * @param {number} page The page of groups to fetch. Page is 1-indexed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsForDataset: async (tRDataset: string, datasetId: string, page: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getGroupsForDataset', 'tRDataset', tRDataset)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getGroupsForDataset', 'datasetId', datasetId)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getGroupsForDataset', 'page', page)
            const localVarPath = `/api/dataset/groups/{dataset_id}/{page}`
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"page"}}`, encodeURIComponent(String(page)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Route to get recommended groups. This route will return groups which are similar to the groups in the request body. You must provide at least one positive group id or group tracking id.
         * @summary Get Recommended Groups
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {RecommendGroupsReqPayload} recommendGroupsReqPayload JSON request payload to get recommendations of chunks similar to the chunks in the request
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedGroups: async (tRDataset: string, recommendGroupsReqPayload: RecommendGroupsReqPayload, xAPIVersion?: APIVersion | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getRecommendedGroups', 'tRDataset', tRDataset)
            // verify required parameter 'recommendGroupsReqPayload' is not null or undefined
            assertParamExists('getRecommendedGroups', 'recommendGroupsReqPayload', recommendGroupsReqPayload)
            const localVarPath = `/api/chunk_group/recommend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }

            if (xAPIVersion != null) {
                localVarHeaderParameter['X-API-Version'] = typeof xAPIVersion === 'string'
                    ? xAPIVersion
                    : JSON.stringify(xAPIVersion);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recommendGroupsReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Route to remove a chunk from a group. Auth\'ed user or api key must be an admin or owner of the dataset\'s organization to remove a chunk from a group.
         * @summary Remove Chunk from Group
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} groupId Id of the group you want to remove the chunk from.
         * @param {string | null} [chunkId] Id of the chunk you want to remove from the group
         * @param {RemoveChunkFromGroupReqPayload | null} [removeChunkFromGroupReqPayload] JSON request payload to remove a chunk from a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeChunkFromGroup: async (tRDataset: string, groupId: string, chunkId?: string | null, removeChunkFromGroupReqPayload?: RemoveChunkFromGroupReqPayload | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('removeChunkFromGroup', 'tRDataset', tRDataset)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('removeChunkFromGroup', 'groupId', groupId)
            const localVarPath = `/api/chunk_group/chunk/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (chunkId !== undefined) {
                localVarQueryParameter['chunk_id'] = chunkId;
            }

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeChunkFromGroupReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route allows you to get groups as results instead of chunks. Each group returned will have the matching chunks sorted by similarity within the group. This is useful for when you want to get groups of chunks which are similar to the search query. If choosing hybrid search, the top chunk of each group will be re-ranked using scores from a cross encoder model. Compatible with semantic, fulltext, or hybrid search modes.
         * @summary Search Over Groups
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {SearchOverGroupsReqPayload} searchOverGroupsReqPayload JSON request payload to semantically search over groups
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchOverGroups: async (tRDataset: string, searchOverGroupsReqPayload: SearchOverGroupsReqPayload, xAPIVersion?: APIVersion | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('searchOverGroups', 'tRDataset', tRDataset)
            // verify required parameter 'searchOverGroupsReqPayload' is not null or undefined
            assertParamExists('searchOverGroups', 'searchOverGroupsReqPayload', searchOverGroupsReqPayload)
            const localVarPath = `/api/chunk_group/group_oriented_search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }

            if (xAPIVersion != null) {
                localVarHeaderParameter['X-API-Version'] = typeof xAPIVersion === 'string'
                    ? xAPIVersion
                    : JSON.stringify(xAPIVersion);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchOverGroupsReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route allows you to search only within a group. This is useful for when you only want search results to contain chunks which are members of a specific group. If choosing hybrid search, the results will be re-ranked using scores from a cross encoder model.
         * @summary Search Within Group
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {SearchWithinGroupReqPayload} searchWithinGroupReqPayload JSON request payload to semantically search a group
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchWithinGroup: async (tRDataset: string, searchWithinGroupReqPayload: SearchWithinGroupReqPayload, xAPIVersion?: APIVersion | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('searchWithinGroup', 'tRDataset', tRDataset)
            // verify required parameter 'searchWithinGroupReqPayload' is not null or undefined
            assertParamExists('searchWithinGroup', 'searchWithinGroupReqPayload', searchWithinGroupReqPayload)
            const localVarPath = `/api/chunk_group/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }

            if (xAPIVersion != null) {
                localVarHeaderParameter['X-API-Version'] = typeof xAPIVersion === 'string'
                    ? xAPIVersion
                    : JSON.stringify(xAPIVersion);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchWithinGroupReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a chunk_group. One of group_id or tracking_id must be provided. If you try to change the tracking_id to one that already exists, this operation will fail. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Update Group
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {UpdateChunkGroupReqPayload} updateChunkGroupReqPayload JSON request payload to update a chunkGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChunkGroup: async (tRDataset: string, updateChunkGroupReqPayload: UpdateChunkGroupReqPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('updateChunkGroup', 'tRDataset', tRDataset)
            // verify required parameter 'updateChunkGroupReqPayload' is not null or undefined
            assertParamExists('updateChunkGroup', 'updateChunkGroupReqPayload', updateChunkGroupReqPayload)
            const localVarPath = `/api/chunk_group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateChunkGroupReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a chunk_group with the given tracking id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Update Group by Tracking ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} trackingId Tracking id of the chunk_group to update
         * @param {UpdateGroupByTrackingIDReqPayload} updateGroupByTrackingIDReqPayload JSON request payload to update a chunkGroup
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateGroupByTrackingId: async (tRDataset: string, trackingId: string, updateGroupByTrackingIDReqPayload: UpdateGroupByTrackingIDReqPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('updateGroupByTrackingId', 'tRDataset', tRDataset)
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('updateGroupByTrackingId', 'trackingId', trackingId)
            // verify required parameter 'updateGroupByTrackingIDReqPayload' is not null or undefined
            assertParamExists('updateGroupByTrackingId', 'updateGroupByTrackingIDReqPayload', updateGroupByTrackingIDReqPayload)
            const localVarPath = `/api/chunk_group/tracking_id/{tracking_id}`
                .replace(`{${"tracking_id"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGroupByTrackingIDReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChunkGroupApi - functional programming interface
 * @export
 */
export const ChunkGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChunkGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * Route to add a chunk to a group. One of chunk_id or chunk_tracking_id must be provided. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Add Chunk to Group
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} groupId Id of the group to add the chunk to as a bookmark
         * @param {AddChunkToGroupReqPayload} addChunkToGroupReqPayload JSON request payload to add a chunk to a group (bookmark it)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addChunkToGroup(tRDataset: string, groupId: string, addChunkToGroupReqPayload: AddChunkToGroupReqPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addChunkToGroup(tRDataset, groupId, addChunkToGroupReqPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.addChunkToGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Route to add a chunk to a group by tracking id. One of chunk_id or chunk_tracking_id must be provided. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Add Chunk to Group by Tracking ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} trackingId Tracking id of the group to add the chunk to as a bookmark
         * @param {AddChunkToGroupReqPayload} addChunkToGroupReqPayload JSON request payload to add a chunk to a group via tracking_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addChunkToGroupByTrackingId(tRDataset: string, trackingId: string, addChunkToGroupReqPayload: AddChunkToGroupReqPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addChunkToGroupByTrackingId(tRDataset, trackingId, addChunkToGroupReqPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.addChunkToGroupByTrackingId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create new chunk_group(s). This is a way to group chunks together. If you try to create a chunk_group with the same tracking_id as an existing chunk_group, this operation will fail. Only 1000 chunk groups can be created at a time. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Create or Upsert Group or Groups
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {CreateChunkGroupReqPayloadEnum} createChunkGroupReqPayloadEnum JSON request payload to cretea a chunk_group(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChunkGroup(tRDataset: string, createChunkGroupReqPayloadEnum: CreateChunkGroupReqPayloadEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateChunkGroupResponseEnum>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChunkGroup(tRDataset, createChunkGroupReqPayloadEnum, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.createChunkGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This will delete a chunk_group. If you set delete_chunks to true, it will also delete the chunks within the group. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Delete Group
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} groupId Id of the group you want to fetch.
         * @param {boolean} deleteChunks Delete the chunks within the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChunkGroup(tRDataset: string, groupId: string, deleteChunks: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChunkGroup(tRDataset, groupId, deleteChunks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.deleteChunkGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a chunk_group with the given tracking id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Delete Group by Tracking ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} trackingId Tracking id of the chunk_group to delete
         * @param {boolean} deleteChunks Delete the chunks within the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupByTrackingId(tRDataset: string, trackingId: string, deleteChunks: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupByTrackingId(tRDataset, trackingId, deleteChunks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.deleteGroupByTrackingId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch the group with the given id.
         * @summary Get Group
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} groupId Id of the group you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChunkGroup(tRDataset: string, groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChunkGroupAndFileId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChunkGroup(tRDataset, groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.getChunkGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Page is 1-indexed.
         * @summary Get Chunks in Group
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} groupId Id of the group you want to fetch.
         * @param {number | null} page The page of chunks to get from the group
         * @param {APIVersion | null} [xAPIVersion] The version of the API to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChunksInGroup(tRDataset: string, groupId: string, page: number | null, xAPIVersion?: APIVersion | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChunksInGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChunksInGroup(tRDataset, groupId, page, xAPIVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.getChunksInGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Support for custom page size is coming soon. Page is 1-indexed.
         * @summary Get Chunks in Group by Tracking ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} groupTrackingId The id of the group to get the chunks from
         * @param {number} page The page of chunks to get from the group
         * @param {APIVersion | null} [xAPIVersion] The version of the API to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChunksInGroupByTrackingId(tRDataset: string, groupTrackingId: string, page: number, xAPIVersion?: APIVersion | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChunksInGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChunksInGroupByTrackingId(tRDataset, groupTrackingId, page, xAPIVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.getChunksInGroupByTrackingId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch the group with the given tracking id. get_group_by_tracking_id
         * @summary Get Group by Tracking ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} trackingId The tracking id of the group to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupByTrackingId(tRDataset: string, trackingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChunkGroupAndFileId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupByTrackingId(tRDataset, trackingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.getGroupByTrackingId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Route to get the groups that a chunk is in.
         * @summary Get Groups for Chunks
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {GetGroupsForChunksReqPayload} getGroupsForChunksReqPayload JSON request payload to get the groups that a chunk is in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupsForChunks(tRDataset: string, getGroupsForChunksReqPayload: GetGroupsForChunksReqPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupsForChunk>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupsForChunks(tRDataset, getGroupsForChunksReqPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.getGroupsForChunks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch the groups which belong to a dataset specified by its id.
         * @summary Get Groups for Dataset
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} datasetId The id of the dataset to fetch groups for.
         * @param {number} page The page of groups to fetch. Page is 1-indexed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupsForDataset(tRDataset: string, datasetId: string, page: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupsForDataset(tRDataset, datasetId, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.getGroupsForDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Route to get recommended groups. This route will return groups which are similar to the groups in the request body. You must provide at least one positive group id or group tracking id.
         * @summary Get Recommended Groups
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {RecommendGroupsReqPayload} recommendGroupsReqPayload JSON request payload to get recommendations of chunks similar to the chunks in the request
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendedGroups(tRDataset: string, recommendGroupsReqPayload: RecommendGroupsReqPayload, xAPIVersion?: APIVersion | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecommendGroupsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendedGroups(tRDataset, recommendGroupsReqPayload, xAPIVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.getRecommendedGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Route to remove a chunk from a group. Auth\'ed user or api key must be an admin or owner of the dataset\'s organization to remove a chunk from a group.
         * @summary Remove Chunk from Group
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} groupId Id of the group you want to remove the chunk from.
         * @param {string | null} [chunkId] Id of the chunk you want to remove from the group
         * @param {RemoveChunkFromGroupReqPayload | null} [removeChunkFromGroupReqPayload] JSON request payload to remove a chunk from a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeChunkFromGroup(tRDataset: string, groupId: string, chunkId?: string | null, removeChunkFromGroupReqPayload?: RemoveChunkFromGroupReqPayload | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeChunkFromGroup(tRDataset, groupId, chunkId, removeChunkFromGroupReqPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.removeChunkFromGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This route allows you to get groups as results instead of chunks. Each group returned will have the matching chunks sorted by similarity within the group. This is useful for when you want to get groups of chunks which are similar to the search query. If choosing hybrid search, the top chunk of each group will be re-ranked using scores from a cross encoder model. Compatible with semantic, fulltext, or hybrid search modes.
         * @summary Search Over Groups
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {SearchOverGroupsReqPayload} searchOverGroupsReqPayload JSON request payload to semantically search over groups
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchOverGroups(tRDataset: string, searchOverGroupsReqPayload: SearchOverGroupsReqPayload, xAPIVersion?: APIVersion | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchOverGroupsResponseTypes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchOverGroups(tRDataset, searchOverGroupsReqPayload, xAPIVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.searchOverGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This route allows you to search only within a group. This is useful for when you only want search results to contain chunks which are members of a specific group. If choosing hybrid search, the results will be re-ranked using scores from a cross encoder model.
         * @summary Search Within Group
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {SearchWithinGroupReqPayload} searchWithinGroupReqPayload JSON request payload to semantically search a group
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchWithinGroup(tRDataset: string, searchWithinGroupReqPayload: SearchWithinGroupReqPayload, xAPIVersion?: APIVersion | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchGroupResponseTypes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchWithinGroup(tRDataset, searchWithinGroupReqPayload, xAPIVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.searchWithinGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a chunk_group. One of group_id or tracking_id must be provided. If you try to change the tracking_id to one that already exists, this operation will fail. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Update Group
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {UpdateChunkGroupReqPayload} updateChunkGroupReqPayload JSON request payload to update a chunkGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateChunkGroup(tRDataset: string, updateChunkGroupReqPayload: UpdateChunkGroupReqPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateChunkGroup(tRDataset, updateChunkGroupReqPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.updateChunkGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a chunk_group with the given tracking id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Update Group by Tracking ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} trackingId Tracking id of the chunk_group to update
         * @param {UpdateGroupByTrackingIDReqPayload} updateGroupByTrackingIDReqPayload JSON request payload to update a chunkGroup
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateGroupByTrackingId(tRDataset: string, trackingId: string, updateGroupByTrackingIDReqPayload: UpdateGroupByTrackingIDReqPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupByTrackingId(tRDataset, trackingId, updateGroupByTrackingIDReqPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.updateGroupByTrackingId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChunkGroupApi - factory interface
 * @export
 */
export const ChunkGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChunkGroupApiFp(configuration)
    return {
        /**
         * Route to add a chunk to a group. One of chunk_id or chunk_tracking_id must be provided. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Add Chunk to Group
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} groupId Id of the group to add the chunk to as a bookmark
         * @param {AddChunkToGroupReqPayload} addChunkToGroupReqPayload JSON request payload to add a chunk to a group (bookmark it)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addChunkToGroup(tRDataset: string, groupId: string, addChunkToGroupReqPayload: AddChunkToGroupReqPayload, options?: any): AxiosPromise<void> {
            return localVarFp.addChunkToGroup(tRDataset, groupId, addChunkToGroupReqPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Route to add a chunk to a group by tracking id. One of chunk_id or chunk_tracking_id must be provided. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Add Chunk to Group by Tracking ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} trackingId Tracking id of the group to add the chunk to as a bookmark
         * @param {AddChunkToGroupReqPayload} addChunkToGroupReqPayload JSON request payload to add a chunk to a group via tracking_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addChunkToGroupByTrackingId(tRDataset: string, trackingId: string, addChunkToGroupReqPayload: AddChunkToGroupReqPayload, options?: any): AxiosPromise<void> {
            return localVarFp.addChunkToGroupByTrackingId(tRDataset, trackingId, addChunkToGroupReqPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new chunk_group(s). This is a way to group chunks together. If you try to create a chunk_group with the same tracking_id as an existing chunk_group, this operation will fail. Only 1000 chunk groups can be created at a time. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Create or Upsert Group or Groups
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {CreateChunkGroupReqPayloadEnum} createChunkGroupReqPayloadEnum JSON request payload to cretea a chunk_group(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChunkGroup(tRDataset: string, createChunkGroupReqPayloadEnum: CreateChunkGroupReqPayloadEnum, options?: any): AxiosPromise<CreateChunkGroupResponseEnum> {
            return localVarFp.createChunkGroup(tRDataset, createChunkGroupReqPayloadEnum, options).then((request) => request(axios, basePath));
        },
        /**
         * This will delete a chunk_group. If you set delete_chunks to true, it will also delete the chunks within the group. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Delete Group
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} groupId Id of the group you want to fetch.
         * @param {boolean} deleteChunks Delete the chunks within the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChunkGroup(tRDataset: string, groupId: string, deleteChunks: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteChunkGroup(tRDataset, groupId, deleteChunks, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a chunk_group with the given tracking id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Delete Group by Tracking ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} trackingId Tracking id of the chunk_group to delete
         * @param {boolean} deleteChunks Delete the chunks within the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupByTrackingId(tRDataset: string, trackingId: string, deleteChunks: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroupByTrackingId(tRDataset, trackingId, deleteChunks, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the group with the given id.
         * @summary Get Group
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} groupId Id of the group you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunkGroup(tRDataset: string, groupId: string, options?: any): AxiosPromise<ChunkGroupAndFileId> {
            return localVarFp.getChunkGroup(tRDataset, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Page is 1-indexed.
         * @summary Get Chunks in Group
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} groupId Id of the group you want to fetch.
         * @param {number | null} page The page of chunks to get from the group
         * @param {APIVersion | null} [xAPIVersion] The version of the API to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunksInGroup(tRDataset: string, groupId: string, page: number | null, xAPIVersion?: APIVersion | null, options?: any): AxiosPromise<GetChunksInGroupResponse> {
            return localVarFp.getChunksInGroup(tRDataset, groupId, page, xAPIVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Support for custom page size is coming soon. Page is 1-indexed.
         * @summary Get Chunks in Group by Tracking ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} groupTrackingId The id of the group to get the chunks from
         * @param {number} page The page of chunks to get from the group
         * @param {APIVersion | null} [xAPIVersion] The version of the API to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunksInGroupByTrackingId(tRDataset: string, groupTrackingId: string, page: number, xAPIVersion?: APIVersion | null, options?: any): AxiosPromise<GetChunksInGroupResponse> {
            return localVarFp.getChunksInGroupByTrackingId(tRDataset, groupTrackingId, page, xAPIVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the group with the given tracking id. get_group_by_tracking_id
         * @summary Get Group by Tracking ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} trackingId The tracking id of the group to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupByTrackingId(tRDataset: string, trackingId: string, options?: any): AxiosPromise<ChunkGroupAndFileId> {
            return localVarFp.getGroupByTrackingId(tRDataset, trackingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Route to get the groups that a chunk is in.
         * @summary Get Groups for Chunks
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {GetGroupsForChunksReqPayload} getGroupsForChunksReqPayload JSON request payload to get the groups that a chunk is in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsForChunks(tRDataset: string, getGroupsForChunksReqPayload: GetGroupsForChunksReqPayload, options?: any): AxiosPromise<Array<GroupsForChunk>> {
            return localVarFp.getGroupsForChunks(tRDataset, getGroupsForChunksReqPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the groups which belong to a dataset specified by its id.
         * @summary Get Groups for Dataset
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} datasetId The id of the dataset to fetch groups for.
         * @param {number} page The page of groups to fetch. Page is 1-indexed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsForDataset(tRDataset: string, datasetId: string, page: number, options?: any): AxiosPromise<GroupData> {
            return localVarFp.getGroupsForDataset(tRDataset, datasetId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Route to get recommended groups. This route will return groups which are similar to the groups in the request body. You must provide at least one positive group id or group tracking id.
         * @summary Get Recommended Groups
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {RecommendGroupsReqPayload} recommendGroupsReqPayload JSON request payload to get recommendations of chunks similar to the chunks in the request
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedGroups(tRDataset: string, recommendGroupsReqPayload: RecommendGroupsReqPayload, xAPIVersion?: APIVersion | null, options?: any): AxiosPromise<RecommendGroupsResponse> {
            return localVarFp.getRecommendedGroups(tRDataset, recommendGroupsReqPayload, xAPIVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Route to remove a chunk from a group. Auth\'ed user or api key must be an admin or owner of the dataset\'s organization to remove a chunk from a group.
         * @summary Remove Chunk from Group
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} groupId Id of the group you want to remove the chunk from.
         * @param {string | null} [chunkId] Id of the chunk you want to remove from the group
         * @param {RemoveChunkFromGroupReqPayload | null} [removeChunkFromGroupReqPayload] JSON request payload to remove a chunk from a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeChunkFromGroup(tRDataset: string, groupId: string, chunkId?: string | null, removeChunkFromGroupReqPayload?: RemoveChunkFromGroupReqPayload | null, options?: any): AxiosPromise<void> {
            return localVarFp.removeChunkFromGroup(tRDataset, groupId, chunkId, removeChunkFromGroupReqPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * This route allows you to get groups as results instead of chunks. Each group returned will have the matching chunks sorted by similarity within the group. This is useful for when you want to get groups of chunks which are similar to the search query. If choosing hybrid search, the top chunk of each group will be re-ranked using scores from a cross encoder model. Compatible with semantic, fulltext, or hybrid search modes.
         * @summary Search Over Groups
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {SearchOverGroupsReqPayload} searchOverGroupsReqPayload JSON request payload to semantically search over groups
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchOverGroups(tRDataset: string, searchOverGroupsReqPayload: SearchOverGroupsReqPayload, xAPIVersion?: APIVersion | null, options?: any): AxiosPromise<SearchOverGroupsResponseTypes> {
            return localVarFp.searchOverGroups(tRDataset, searchOverGroupsReqPayload, xAPIVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * This route allows you to search only within a group. This is useful for when you only want search results to contain chunks which are members of a specific group. If choosing hybrid search, the results will be re-ranked using scores from a cross encoder model.
         * @summary Search Within Group
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {SearchWithinGroupReqPayload} searchWithinGroupReqPayload JSON request payload to semantically search a group
         * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchWithinGroup(tRDataset: string, searchWithinGroupReqPayload: SearchWithinGroupReqPayload, xAPIVersion?: APIVersion | null, options?: any): AxiosPromise<SearchGroupResponseTypes> {
            return localVarFp.searchWithinGroup(tRDataset, searchWithinGroupReqPayload, xAPIVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a chunk_group. One of group_id or tracking_id must be provided. If you try to change the tracking_id to one that already exists, this operation will fail. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Update Group
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {UpdateChunkGroupReqPayload} updateChunkGroupReqPayload JSON request payload to update a chunkGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChunkGroup(tRDataset: string, updateChunkGroupReqPayload: UpdateChunkGroupReqPayload, options?: any): AxiosPromise<void> {
            return localVarFp.updateChunkGroup(tRDataset, updateChunkGroupReqPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a chunk_group with the given tracking id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Update Group by Tracking ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} trackingId Tracking id of the chunk_group to update
         * @param {UpdateGroupByTrackingIDReqPayload} updateGroupByTrackingIDReqPayload JSON request payload to update a chunkGroup
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateGroupByTrackingId(tRDataset: string, trackingId: string, updateGroupByTrackingIDReqPayload: UpdateGroupByTrackingIDReqPayload, options?: any): AxiosPromise<void> {
            return localVarFp.updateGroupByTrackingId(tRDataset, trackingId, updateGroupByTrackingIDReqPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChunkGroupApi - object-oriented interface
 * @export
 * @class ChunkGroupApi
 * @extends {BaseAPI}
 */
export class ChunkGroupApi extends BaseAPI {
    /**
     * Route to add a chunk to a group. One of chunk_id or chunk_tracking_id must be provided. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Add Chunk to Group
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} groupId Id of the group to add the chunk to as a bookmark
     * @param {AddChunkToGroupReqPayload} addChunkToGroupReqPayload JSON request payload to add a chunk to a group (bookmark it)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public addChunkToGroup(tRDataset: string, groupId: string, addChunkToGroupReqPayload: AddChunkToGroupReqPayload, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).addChunkToGroup(tRDataset, groupId, addChunkToGroupReqPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Route to add a chunk to a group by tracking id. One of chunk_id or chunk_tracking_id must be provided. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Add Chunk to Group by Tracking ID
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} trackingId Tracking id of the group to add the chunk to as a bookmark
     * @param {AddChunkToGroupReqPayload} addChunkToGroupReqPayload JSON request payload to add a chunk to a group via tracking_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public addChunkToGroupByTrackingId(tRDataset: string, trackingId: string, addChunkToGroupReqPayload: AddChunkToGroupReqPayload, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).addChunkToGroupByTrackingId(tRDataset, trackingId, addChunkToGroupReqPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new chunk_group(s). This is a way to group chunks together. If you try to create a chunk_group with the same tracking_id as an existing chunk_group, this operation will fail. Only 1000 chunk groups can be created at a time. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Create or Upsert Group or Groups
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {CreateChunkGroupReqPayloadEnum} createChunkGroupReqPayloadEnum JSON request payload to cretea a chunk_group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public createChunkGroup(tRDataset: string, createChunkGroupReqPayloadEnum: CreateChunkGroupReqPayloadEnum, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).createChunkGroup(tRDataset, createChunkGroupReqPayloadEnum, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will delete a chunk_group. If you set delete_chunks to true, it will also delete the chunks within the group. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Delete Group
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} groupId Id of the group you want to fetch.
     * @param {boolean} deleteChunks Delete the chunks within the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public deleteChunkGroup(tRDataset: string, groupId: string, deleteChunks: boolean, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).deleteChunkGroup(tRDataset, groupId, deleteChunks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a chunk_group with the given tracking id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Delete Group by Tracking ID
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} trackingId Tracking id of the chunk_group to delete
     * @param {boolean} deleteChunks Delete the chunks within the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public deleteGroupByTrackingId(tRDataset: string, trackingId: string, deleteChunks: boolean, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).deleteGroupByTrackingId(tRDataset, trackingId, deleteChunks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch the group with the given id.
     * @summary Get Group
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} groupId Id of the group you want to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public getChunkGroup(tRDataset: string, groupId: string, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).getChunkGroup(tRDataset, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Page is 1-indexed.
     * @summary Get Chunks in Group
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} groupId Id of the group you want to fetch.
     * @param {number | null} page The page of chunks to get from the group
     * @param {APIVersion | null} [xAPIVersion] The version of the API to use for the request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public getChunksInGroup(tRDataset: string, groupId: string, page: number | null, xAPIVersion?: APIVersion | null, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).getChunksInGroup(tRDataset, groupId, page, xAPIVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Support for custom page size is coming soon. Page is 1-indexed.
     * @summary Get Chunks in Group by Tracking ID
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} groupTrackingId The id of the group to get the chunks from
     * @param {number} page The page of chunks to get from the group
     * @param {APIVersion | null} [xAPIVersion] The version of the API to use for the request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public getChunksInGroupByTrackingId(tRDataset: string, groupTrackingId: string, page: number, xAPIVersion?: APIVersion | null, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).getChunksInGroupByTrackingId(tRDataset, groupTrackingId, page, xAPIVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch the group with the given tracking id. get_group_by_tracking_id
     * @summary Get Group by Tracking ID
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} trackingId The tracking id of the group to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public getGroupByTrackingId(tRDataset: string, trackingId: string, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).getGroupByTrackingId(tRDataset, trackingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Route to get the groups that a chunk is in.
     * @summary Get Groups for Chunks
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {GetGroupsForChunksReqPayload} getGroupsForChunksReqPayload JSON request payload to get the groups that a chunk is in
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public getGroupsForChunks(tRDataset: string, getGroupsForChunksReqPayload: GetGroupsForChunksReqPayload, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).getGroupsForChunks(tRDataset, getGroupsForChunksReqPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch the groups which belong to a dataset specified by its id.
     * @summary Get Groups for Dataset
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} datasetId The id of the dataset to fetch groups for.
     * @param {number} page The page of groups to fetch. Page is 1-indexed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public getGroupsForDataset(tRDataset: string, datasetId: string, page: number, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).getGroupsForDataset(tRDataset, datasetId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Route to get recommended groups. This route will return groups which are similar to the groups in the request body. You must provide at least one positive group id or group tracking id.
     * @summary Get Recommended Groups
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {RecommendGroupsReqPayload} recommendGroupsReqPayload JSON request payload to get recommendations of chunks similar to the chunks in the request
     * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public getRecommendedGroups(tRDataset: string, recommendGroupsReqPayload: RecommendGroupsReqPayload, xAPIVersion?: APIVersion | null, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).getRecommendedGroups(tRDataset, recommendGroupsReqPayload, xAPIVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Route to remove a chunk from a group. Auth\'ed user or api key must be an admin or owner of the dataset\'s organization to remove a chunk from a group.
     * @summary Remove Chunk from Group
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} groupId Id of the group you want to remove the chunk from.
     * @param {string | null} [chunkId] Id of the chunk you want to remove from the group
     * @param {RemoveChunkFromGroupReqPayload | null} [removeChunkFromGroupReqPayload] JSON request payload to remove a chunk from a group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public removeChunkFromGroup(tRDataset: string, groupId: string, chunkId?: string | null, removeChunkFromGroupReqPayload?: RemoveChunkFromGroupReqPayload | null, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).removeChunkFromGroup(tRDataset, groupId, chunkId, removeChunkFromGroupReqPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route allows you to get groups as results instead of chunks. Each group returned will have the matching chunks sorted by similarity within the group. This is useful for when you want to get groups of chunks which are similar to the search query. If choosing hybrid search, the top chunk of each group will be re-ranked using scores from a cross encoder model. Compatible with semantic, fulltext, or hybrid search modes.
     * @summary Search Over Groups
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {SearchOverGroupsReqPayload} searchOverGroupsReqPayload JSON request payload to semantically search over groups
     * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public searchOverGroups(tRDataset: string, searchOverGroupsReqPayload: SearchOverGroupsReqPayload, xAPIVersion?: APIVersion | null, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).searchOverGroups(tRDataset, searchOverGroupsReqPayload, xAPIVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route allows you to search only within a group. This is useful for when you only want search results to contain chunks which are members of a specific group. If choosing hybrid search, the results will be re-ranked using scores from a cross encoder model.
     * @summary Search Within Group
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {SearchWithinGroupReqPayload} searchWithinGroupReqPayload JSON request payload to semantically search a group
     * @param {APIVersion | null} [xAPIVersion] The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public searchWithinGroup(tRDataset: string, searchWithinGroupReqPayload: SearchWithinGroupReqPayload, xAPIVersion?: APIVersion | null, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).searchWithinGroup(tRDataset, searchWithinGroupReqPayload, xAPIVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a chunk_group. One of group_id or tracking_id must be provided. If you try to change the tracking_id to one that already exists, this operation will fail. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Update Group
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {UpdateChunkGroupReqPayload} updateChunkGroupReqPayload JSON request payload to update a chunkGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public updateChunkGroup(tRDataset: string, updateChunkGroupReqPayload: UpdateChunkGroupReqPayload, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).updateChunkGroup(tRDataset, updateChunkGroupReqPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a chunk_group with the given tracking id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Update Group by Tracking ID
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} trackingId Tracking id of the chunk_group to update
     * @param {UpdateGroupByTrackingIDReqPayload} updateGroupByTrackingIDReqPayload JSON request payload to update a chunkGroup
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public updateGroupByTrackingId(tRDataset: string, trackingId: string, updateGroupByTrackingIDReqPayload: UpdateGroupByTrackingIDReqPayload, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).updateGroupByTrackingId(tRDataset, trackingId, updateGroupByTrackingIDReqPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DatasetApi - axios parameter creator
 * @export
 */
export const DatasetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes all chunks, files, and groups from the dataset while retaining the analytics and dataset itself. The auth\'ed user must be an owner of the organization to clear a dataset.
         * @summary Clear Dataset
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} datasetId The id of the dataset you want to clear.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearDataset: async (tRDataset: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('clearDataset', 'tRDataset', tRDataset)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('clearDataset', 'datasetId', datasetId)
            const localVarPath = `/api/dataset/clear/{dataset_id}`
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Auth\'ed user must be an owner of the organization to create a dataset.
         * @summary Create Dataset
         * @param {string} tROrganization The organization id to use for the request
         * @param {CreateDatasetRequest} createDatasetRequest JSON request payload to create a new dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataset: async (tROrganization: string, createDatasetRequest: CreateDatasetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('createDataset', 'tROrganization', tROrganization)
            // verify required parameter 'createDatasetRequest' is not null or undefined
            assertParamExists('createDataset', 'createDatasetRequest', createDatasetRequest)
            const localVarPath = `/api/dataset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDatasetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Auth\'ed user must be an owner of the organization to delete a dataset.
         * @summary Delete Dataset
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} datasetId The id of the dataset you want to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataset: async (tRDataset: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('deleteDataset', 'tRDataset', tRDataset)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('deleteDataset', 'datasetId', datasetId)
            const localVarPath = `/api/dataset/{dataset_id}`
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Auth\'ed user must be an owner of the organization to delete a dataset.
         * @summary Delete Dataset by Tracking ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} trackingId The tracking id of the dataset you want to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatasetByTrackingId: async (tRDataset: string, trackingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('deleteDatasetByTrackingId', 'tRDataset', tRDataset)
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('deleteDatasetByTrackingId', 'trackingId', trackingId)
            const localVarPath = `/api/dataset/tracking_id/{tracking_id}`
                .replace(`{${"tracking_id"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Scroll through all tags in the dataset and get the number of chunks in the dataset with that tag plus the total number of unique tags for the whole datset.
         * @summary Get All Tags
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {GetAllTagsReqPayload} getAllTagsReqPayload JSON request payload to get items with the tag in the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTags: async (tRDataset: string, getAllTagsReqPayload: GetAllTagsReqPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getAllTags', 'tRDataset', tRDataset)
            // verify required parameter 'getAllTagsReqPayload' is not null or undefined
            assertParamExists('getAllTags', 'getAllTagsReqPayload', getAllTagsReqPayload)
            const localVarPath = `/api/dataset/get_all_tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getAllTagsReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Dataset By ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} datasetId The id of the dataset you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataset: async (tRDataset: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getDataset', 'tRDataset', tRDataset)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getDataset', 'datasetId', datasetId)
            const localVarPath = `/api/dataset/{dataset_id}`
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Dataset by Tracking ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} trackingId The tracking id of the dataset you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetByTrackingId: async (tRDataset: string, trackingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getDatasetByTrackingId', 'tRDataset', tRDataset)
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('getDatasetByTrackingId', 'trackingId', trackingId)
            const localVarPath = `/api/dataset/tracking_id/{tracking_id}`
                .replace(`{${"tracking_id"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Dataset Crawl Options
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} datasetId The id of the dataset you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetCrawlOptions: async (tRDataset: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getDatasetCrawlOptions', 'tRDataset', tRDataset)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getDatasetCrawlOptions', 'datasetId', datasetId)
            const localVarPath = `/api/dataset/crawl_options/{dataset_id}`
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Datasets from Organization
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId id of the organization you want to retrieve datasets for
         * @param {number | null} [limit] The number of records to return
         * @param {number | null} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetsFromOrganization: async (tROrganization: string, organizationId: string, limit?: number | null, offset?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('getDatasetsFromOrganization', 'tROrganization', tROrganization)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getDatasetsFromOrganization', 'organizationId', organizationId)
            const localVarPath = `/api/dataset/organization/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get events for the dataset specified by the TR-Dataset header.
         * @summary Get events for the dataset
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {GetEventsData} getEventsData JSON request payload to get events for a dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (tRDataset: string, getEventsData: GetEventsData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getEvents', 'tRDataset', tRDataset)
            // verify required parameter 'getEventsData' is not null or undefined
            assertParamExists('getEvents', 'getEventsData', getEventsData)
            const localVarPath = `/api/dataset/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEventsData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Usage By Dataset ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} datasetId The id of the dataset you want to retrieve usage for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageByDatasetId: async (tRDataset: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getUsageByDatasetId', 'tRDataset', tRDataset)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getUsageByDatasetId', 'datasetId', datasetId)
            const localVarPath = `/api/dataset/usage/{dataset_id}`
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * One of id or tracking_id must be provided. The auth\'ed user must be an owner of the organization to update a dataset.
         * @summary Update Dataset by ID or Tracking ID
         * @param {string} tROrganization The organization id to use for the request
         * @param {UpdateDatasetRequest} updateDatasetRequest JSON request payload to update a dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataset: async (tROrganization: string, updateDatasetRequest: UpdateDatasetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('updateDataset', 'tROrganization', tROrganization)
            // verify required parameter 'updateDatasetRequest' is not null or undefined
            assertParamExists('updateDataset', 'updateDatasetRequest', updateDatasetRequest)
            const localVarPath = `/api/dataset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDatasetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatasetApi - functional programming interface
 * @export
 */
export const DatasetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatasetApiAxiosParamCreator(configuration)
    return {
        /**
         * Removes all chunks, files, and groups from the dataset while retaining the analytics and dataset itself. The auth\'ed user must be an owner of the organization to clear a dataset.
         * @summary Clear Dataset
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} datasetId The id of the dataset you want to clear.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearDataset(tRDataset: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearDataset(tRDataset, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.clearDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Auth\'ed user must be an owner of the organization to create a dataset.
         * @summary Create Dataset
         * @param {string} tROrganization The organization id to use for the request
         * @param {CreateDatasetRequest} createDatasetRequest JSON request payload to create a new dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDataset(tROrganization: string, createDatasetRequest: CreateDatasetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDataset(tROrganization, createDatasetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.createDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Auth\'ed user must be an owner of the organization to delete a dataset.
         * @summary Delete Dataset
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} datasetId The id of the dataset you want to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDataset(tRDataset: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDataset(tRDataset, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.deleteDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Auth\'ed user must be an owner of the organization to delete a dataset.
         * @summary Delete Dataset by Tracking ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} trackingId The tracking id of the dataset you want to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDatasetByTrackingId(tRDataset: string, trackingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDatasetByTrackingId(tRDataset, trackingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.deleteDatasetByTrackingId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Scroll through all tags in the dataset and get the number of chunks in the dataset with that tag plus the total number of unique tags for the whole datset.
         * @summary Get All Tags
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {GetAllTagsReqPayload} getAllTagsReqPayload JSON request payload to get items with the tag in the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTags(tRDataset: string, getAllTagsReqPayload: GetAllTagsReqPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllTagsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTags(tRDataset, getAllTagsReqPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getAllTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Dataset By ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} datasetId The id of the dataset you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataset(tRDataset: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataset(tRDataset, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Dataset by Tracking ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} trackingId The tracking id of the dataset you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatasetByTrackingId(tRDataset: string, trackingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatasetByTrackingId(tRDataset, trackingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getDatasetByTrackingId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Dataset Crawl Options
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} datasetId The id of the dataset you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatasetCrawlOptions(tRDataset: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCrawlOptionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatasetCrawlOptions(tRDataset, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getDatasetCrawlOptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Datasets from Organization
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId id of the organization you want to retrieve datasets for
         * @param {number | null} [limit] The number of records to return
         * @param {number | null} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatasetsFromOrganization(tROrganization: string, organizationId: string, limit?: number | null, offset?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DatasetAndUsage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatasetsFromOrganization(tROrganization, organizationId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getDatasetsFromOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get events for the dataset specified by the TR-Dataset header.
         * @summary Get events for the dataset
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {GetEventsData} getEventsData JSON request payload to get events for a dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(tRDataset: string, getEventsData: GetEventsData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(tRDataset, getEventsData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Usage By Dataset ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} datasetId The id of the dataset you want to retrieve usage for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsageByDatasetId(tRDataset: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetUsageCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsageByDatasetId(tRDataset, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getUsageByDatasetId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * One of id or tracking_id must be provided. The auth\'ed user must be an owner of the organization to update a dataset.
         * @summary Update Dataset by ID or Tracking ID
         * @param {string} tROrganization The organization id to use for the request
         * @param {UpdateDatasetRequest} updateDatasetRequest JSON request payload to update a dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDataset(tROrganization: string, updateDatasetRequest: UpdateDatasetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDataset(tROrganization, updateDatasetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.updateDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DatasetApi - factory interface
 * @export
 */
export const DatasetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatasetApiFp(configuration)
    return {
        /**
         * Removes all chunks, files, and groups from the dataset while retaining the analytics and dataset itself. The auth\'ed user must be an owner of the organization to clear a dataset.
         * @summary Clear Dataset
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} datasetId The id of the dataset you want to clear.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearDataset(tRDataset: string, datasetId: string, options?: any): AxiosPromise<void> {
            return localVarFp.clearDataset(tRDataset, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Auth\'ed user must be an owner of the organization to create a dataset.
         * @summary Create Dataset
         * @param {string} tROrganization The organization id to use for the request
         * @param {CreateDatasetRequest} createDatasetRequest JSON request payload to create a new dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataset(tROrganization: string, createDatasetRequest: CreateDatasetRequest, options?: any): AxiosPromise<Dataset> {
            return localVarFp.createDataset(tROrganization, createDatasetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Auth\'ed user must be an owner of the organization to delete a dataset.
         * @summary Delete Dataset
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} datasetId The id of the dataset you want to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataset(tRDataset: string, datasetId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDataset(tRDataset, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Auth\'ed user must be an owner of the organization to delete a dataset.
         * @summary Delete Dataset by Tracking ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} trackingId The tracking id of the dataset you want to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatasetByTrackingId(tRDataset: string, trackingId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDatasetByTrackingId(tRDataset, trackingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Scroll through all tags in the dataset and get the number of chunks in the dataset with that tag plus the total number of unique tags for the whole datset.
         * @summary Get All Tags
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {GetAllTagsReqPayload} getAllTagsReqPayload JSON request payload to get items with the tag in the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTags(tRDataset: string, getAllTagsReqPayload: GetAllTagsReqPayload, options?: any): AxiosPromise<GetAllTagsResponse> {
            return localVarFp.getAllTags(tRDataset, getAllTagsReqPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Dataset By ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} datasetId The id of the dataset you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataset(tRDataset: string, datasetId: string, options?: any): AxiosPromise<Dataset> {
            return localVarFp.getDataset(tRDataset, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Dataset by Tracking ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} trackingId The tracking id of the dataset you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetByTrackingId(tRDataset: string, trackingId: string, options?: any): AxiosPromise<Dataset> {
            return localVarFp.getDatasetByTrackingId(tRDataset, trackingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Dataset Crawl Options
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} datasetId The id of the dataset you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetCrawlOptions(tRDataset: string, datasetId: string, options?: any): AxiosPromise<GetCrawlOptionsResponse> {
            return localVarFp.getDatasetCrawlOptions(tRDataset, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Datasets from Organization
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId id of the organization you want to retrieve datasets for
         * @param {number | null} [limit] The number of records to return
         * @param {number | null} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetsFromOrganization(tROrganization: string, organizationId: string, limit?: number | null, offset?: number | null, options?: any): AxiosPromise<Array<DatasetAndUsage>> {
            return localVarFp.getDatasetsFromOrganization(tROrganization, organizationId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Get events for the dataset specified by the TR-Dataset header.
         * @summary Get events for the dataset
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {GetEventsData} getEventsData JSON request payload to get events for a dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(tRDataset: string, getEventsData: GetEventsData, options?: any): AxiosPromise<EventReturn> {
            return localVarFp.getEvents(tRDataset, getEventsData, options).then((request) => request(axios, basePath));
        },
        /**
         * Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Usage By Dataset ID
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} datasetId The id of the dataset you want to retrieve usage for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageByDatasetId(tRDataset: string, datasetId: string, options?: any): AxiosPromise<DatasetUsageCount> {
            return localVarFp.getUsageByDatasetId(tRDataset, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * One of id or tracking_id must be provided. The auth\'ed user must be an owner of the organization to update a dataset.
         * @summary Update Dataset by ID or Tracking ID
         * @param {string} tROrganization The organization id to use for the request
         * @param {UpdateDatasetRequest} updateDatasetRequest JSON request payload to update a dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataset(tROrganization: string, updateDatasetRequest: UpdateDatasetRequest, options?: any): AxiosPromise<Dataset> {
            return localVarFp.updateDataset(tROrganization, updateDatasetRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatasetApi - object-oriented interface
 * @export
 * @class DatasetApi
 * @extends {BaseAPI}
 */
export class DatasetApi extends BaseAPI {
    /**
     * Removes all chunks, files, and groups from the dataset while retaining the analytics and dataset itself. The auth\'ed user must be an owner of the organization to clear a dataset.
     * @summary Clear Dataset
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} datasetId The id of the dataset you want to clear.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public clearDataset(tRDataset: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).clearDataset(tRDataset, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Auth\'ed user must be an owner of the organization to create a dataset.
     * @summary Create Dataset
     * @param {string} tROrganization The organization id to use for the request
     * @param {CreateDatasetRequest} createDatasetRequest JSON request payload to create a new dataset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public createDataset(tROrganization: string, createDatasetRequest: CreateDatasetRequest, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).createDataset(tROrganization, createDatasetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Auth\'ed user must be an owner of the organization to delete a dataset.
     * @summary Delete Dataset
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} datasetId The id of the dataset you want to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public deleteDataset(tRDataset: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).deleteDataset(tRDataset, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Auth\'ed user must be an owner of the organization to delete a dataset.
     * @summary Delete Dataset by Tracking ID
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} trackingId The tracking id of the dataset you want to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public deleteDatasetByTrackingId(tRDataset: string, trackingId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).deleteDatasetByTrackingId(tRDataset, trackingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Scroll through all tags in the dataset and get the number of chunks in the dataset with that tag plus the total number of unique tags for the whole datset.
     * @summary Get All Tags
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {GetAllTagsReqPayload} getAllTagsReqPayload JSON request payload to get items with the tag in the request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getAllTags(tRDataset: string, getAllTagsReqPayload: GetAllTagsReqPayload, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getAllTags(tRDataset, getAllTagsReqPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Get Dataset By ID
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} datasetId The id of the dataset you want to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getDataset(tRDataset: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getDataset(tRDataset, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Get Dataset by Tracking ID
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} trackingId The tracking id of the dataset you want to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getDatasetByTrackingId(tRDataset: string, trackingId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getDatasetByTrackingId(tRDataset, trackingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Get Dataset Crawl Options
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} datasetId The id of the dataset you want to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getDatasetCrawlOptions(tRDataset: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getDatasetCrawlOptions(tRDataset, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Get Datasets from Organization
     * @param {string} tROrganization The organization id to use for the request
     * @param {string} organizationId id of the organization you want to retrieve datasets for
     * @param {number | null} [limit] The number of records to return
     * @param {number | null} [offset] The number of records to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getDatasetsFromOrganization(tROrganization: string, organizationId: string, limit?: number | null, offset?: number | null, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getDatasetsFromOrganization(tROrganization, organizationId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get events for the dataset specified by the TR-Dataset header.
     * @summary Get events for the dataset
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {GetEventsData} getEventsData JSON request payload to get events for a dataset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getEvents(tRDataset: string, getEventsData: GetEventsData, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getEvents(tRDataset, getEventsData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Get Usage By Dataset ID
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} datasetId The id of the dataset you want to retrieve usage for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getUsageByDatasetId(tRDataset: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getUsageByDatasetId(tRDataset, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * One of id or tracking_id must be provided. The auth\'ed user must be an owner of the organization to update a dataset.
     * @summary Update Dataset by ID or Tracking ID
     * @param {string} tROrganization The organization id to use for the request
     * @param {UpdateDatasetRequest} updateDatasetRequest JSON request payload to update a dataset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public updateDataset(tROrganization: string, updateDatasetRequest: UpdateDatasetRequest, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).updateDataset(tROrganization, updateDatasetRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FileApi - axios parameter creator
 * @export
 */
export const FileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a file from S3 attached to the server based on its id. This will disassociate chunks from the file, but only delete them all together if you specify delete_chunks to be true. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Delete File
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} fileId The id of the file to delete
         * @param {boolean} deleteChunks Delete the chunks within the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileHandler: async (tRDataset: string, fileId: string, deleteChunks: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('deleteFileHandler', 'tRDataset', tRDataset)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('deleteFileHandler', 'fileId', fileId)
            // verify required parameter 'deleteChunks' is not null or undefined
            assertParamExists('deleteFileHandler', 'deleteChunks', deleteChunks)
            const localVarPath = `/api/file/{file_id}`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (deleteChunks !== undefined) {
                localVarQueryParameter['delete_chunks'] = deleteChunks;
            }

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all files which belong to a given dataset specified by the dataset_id parameter. 10 files are returned per page.
         * @summary Get Files for Dataset
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} datasetId The id of the dataset to fetch files for.
         * @param {number} page The page number of files you wish to fetch. Each page contains at most 10 files.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetFilesHandler: async (tRDataset: string, datasetId: string, page: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getDatasetFilesHandler', 'tRDataset', tRDataset)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getDatasetFilesHandler', 'datasetId', datasetId)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getDatasetFilesHandler', 'page', page)
            const localVarPath = `/api/dataset/files/{dataset_id}/{page}`
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"page"}}`, encodeURIComponent(String(page)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download a file based on its id.
         * @summary Get File
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} fileId The id of the file to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileHandler: async (tRDataset: string, fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getFileHandler', 'tRDataset', tRDataset)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFileHandler', 'fileId', fileId)
            const localVarPath = `/api/file/{file_id}`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a file to S3 attached to the server. The file will be converted to HTML with tika and chunked algorithmically, images will be OCR\'ed with tesseract. The resulting chunks will be indexed and searchable. Optionally, you can only upload the file and manually create chunks associated to the file after. See docs.trieve.ai and/or contact us for more details and tips. Auth\'ed user must be an admin or owner of the dataset\'s organization to upload a file.
         * @summary Upload File
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {UploadFileReqPayload} uploadFileReqPayload JSON request payload to upload a file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileHandler: async (tRDataset: string, uploadFileReqPayload: UploadFileReqPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('uploadFileHandler', 'tRDataset', tRDataset)
            // verify required parameter 'uploadFileReqPayload' is not null or undefined
            assertParamExists('uploadFileHandler', 'uploadFileReqPayload', uploadFileReqPayload)
            const localVarPath = `/api/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadFileReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileApi - functional programming interface
 * @export
 */
export const FileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a file from S3 attached to the server based on its id. This will disassociate chunks from the file, but only delete them all together if you specify delete_chunks to be true. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Delete File
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} fileId The id of the file to delete
         * @param {boolean} deleteChunks Delete the chunks within the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFileHandler(tRDataset: string, fileId: string, deleteChunks: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFileHandler(tRDataset, fileId, deleteChunks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.deleteFileHandler']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all files which belong to a given dataset specified by the dataset_id parameter. 10 files are returned per page.
         * @summary Get Files for Dataset
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} datasetId The id of the dataset to fetch files for.
         * @param {number} page The page number of files you wish to fetch. Each page contains at most 10 files.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatasetFilesHandler(tRDataset: string, datasetId: string, page: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatasetFilesHandler(tRDataset, datasetId, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.getDatasetFilesHandler']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Download a file based on its id.
         * @summary Get File
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} fileId The id of the file to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileHandler(tRDataset: string, fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileHandler(tRDataset, fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.getFileHandler']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload a file to S3 attached to the server. The file will be converted to HTML with tika and chunked algorithmically, images will be OCR\'ed with tesseract. The resulting chunks will be indexed and searchable. Optionally, you can only upload the file and manually create chunks associated to the file after. See docs.trieve.ai and/or contact us for more details and tips. Auth\'ed user must be an admin or owner of the dataset\'s organization to upload a file.
         * @summary Upload File
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {UploadFileReqPayload} uploadFileReqPayload JSON request payload to upload a file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFileHandler(tRDataset: string, uploadFileReqPayload: UploadFileReqPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadFileResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFileHandler(tRDataset, uploadFileReqPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.uploadFileHandler']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FileApi - factory interface
 * @export
 */
export const FileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileApiFp(configuration)
    return {
        /**
         * Delete a file from S3 attached to the server based on its id. This will disassociate chunks from the file, but only delete them all together if you specify delete_chunks to be true. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Delete File
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} fileId The id of the file to delete
         * @param {boolean} deleteChunks Delete the chunks within the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileHandler(tRDataset: string, fileId: string, deleteChunks: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFileHandler(tRDataset, fileId, deleteChunks, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all files which belong to a given dataset specified by the dataset_id parameter. 10 files are returned per page.
         * @summary Get Files for Dataset
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} datasetId The id of the dataset to fetch files for.
         * @param {number} page The page number of files you wish to fetch. Each page contains at most 10 files.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetFilesHandler(tRDataset: string, datasetId: string, page: number, options?: any): AxiosPromise<Array<any>> {
            return localVarFp.getDatasetFilesHandler(tRDataset, datasetId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Download a file based on its id.
         * @summary Get File
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} fileId The id of the file to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileHandler(tRDataset: string, fileId: string, options?: any): AxiosPromise<FileDTO> {
            return localVarFp.getFileHandler(tRDataset, fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a file to S3 attached to the server. The file will be converted to HTML with tika and chunked algorithmically, images will be OCR\'ed with tesseract. The resulting chunks will be indexed and searchable. Optionally, you can only upload the file and manually create chunks associated to the file after. See docs.trieve.ai and/or contact us for more details and tips. Auth\'ed user must be an admin or owner of the dataset\'s organization to upload a file.
         * @summary Upload File
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {UploadFileReqPayload} uploadFileReqPayload JSON request payload to upload a file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileHandler(tRDataset: string, uploadFileReqPayload: UploadFileReqPayload, options?: any): AxiosPromise<UploadFileResult> {
            return localVarFp.uploadFileHandler(tRDataset, uploadFileReqPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
export class FileApi extends BaseAPI {
    /**
     * Delete a file from S3 attached to the server based on its id. This will disassociate chunks from the file, but only delete them all together if you specify delete_chunks to be true. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Delete File
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} fileId The id of the file to delete
     * @param {boolean} deleteChunks Delete the chunks within the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public deleteFileHandler(tRDataset: string, fileId: string, deleteChunks: boolean, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).deleteFileHandler(tRDataset, fileId, deleteChunks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all files which belong to a given dataset specified by the dataset_id parameter. 10 files are returned per page.
     * @summary Get Files for Dataset
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} datasetId The id of the dataset to fetch files for.
     * @param {number} page The page number of files you wish to fetch. Each page contains at most 10 files.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public getDatasetFilesHandler(tRDataset: string, datasetId: string, page: number, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).getDatasetFilesHandler(tRDataset, datasetId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download a file based on its id.
     * @summary Get File
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} fileId The id of the file to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public getFileHandler(tRDataset: string, fileId: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).getFileHandler(tRDataset, fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a file to S3 attached to the server. The file will be converted to HTML with tika and chunked algorithmically, images will be OCR\'ed with tesseract. The resulting chunks will be indexed and searchable. Optionally, you can only upload the file and manually create chunks associated to the file after. See docs.trieve.ai and/or contact us for more details and tips. Auth\'ed user must be an admin or owner of the dataset\'s organization to upload a file.
     * @summary Upload File
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {UploadFileReqPayload} uploadFileReqPayload JSON request payload to upload a file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public uploadFileHandler(tRDataset: string, uploadFileReqPayload: UploadFileReqPayload, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).uploadFileHandler(tRDataset, uploadFileReqPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Confirmation that the service is healthy and can make embedding vectors
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * Confirmation that the service is healthy and can make embedding vectors
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * Confirmation that the service is healthy and can make embedding vectors
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(options?: any): AxiosPromise<void> {
            return localVarFp.healthCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * Confirmation that the service is healthy and can make embedding vectors
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public healthCheck(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthCheck(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InvitationApi - axios parameter creator
 * @export
 */
export const InvitationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an invitation by id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Delete Invitation
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} invitationId The id of the invitation to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvitation: async (tROrganization: string, invitationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('deleteInvitation', 'tROrganization', tROrganization)
            // verify required parameter 'invitationId' is not null or undefined
            assertParamExists('deleteInvitation', 'invitationId', invitationId)
            const localVarPath = `/api/invitation/{invitation_id}`
                .replace(`{${"invitation_id"}}`, encodeURIComponent(String(invitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all invitations for the organization. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Invitations
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The organization id to get invitations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvitations: async (tROrganization: string, organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('getInvitations', 'tROrganization', tROrganization)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getInvitations', 'organizationId', organizationId)
            const localVarPath = `/api/invitations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invitations act as a way to invite users to join an organization. After a user is invited, they will automatically be added to the organization with the role specified in the invitation once they set their. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Send Invitation
         * @param {string} tROrganization The organization id to use for the request
         * @param {InvitationData} invitationData JSON request payload to send an invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInvitation: async (tROrganization: string, invitationData: InvitationData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('postInvitation', 'tROrganization', tROrganization)
            // verify required parameter 'invitationData' is not null or undefined
            assertParamExists('postInvitation', 'invitationData', invitationData)
            const localVarPath = `/api/invitation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invitationData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvitationApi - functional programming interface
 * @export
 */
export const InvitationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvitationApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete an invitation by id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Delete Invitation
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} invitationId The id of the invitation to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvitation(tROrganization: string, invitationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvitation(tROrganization, invitationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitationApi.deleteInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all invitations for the organization. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Invitations
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The organization id to get invitations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvitations(tROrganization: string, organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invitation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvitations(tROrganization, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitationApi.getInvitations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invitations act as a way to invite users to join an organization. After a user is invited, they will automatically be added to the organization with the role specified in the invitation once they set their. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Send Invitation
         * @param {string} tROrganization The organization id to use for the request
         * @param {InvitationData} invitationData JSON request payload to send an invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postInvitation(tROrganization: string, invitationData: InvitationData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInvitation(tROrganization, invitationData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitationApi.postInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InvitationApi - factory interface
 * @export
 */
export const InvitationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvitationApiFp(configuration)
    return {
        /**
         * Delete an invitation by id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Delete Invitation
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} invitationId The id of the invitation to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvitation(tROrganization: string, invitationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteInvitation(tROrganization, invitationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all invitations for the organization. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Invitations
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The organization id to get invitations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvitations(tROrganization: string, organizationId: string, options?: any): AxiosPromise<Array<Invitation>> {
            return localVarFp.getInvitations(tROrganization, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Invitations act as a way to invite users to join an organization. After a user is invited, they will automatically be added to the organization with the role specified in the invitation once they set their. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Send Invitation
         * @param {string} tROrganization The organization id to use for the request
         * @param {InvitationData} invitationData JSON request payload to send an invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInvitation(tROrganization: string, invitationData: InvitationData, options?: any): AxiosPromise<void> {
            return localVarFp.postInvitation(tROrganization, invitationData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvitationApi - object-oriented interface
 * @export
 * @class InvitationApi
 * @extends {BaseAPI}
 */
export class InvitationApi extends BaseAPI {
    /**
     * Delete an invitation by id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Delete Invitation
     * @param {string} tROrganization The organization id to use for the request
     * @param {string} invitationId The id of the invitation to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public deleteInvitation(tROrganization: string, invitationId: string, options?: RawAxiosRequestConfig) {
        return InvitationApiFp(this.configuration).deleteInvitation(tROrganization, invitationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all invitations for the organization. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Get Invitations
     * @param {string} tROrganization The organization id to use for the request
     * @param {string} organizationId The organization id to get invitations for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public getInvitations(tROrganization: string, organizationId: string, options?: RawAxiosRequestConfig) {
        return InvitationApiFp(this.configuration).getInvitations(tROrganization, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invitations act as a way to invite users to join an organization. After a user is invited, they will automatically be added to the organization with the role specified in the invitation once they set their. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Send Invitation
     * @param {string} tROrganization The organization id to use for the request
     * @param {InvitationData} invitationData JSON request payload to send an invitation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public postInvitation(tROrganization: string, invitationData: InvitationData, options?: RawAxiosRequestConfig) {
        return InvitationApiFp(this.configuration).postInvitation(tROrganization, invitationData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MessageApi - axios parameter creator
 * @export
 */
export const MessageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create message. Messages are attached to topics in order to coordinate memory of gen-AI chat sessions.Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Create message
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {CreateMessageReqPayload} createMessageReqPayload JSON request payload to create a message completion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessage: async (tRDataset: string, createMessageReqPayload: CreateMessageReqPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('createMessage', 'tRDataset', tRDataset)
            // verify required parameter 'createMessageReqPayload' is not null or undefined
            assertParamExists('createMessage', 'createMessageReqPayload', createMessageReqPayload)
            const localVarPath = `/api/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMessageReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit message which exists within the topic\'s chat history. This will delete the message and replace it with a new message. The new message will be generated by the AI based on the new content provided in the request body. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Edit message
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {EditMessageReqPayload} editMessageReqPayload JSON request payload to edit a message and get a new stream
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMessage: async (tRDataset: string, editMessageReqPayload: EditMessageReqPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('editMessage', 'tRDataset', tRDataset)
            // verify required parameter 'editMessageReqPayload' is not null or undefined
            assertParamExists('editMessage', 'editMessageReqPayload', editMessageReqPayload)
            const localVarPath = `/api/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editMessageReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all messages for a given topic. If the topic is a RAG topic then the response will include Chunks first on each message. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
         * @summary Get all messages for a given topic
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} messagesTopicId The ID of the topic to get messages for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTopicMessages: async (tRDataset: string, messagesTopicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getAllTopicMessages', 'tRDataset', tRDataset)
            // verify required parameter 'messagesTopicId' is not null or undefined
            assertParamExists('getAllTopicMessages', 'messagesTopicId', messagesTopicId)
            const localVarPath = `/api/messages/{messages_topic_id}`
                .replace(`{${"messages_topic_id"}}`, encodeURIComponent(String(messagesTopicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Regenerate message
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {RegenerateMessageReqPayload} regenerateMessageReqPayload JSON request payload to delete an agent message then regenerate it in a strem
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        regenerateMessage: async (tRDataset: string, regenerateMessageReqPayload: RegenerateMessageReqPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('regenerateMessage', 'tRDataset', tRDataset)
            // verify required parameter 'regenerateMessageReqPayload' is not null or undefined
            assertParamExists('regenerateMessage', 'regenerateMessageReqPayload', regenerateMessageReqPayload)
            const localVarPath = `/api/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regenerateMessageReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Regenerate message
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {RegenerateMessageReqPayload} regenerateMessageReqPayload JSON request payload to delete an agent message then regenerate it in a strem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateMessagePatch: async (tRDataset: string, regenerateMessageReqPayload: RegenerateMessageReqPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('regenerateMessagePatch', 'tRDataset', tRDataset)
            // verify required parameter 'regenerateMessageReqPayload' is not null or undefined
            assertParamExists('regenerateMessagePatch', 'regenerateMessageReqPayload', regenerateMessageReqPayload)
            const localVarPath = `/api/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regenerateMessageReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessageApi - functional programming interface
 * @export
 */
export const MessageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessageApiAxiosParamCreator(configuration)
    return {
        /**
         * Create message. Messages are attached to topics in order to coordinate memory of gen-AI chat sessions.Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Create message
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {CreateMessageReqPayload} createMessageReqPayload JSON request payload to create a message completion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMessage(tRDataset: string, createMessageReqPayload: CreateMessageReqPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMessage(tRDataset, createMessageReqPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessageApi.createMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit message which exists within the topic\'s chat history. This will delete the message and replace it with a new message. The new message will be generated by the AI based on the new content provided in the request body. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Edit message
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {EditMessageReqPayload} editMessageReqPayload JSON request payload to edit a message and get a new stream
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editMessage(tRDataset: string, editMessageReqPayload: EditMessageReqPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editMessage(tRDataset, editMessageReqPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessageApi.editMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all messages for a given topic. If the topic is a RAG topic then the response will include Chunks first on each message. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
         * @summary Get all messages for a given topic
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} messagesTopicId The ID of the topic to get messages for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTopicMessages(tRDataset: string, messagesTopicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Message>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTopicMessages(tRDataset, messagesTopicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessageApi.getAllTopicMessages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Regenerate message
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {RegenerateMessageReqPayload} regenerateMessageReqPayload JSON request payload to delete an agent message then regenerate it in a strem
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async regenerateMessage(tRDataset: string, regenerateMessageReqPayload: RegenerateMessageReqPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regenerateMessage(tRDataset, regenerateMessageReqPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessageApi.regenerateMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Regenerate message
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {RegenerateMessageReqPayload} regenerateMessageReqPayload JSON request payload to delete an agent message then regenerate it in a strem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regenerateMessagePatch(tRDataset: string, regenerateMessageReqPayload: RegenerateMessageReqPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regenerateMessagePatch(tRDataset, regenerateMessageReqPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessageApi.regenerateMessagePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MessageApi - factory interface
 * @export
 */
export const MessageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessageApiFp(configuration)
    return {
        /**
         * Create message. Messages are attached to topics in order to coordinate memory of gen-AI chat sessions.Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Create message
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {CreateMessageReqPayload} createMessageReqPayload JSON request payload to create a message completion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessage(tRDataset: string, createMessageReqPayload: CreateMessageReqPayload, options?: any): AxiosPromise<string> {
            return localVarFp.createMessage(tRDataset, createMessageReqPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit message which exists within the topic\'s chat history. This will delete the message and replace it with a new message. The new message will be generated by the AI based on the new content provided in the request body. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Edit message
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {EditMessageReqPayload} editMessageReqPayload JSON request payload to edit a message and get a new stream
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMessage(tRDataset: string, editMessageReqPayload: EditMessageReqPayload, options?: any): AxiosPromise<void> {
            return localVarFp.editMessage(tRDataset, editMessageReqPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all messages for a given topic. If the topic is a RAG topic then the response will include Chunks first on each message. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
         * @summary Get all messages for a given topic
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} messagesTopicId The ID of the topic to get messages for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTopicMessages(tRDataset: string, messagesTopicId: string, options?: any): AxiosPromise<Array<Message>> {
            return localVarFp.getAllTopicMessages(tRDataset, messagesTopicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Regenerate message
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {RegenerateMessageReqPayload} regenerateMessageReqPayload JSON request payload to delete an agent message then regenerate it in a strem
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        regenerateMessage(tRDataset: string, regenerateMessageReqPayload: RegenerateMessageReqPayload, options?: any): AxiosPromise<string> {
            return localVarFp.regenerateMessage(tRDataset, regenerateMessageReqPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Regenerate message
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {RegenerateMessageReqPayload} regenerateMessageReqPayload JSON request payload to delete an agent message then regenerate it in a strem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateMessagePatch(tRDataset: string, regenerateMessageReqPayload: RegenerateMessageReqPayload, options?: any): AxiosPromise<string> {
            return localVarFp.regenerateMessagePatch(tRDataset, regenerateMessageReqPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessageApi - object-oriented interface
 * @export
 * @class MessageApi
 * @extends {BaseAPI}
 */
export class MessageApi extends BaseAPI {
    /**
     * Create message. Messages are attached to topics in order to coordinate memory of gen-AI chat sessions.Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Create message
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {CreateMessageReqPayload} createMessageReqPayload JSON request payload to create a message completion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public createMessage(tRDataset: string, createMessageReqPayload: CreateMessageReqPayload, options?: RawAxiosRequestConfig) {
        return MessageApiFp(this.configuration).createMessage(tRDataset, createMessageReqPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit message which exists within the topic\'s chat history. This will delete the message and replace it with a new message. The new message will be generated by the AI based on the new content provided in the request body. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Edit message
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {EditMessageReqPayload} editMessageReqPayload JSON request payload to edit a message and get a new stream
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public editMessage(tRDataset: string, editMessageReqPayload: EditMessageReqPayload, options?: RawAxiosRequestConfig) {
        return MessageApiFp(this.configuration).editMessage(tRDataset, editMessageReqPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all messages for a given topic. If the topic is a RAG topic then the response will include Chunks first on each message. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
     * @summary Get all messages for a given topic
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} messagesTopicId The ID of the topic to get messages for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public getAllTopicMessages(tRDataset: string, messagesTopicId: string, options?: RawAxiosRequestConfig) {
        return MessageApiFp(this.configuration).getAllTopicMessages(tRDataset, messagesTopicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Regenerate message
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {RegenerateMessageReqPayload} regenerateMessageReqPayload JSON request payload to delete an agent message then regenerate it in a strem
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public regenerateMessage(tRDataset: string, regenerateMessageReqPayload: RegenerateMessageReqPayload, options?: RawAxiosRequestConfig) {
        return MessageApiFp(this.configuration).regenerateMessage(tRDataset, regenerateMessageReqPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Regenerate message
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {RegenerateMessageReqPayload} regenerateMessageReqPayload JSON request payload to delete an agent message then regenerate it in a strem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public regenerateMessagePatch(tRDataset: string, regenerateMessageReqPayload: RegenerateMessageReqPayload, options?: RawAxiosRequestConfig) {
        return MessageApiFp(this.configuration).regenerateMessagePatch(tRDataset, regenerateMessageReqPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This route allows you to view the number of items in each queue in the Prometheus format.
         * @summary Get Prometheus Metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * This route allows you to view the number of items in each queue in the Prometheus format.
         * @summary Get Prometheus Metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetrics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetrics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.getMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * This route allows you to view the number of items in each queue in the Prometheus format.
         * @summary Get Prometheus Metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(options?: any): AxiosPromise<string> {
            return localVarFp.getMetrics(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * This route allows you to view the number of items in each queue in the Prometheus format.
     * @summary Get Prometheus Metrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetrics(options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getMetrics(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new organization. The auth\'ed user who creates the organization will be the default owner of the organization.
         * @summary Create Organization
         * @param {CreateOrganizationReqPayload} createOrganizationReqPayload The organization data that you want to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization: async (createOrganizationReqPayload: CreateOrganizationReqPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrganizationReqPayload' is not null or undefined
            assertParamExists('createOrganization', 'createOrganizationReqPayload', createOrganizationReqPayload)
            const localVarPath = `/api/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrganizationReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an organization by its id. The auth\'ed user must be an owner of the organization to delete it.
         * @summary Delete Organization
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The id of the organization you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization: async (tROrganization: string, organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('deleteOrganization', 'tROrganization', tROrganization)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganization', 'organizationId', organizationId)
            const localVarPath = `/api/organization/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the details of an organization by its id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Organization
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The id of the organization you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: async (tROrganization: string, organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('getOrganization', 'tROrganization', tROrganization)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganization', 'organizationId', organizationId)
            const localVarPath = `/api/organization/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the current usage specification of an organization by its id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Organization Usage
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The id of the organization you want to fetch the usage of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUsage: async (tROrganization: string, organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('getOrganizationUsage', 'tROrganization', tROrganization)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationUsage', 'organizationId', organizationId)
            const localVarPath = `/api/organization/usage/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the users of an organization by its id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Organization Users
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The id of the organization you want to fetch the users of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUsers: async (tROrganization: string, organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('getOrganizationUsers', 'tROrganization', tROrganization)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationUsers', 'organizationId', organizationId)
            const localVarPath = `/api/organization/users/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the configurations for all datasets in an organization. Only the specified keys in the configuration object will be changed per dataset such that you can preserve dataset unique values. Auth\'ed user or api key must have an owner role for the specified organization.
         * @summary Update All Dataset Configurations
         * @param {string} tROrganization The organization id to use for the request
         * @param {UpdateAllOrgDatasetConfigsReqPayload} updateAllOrgDatasetConfigsReqPayload The organization data that you want to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAllOrgDatasetConfigs: async (tROrganization: string, updateAllOrgDatasetConfigsReqPayload: UpdateAllOrgDatasetConfigsReqPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('updateAllOrgDatasetConfigs', 'tROrganization', tROrganization)
            // verify required parameter 'updateAllOrgDatasetConfigsReqPayload' is not null or undefined
            assertParamExists('updateAllOrgDatasetConfigs', 'updateAllOrgDatasetConfigsReqPayload', updateAllOrgDatasetConfigsReqPayload)
            const localVarPath = `/api/organization/update_dataset_configs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAllOrgDatasetConfigsReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an organization. Only the owner of the organization can update it.
         * @summary Update Organization
         * @param {string} tROrganization The organization id to use for the request
         * @param {UpdateOrganizationReqPayload} updateOrganizationReqPayload The organization data that you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization: async (tROrganization: string, updateOrganizationReqPayload: UpdateOrganizationReqPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('updateOrganization', 'tROrganization', tROrganization)
            // verify required parameter 'updateOrganizationReqPayload' is not null or undefined
            assertParamExists('updateOrganization', 'updateOrganizationReqPayload', updateOrganizationReqPayload)
            const localVarPath = `/api/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrganizationReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new organization. The auth\'ed user who creates the organization will be the default owner of the organization.
         * @summary Create Organization
         * @param {CreateOrganizationReqPayload} createOrganizationReqPayload The organization data that you want to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganization(createOrganizationReqPayload: CreateOrganizationReqPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganization(createOrganizationReqPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.createOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an organization by its id. The auth\'ed user must be an owner of the organization to delete it.
         * @summary Delete Organization
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The id of the organization you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganization(tROrganization: string, organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganization(tROrganization, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.deleteOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch the details of an organization by its id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Organization
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The id of the organization you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganization(tROrganization: string, organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationWithSubAndPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganization(tROrganization, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch the current usage specification of an organization by its id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Organization Usage
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The id of the organization you want to fetch the usage of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationUsage(tROrganization: string, organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationUsageCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationUsage(tROrganization, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getOrganizationUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch the users of an organization by its id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Organization Users
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The id of the organization you want to fetch the users of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationUsers(tROrganization: string, organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SlimUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationUsers(tROrganization, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getOrganizationUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the configurations for all datasets in an organization. Only the specified keys in the configuration object will be changed per dataset such that you can preserve dataset unique values. Auth\'ed user or api key must have an owner role for the specified organization.
         * @summary Update All Dataset Configurations
         * @param {string} tROrganization The organization id to use for the request
         * @param {UpdateAllOrgDatasetConfigsReqPayload} updateAllOrgDatasetConfigsReqPayload The organization data that you want to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAllOrgDatasetConfigs(tROrganization: string, updateAllOrgDatasetConfigsReqPayload: UpdateAllOrgDatasetConfigsReqPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAllOrgDatasetConfigs(tROrganization, updateAllOrgDatasetConfigsReqPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.updateAllOrgDatasetConfigs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an organization. Only the owner of the organization can update it.
         * @summary Update Organization
         * @param {string} tROrganization The organization id to use for the request
         * @param {UpdateOrganizationReqPayload} updateOrganizationReqPayload The organization data that you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganization(tROrganization: string, updateOrganizationReqPayload: UpdateOrganizationReqPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganization(tROrganization, updateOrganizationReqPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.updateOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiFp(configuration)
    return {
        /**
         * Create a new organization. The auth\'ed user who creates the organization will be the default owner of the organization.
         * @summary Create Organization
         * @param {CreateOrganizationReqPayload} createOrganizationReqPayload The organization data that you want to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(createOrganizationReqPayload: CreateOrganizationReqPayload, options?: any): AxiosPromise<Organization> {
            return localVarFp.createOrganization(createOrganizationReqPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an organization by its id. The auth\'ed user must be an owner of the organization to delete it.
         * @summary Delete Organization
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The id of the organization you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(tROrganization: string, organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganization(tROrganization, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the details of an organization by its id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Organization
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The id of the organization you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(tROrganization: string, organizationId: string, options?: any): AxiosPromise<OrganizationWithSubAndPlan> {
            return localVarFp.getOrganization(tROrganization, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the current usage specification of an organization by its id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Organization Usage
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The id of the organization you want to fetch the usage of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUsage(tROrganization: string, organizationId: string, options?: any): AxiosPromise<OrganizationUsageCount> {
            return localVarFp.getOrganizationUsage(tROrganization, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the users of an organization by its id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get Organization Users
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The id of the organization you want to fetch the users of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUsers(tROrganization: string, organizationId: string, options?: any): AxiosPromise<Array<SlimUser>> {
            return localVarFp.getOrganizationUsers(tROrganization, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the configurations for all datasets in an organization. Only the specified keys in the configuration object will be changed per dataset such that you can preserve dataset unique values. Auth\'ed user or api key must have an owner role for the specified organization.
         * @summary Update All Dataset Configurations
         * @param {string} tROrganization The organization id to use for the request
         * @param {UpdateAllOrgDatasetConfigsReqPayload} updateAllOrgDatasetConfigsReqPayload The organization data that you want to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAllOrgDatasetConfigs(tROrganization: string, updateAllOrgDatasetConfigsReqPayload: UpdateAllOrgDatasetConfigsReqPayload, options?: any): AxiosPromise<void> {
            return localVarFp.updateAllOrgDatasetConfigs(tROrganization, updateAllOrgDatasetConfigsReqPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an organization. Only the owner of the organization can update it.
         * @summary Update Organization
         * @param {string} tROrganization The organization id to use for the request
         * @param {UpdateOrganizationReqPayload} updateOrganizationReqPayload The organization data that you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(tROrganization: string, updateOrganizationReqPayload: UpdateOrganizationReqPayload, options?: any): AxiosPromise<Organization> {
            return localVarFp.updateOrganization(tROrganization, updateOrganizationReqPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * Create a new organization. The auth\'ed user who creates the organization will be the default owner of the organization.
     * @summary Create Organization
     * @param {CreateOrganizationReqPayload} createOrganizationReqPayload The organization data that you want to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public createOrganization(createOrganizationReqPayload: CreateOrganizationReqPayload, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).createOrganization(createOrganizationReqPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an organization by its id. The auth\'ed user must be an owner of the organization to delete it.
     * @summary Delete Organization
     * @param {string} tROrganization The organization id to use for the request
     * @param {string} organizationId The id of the organization you want to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public deleteOrganization(tROrganization: string, organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).deleteOrganization(tROrganization, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch the details of an organization by its id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Get Organization
     * @param {string} tROrganization The organization id to use for the request
     * @param {string} organizationId The id of the organization you want to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganization(tROrganization: string, organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganization(tROrganization, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch the current usage specification of an organization by its id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Get Organization Usage
     * @param {string} tROrganization The organization id to use for the request
     * @param {string} organizationId The id of the organization you want to fetch the usage of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationUsage(tROrganization: string, organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganizationUsage(tROrganization, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch the users of an organization by its id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Get Organization Users
     * @param {string} tROrganization The organization id to use for the request
     * @param {string} organizationId The id of the organization you want to fetch the users of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationUsers(tROrganization: string, organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganizationUsers(tROrganization, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the configurations for all datasets in an organization. Only the specified keys in the configuration object will be changed per dataset such that you can preserve dataset unique values. Auth\'ed user or api key must have an owner role for the specified organization.
     * @summary Update All Dataset Configurations
     * @param {string} tROrganization The organization id to use for the request
     * @param {UpdateAllOrgDatasetConfigsReqPayload} updateAllOrgDatasetConfigsReqPayload The organization data that you want to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateAllOrgDatasetConfigs(tROrganization: string, updateAllOrgDatasetConfigsReqPayload: UpdateAllOrgDatasetConfigsReqPayload, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateAllOrgDatasetConfigs(tROrganization, updateAllOrgDatasetConfigsReqPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an organization. Only the owner of the organization can update it.
     * @summary Update Organization
     * @param {string} tROrganization The organization id to use for the request
     * @param {UpdateOrganizationReqPayload} updateOrganizationReqPayload The organization data that you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateOrganization(tROrganization: string, updateOrganizationReqPayload: UpdateOrganizationReqPayload, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateOrganization(tROrganization, updateOrganizationReqPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PublicApi - axios parameter creator
 * @export
 */
export const PublicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} datasetId The id of the organization you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicPage: async (datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('publicPage', 'datasetId', datasetId)
            const localVarPath = `/api/public_page/{dataset_id}`
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicApi - functional programming interface
 * @export
 */
export const PublicApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} datasetId The id of the organization you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicPage(datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicPage(datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.publicPage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PublicApi - factory interface
 * @export
 */
export const PublicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicApiFp(configuration)
    return {
        /**
         * 
         * @param {string} datasetId The id of the organization you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicPage(datasetId: string, options?: any): AxiosPromise<void> {
            return localVarFp.publicPage(datasetId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
export class PublicApi extends BaseAPI {
    /**
     * 
     * @param {string} datasetId The id of the organization you want to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public publicPage(datasetId: string, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).publicPage(datasetId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StripeApi - axios parameter creator
 * @export
 */
export const StripeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel a subscription by its id
         * @summary Cancel Subscription
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} subscriptionId id of the subscription you want to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscription: async (tROrganization: string, subscriptionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('cancelSubscription', 'tROrganization', tROrganization)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('cancelSubscription', 'subscriptionId', subscriptionId)
            const localVarPath = `/api/stripe/subscription/{subscription_id}`
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a checkout session (setup)
         * @summary Create checkout session setup
         * @param {string} organizationId The id of the organization to create setup checkout session for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSetupCheckoutSession: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createSetupCheckoutSession', 'organizationId', organizationId)
            const localVarPath = `/api/stripe/checkout/setup/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a 303 SeeOther redirect link to the stripe checkout page for the plan and organization
         * @summary Checkout
         * @param {string} planId id of the plan you want to subscribe to
         * @param {string} organizationId id of the organization you want to subscribe to the plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directToPaymentLink: async (planId: string, organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('directToPaymentLink', 'planId', planId)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('directToPaymentLink', 'organizationId', organizationId)
            const localVarPath = `/api/stripe/payment_link/{plan_id}/{organization_id}`
                .replace(`{${"plan_id"}}`, encodeURIComponent(String(planId)))
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all invoices
         * @summary Get All Invoices
         * @param {string} organizationId The id of the organization to get invoices for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInvoices: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getAllInvoices', 'organizationId', organizationId)
            const localVarPath = `/api/stripe/invoices/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all plans
         * @summary Get All Plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPlans: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stripe/plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a subscription to a new plan
         * @summary Update Subscription Plan
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} subscriptionId id of the subscription you want to update
         * @param {string} planId id of the plan you want to subscribe to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionPlan: async (tROrganization: string, subscriptionId: string, planId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('updateSubscriptionPlan', 'tROrganization', tROrganization)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('updateSubscriptionPlan', 'subscriptionId', subscriptionId)
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('updateSubscriptionPlan', 'planId', planId)
            const localVarPath = `/api/stripe/subscription_plan/{subscription_id}/{plan_id}`
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)))
                .replace(`{${"plan_id"}}`, encodeURIComponent(String(planId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StripeApi - functional programming interface
 * @export
 */
export const StripeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StripeApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel a subscription by its id
         * @summary Cancel Subscription
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} subscriptionId id of the subscription you want to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelSubscription(tROrganization: string, subscriptionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelSubscription(tROrganization, subscriptionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripeApi.cancelSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a checkout session (setup)
         * @summary Create checkout session setup
         * @param {string} organizationId The id of the organization to create setup checkout session for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSetupCheckoutSession(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSetupCheckoutSessionResPayload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSetupCheckoutSession(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripeApi.createSetupCheckoutSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a 303 SeeOther redirect link to the stripe checkout page for the plan and organization
         * @summary Checkout
         * @param {string} planId id of the plan you want to subscribe to
         * @param {string} organizationId id of the organization you want to subscribe to the plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async directToPaymentLink(planId: string, organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.directToPaymentLink(planId, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripeApi.directToPaymentLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all invoices
         * @summary Get All Invoices
         * @param {string} organizationId The id of the organization to get invoices for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllInvoices(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StripeInvoice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllInvoices(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripeApi.getAllInvoices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all plans
         * @summary Get All Plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPlans(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StripePlan>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPlans(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripeApi.getAllPlans']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a subscription to a new plan
         * @summary Update Subscription Plan
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} subscriptionId id of the subscription you want to update
         * @param {string} planId id of the plan you want to subscribe to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubscriptionPlan(tROrganization: string, subscriptionId: string, planId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubscriptionPlan(tROrganization, subscriptionId, planId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripeApi.updateSubscriptionPlan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StripeApi - factory interface
 * @export
 */
export const StripeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StripeApiFp(configuration)
    return {
        /**
         * Cancel a subscription by its id
         * @summary Cancel Subscription
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} subscriptionId id of the subscription you want to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscription(tROrganization: string, subscriptionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelSubscription(tROrganization, subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a checkout session (setup)
         * @summary Create checkout session setup
         * @param {string} organizationId The id of the organization to create setup checkout session for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSetupCheckoutSession(organizationId: string, options?: any): AxiosPromise<CreateSetupCheckoutSessionResPayload> {
            return localVarFp.createSetupCheckoutSession(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a 303 SeeOther redirect link to the stripe checkout page for the plan and organization
         * @summary Checkout
         * @param {string} planId id of the plan you want to subscribe to
         * @param {string} organizationId id of the organization you want to subscribe to the plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directToPaymentLink(planId: string, organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.directToPaymentLink(planId, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all invoices
         * @summary Get All Invoices
         * @param {string} organizationId The id of the organization to get invoices for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInvoices(organizationId: string, options?: any): AxiosPromise<Array<StripeInvoice>> {
            return localVarFp.getAllInvoices(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all plans
         * @summary Get All Plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPlans(options?: any): AxiosPromise<Array<StripePlan>> {
            return localVarFp.getAllPlans(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a subscription to a new plan
         * @summary Update Subscription Plan
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} subscriptionId id of the subscription you want to update
         * @param {string} planId id of the plan you want to subscribe to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionPlan(tROrganization: string, subscriptionId: string, planId: string, options?: any): AxiosPromise<void> {
            return localVarFp.updateSubscriptionPlan(tROrganization, subscriptionId, planId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StripeApi - object-oriented interface
 * @export
 * @class StripeApi
 * @extends {BaseAPI}
 */
export class StripeApi extends BaseAPI {
    /**
     * Cancel a subscription by its id
     * @summary Cancel Subscription
     * @param {string} tROrganization The organization id to use for the request
     * @param {string} subscriptionId id of the subscription you want to cancel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public cancelSubscription(tROrganization: string, subscriptionId: string, options?: RawAxiosRequestConfig) {
        return StripeApiFp(this.configuration).cancelSubscription(tROrganization, subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a checkout session (setup)
     * @summary Create checkout session setup
     * @param {string} organizationId The id of the organization to create setup checkout session for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public createSetupCheckoutSession(organizationId: string, options?: RawAxiosRequestConfig) {
        return StripeApiFp(this.configuration).createSetupCheckoutSession(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a 303 SeeOther redirect link to the stripe checkout page for the plan and organization
     * @summary Checkout
     * @param {string} planId id of the plan you want to subscribe to
     * @param {string} organizationId id of the organization you want to subscribe to the plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public directToPaymentLink(planId: string, organizationId: string, options?: RawAxiosRequestConfig) {
        return StripeApiFp(this.configuration).directToPaymentLink(planId, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all invoices
     * @summary Get All Invoices
     * @param {string} organizationId The id of the organization to get invoices for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public getAllInvoices(organizationId: string, options?: RawAxiosRequestConfig) {
        return StripeApiFp(this.configuration).getAllInvoices(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all plans
     * @summary Get All Plans
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public getAllPlans(options?: RawAxiosRequestConfig) {
        return StripeApiFp(this.configuration).getAllPlans(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a subscription to a new plan
     * @summary Update Subscription Plan
     * @param {string} tROrganization The organization id to use for the request
     * @param {string} subscriptionId id of the subscription you want to update
     * @param {string} planId id of the plan you want to subscribe to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public updateSubscriptionPlan(tROrganization: string, subscriptionId: string, planId: string, options?: RawAxiosRequestConfig) {
        return StripeApiFp(this.configuration).updateSubscriptionPlan(tROrganization, subscriptionId, planId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TopicApi - axios parameter creator
 * @export
 */
export const TopicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new chat topic from a `topic_id`. The new topic will be attched to the owner_id and act as a coordinator for conversation message history of gen-AI chat sessions. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Clone Topic
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {CloneTopicReqPayload} cloneTopicReqPayload JSON request payload to create chat topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneTopic: async (tRDataset: string, cloneTopicReqPayload: CloneTopicReqPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('cloneTopic', 'tRDataset', tRDataset)
            // verify required parameter 'cloneTopicReqPayload' is not null or undefined
            assertParamExists('cloneTopic', 'cloneTopicReqPayload', cloneTopicReqPayload)
            const localVarPath = `/api/topic/clone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloneTopicReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new chat topic. Topics are attached to a owner_id\'s and act as a coordinator for conversation message history of gen-AI chat sessions. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Create Topic
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {CreateTopicReqPayload} createTopicReqPayload JSON request payload to create chat topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTopic: async (tRDataset: string, createTopicReqPayload: CreateTopicReqPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('createTopic', 'tRDataset', tRDataset)
            // verify required parameter 'createTopicReqPayload' is not null or undefined
            assertParamExists('createTopic', 'createTopicReqPayload', createTopicReqPayload)
            const localVarPath = `/api/topic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTopicReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing chat topic. When a topic is deleted, all associated chat messages are also deleted. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Delete Topic
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} topicId The id of the topic you want to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTopic: async (tRDataset: string, topicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('deleteTopic', 'tRDataset', tRDataset)
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('deleteTopic', 'topicId', topicId)
            const localVarPath = `/api/topic/{topic_id}`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all topics belonging to an arbitary owner_id. This is useful for managing message history and chat sessions. It is common to use a browser fingerprint or your user\'s id as the owner_id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get All Topics for Owner ID
         * @param {string} ownerId The owner_id to get topics of; A common approach is to use a browser fingerprint or your user\&#39;s id
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTopicsForOwnerId: async (ownerId: string, tRDataset: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ownerId' is not null or undefined
            assertParamExists('getAllTopicsForOwnerId', 'ownerId', ownerId)
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getAllTopicsForOwnerId', 'tRDataset', tRDataset)
            const localVarPath = `/api/topic/owner/{owner_id}`
                .replace(`{${"owner_id"}}`, encodeURIComponent(String(ownerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing chat topic. Currently, only the name of the topic can be updated. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Update Topic
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {UpdateTopicReqPayload} updateTopicReqPayload JSON request payload to update a chat topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTopic: async (tRDataset: string, updateTopicReqPayload: UpdateTopicReqPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('updateTopic', 'tRDataset', tRDataset)
            // verify required parameter 'updateTopicReqPayload' is not null or undefined
            assertParamExists('updateTopic', 'updateTopicReqPayload', updateTopicReqPayload)
            const localVarPath = `/api/topic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTopicReqPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TopicApi - functional programming interface
 * @export
 */
export const TopicApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TopicApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new chat topic from a `topic_id`. The new topic will be attched to the owner_id and act as a coordinator for conversation message history of gen-AI chat sessions. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Clone Topic
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {CloneTopicReqPayload} cloneTopicReqPayload JSON request payload to create chat topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneTopic(tRDataset: string, cloneTopicReqPayload: CloneTopicReqPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Topic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneTopic(tRDataset, cloneTopicReqPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicApi.cloneTopic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new chat topic. Topics are attached to a owner_id\'s and act as a coordinator for conversation message history of gen-AI chat sessions. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Create Topic
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {CreateTopicReqPayload} createTopicReqPayload JSON request payload to create chat topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTopic(tRDataset: string, createTopicReqPayload: CreateTopicReqPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Topic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTopic(tRDataset, createTopicReqPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicApi.createTopic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing chat topic. When a topic is deleted, all associated chat messages are also deleted. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Delete Topic
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} topicId The id of the topic you want to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTopic(tRDataset: string, topicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTopic(tRDataset, topicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicApi.deleteTopic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all topics belonging to an arbitary owner_id. This is useful for managing message history and chat sessions. It is common to use a browser fingerprint or your user\'s id as the owner_id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get All Topics for Owner ID
         * @param {string} ownerId The owner_id to get topics of; A common approach is to use a browser fingerprint or your user\&#39;s id
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTopicsForOwnerId(ownerId: string, tRDataset: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Topic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTopicsForOwnerId(ownerId, tRDataset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicApi.getAllTopicsForOwnerId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing chat topic. Currently, only the name of the topic can be updated. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Update Topic
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {UpdateTopicReqPayload} updateTopicReqPayload JSON request payload to update a chat topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTopic(tRDataset: string, updateTopicReqPayload: UpdateTopicReqPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTopic(tRDataset, updateTopicReqPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicApi.updateTopic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TopicApi - factory interface
 * @export
 */
export const TopicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TopicApiFp(configuration)
    return {
        /**
         * Create a new chat topic from a `topic_id`. The new topic will be attched to the owner_id and act as a coordinator for conversation message history of gen-AI chat sessions. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Clone Topic
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {CloneTopicReqPayload} cloneTopicReqPayload JSON request payload to create chat topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneTopic(tRDataset: string, cloneTopicReqPayload: CloneTopicReqPayload, options?: any): AxiosPromise<Topic> {
            return localVarFp.cloneTopic(tRDataset, cloneTopicReqPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new chat topic. Topics are attached to a owner_id\'s and act as a coordinator for conversation message history of gen-AI chat sessions. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Create Topic
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {CreateTopicReqPayload} createTopicReqPayload JSON request payload to create chat topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTopic(tRDataset: string, createTopicReqPayload: CreateTopicReqPayload, options?: any): AxiosPromise<Topic> {
            return localVarFp.createTopic(tRDataset, createTopicReqPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing chat topic. When a topic is deleted, all associated chat messages are also deleted. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Delete Topic
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {string} topicId The id of the topic you want to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTopic(tRDataset: string, topicId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTopic(tRDataset, topicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all topics belonging to an arbitary owner_id. This is useful for managing message history and chat sessions. It is common to use a browser fingerprint or your user\'s id as the owner_id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Get All Topics for Owner ID
         * @param {string} ownerId The owner_id to get topics of; A common approach is to use a browser fingerprint or your user\&#39;s id
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTopicsForOwnerId(ownerId: string, tRDataset: string, options?: any): AxiosPromise<Array<Topic>> {
            return localVarFp.getAllTopicsForOwnerId(ownerId, tRDataset, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing chat topic. Currently, only the name of the topic can be updated. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
         * @summary Update Topic
         * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
         * @param {UpdateTopicReqPayload} updateTopicReqPayload JSON request payload to update a chat topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTopic(tRDataset: string, updateTopicReqPayload: UpdateTopicReqPayload, options?: any): AxiosPromise<void> {
            return localVarFp.updateTopic(tRDataset, updateTopicReqPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TopicApi - object-oriented interface
 * @export
 * @class TopicApi
 * @extends {BaseAPI}
 */
export class TopicApi extends BaseAPI {
    /**
     * Create a new chat topic from a `topic_id`. The new topic will be attched to the owner_id and act as a coordinator for conversation message history of gen-AI chat sessions. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Clone Topic
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {CloneTopicReqPayload} cloneTopicReqPayload JSON request payload to create chat topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public cloneTopic(tRDataset: string, cloneTopicReqPayload: CloneTopicReqPayload, options?: RawAxiosRequestConfig) {
        return TopicApiFp(this.configuration).cloneTopic(tRDataset, cloneTopicReqPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new chat topic. Topics are attached to a owner_id\'s and act as a coordinator for conversation message history of gen-AI chat sessions. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Create Topic
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {CreateTopicReqPayload} createTopicReqPayload JSON request payload to create chat topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public createTopic(tRDataset: string, createTopicReqPayload: CreateTopicReqPayload, options?: RawAxiosRequestConfig) {
        return TopicApiFp(this.configuration).createTopic(tRDataset, createTopicReqPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing chat topic. When a topic is deleted, all associated chat messages are also deleted. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Delete Topic
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {string} topicId The id of the topic you want to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public deleteTopic(tRDataset: string, topicId: string, options?: RawAxiosRequestConfig) {
        return TopicApiFp(this.configuration).deleteTopic(tRDataset, topicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all topics belonging to an arbitary owner_id. This is useful for managing message history and chat sessions. It is common to use a browser fingerprint or your user\'s id as the owner_id. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Get All Topics for Owner ID
     * @param {string} ownerId The owner_id to get topics of; A common approach is to use a browser fingerprint or your user\&#39;s id
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public getAllTopicsForOwnerId(ownerId: string, tRDataset: string, options?: RawAxiosRequestConfig) {
        return TopicApiFp(this.configuration).getAllTopicsForOwnerId(ownerId, tRDataset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing chat topic. Currently, only the name of the topic can be updated. Auth\'ed user or api key must have an admin or owner role for the specified dataset\'s organization.
     * @summary Update Topic
     * @param {string} tRDataset The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
     * @param {UpdateTopicReqPayload} updateTopicReqPayload JSON request payload to update a chat topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public updateTopic(tRDataset: string, updateTopicReqPayload: UpdateTopicReqPayload, options?: RawAxiosRequestConfig) {
        return TopicApiFp(this.configuration).updateTopic(tRDataset, updateTopicReqPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an api key for the auth\'ed user.
         * @summary Delete User Api Key
         * @param {string} apiKeyId The id of the api key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserApiKey: async (apiKeyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKeyId' is not null or undefined
            assertParamExists('deleteUserApiKey', 'apiKeyId', apiKeyId)
            const localVarPath = `/api/user/api_key/{api_key_id}`
                .replace(`{${"api_key_id"}}`, encodeURIComponent(String(apiKeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new api key for the auth\'ed user. Successful response will contain the newly created api key. If a write role is assigned the api key will have permission level of the auth\'ed user who calls this endpoint.
         * @summary Set User Api Key
         * @param {SetUserApiKeyRequest} setUserApiKeyRequest JSON request payload to create a new user api key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserApiKey: async (setUserApiKeyRequest: SetUserApiKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setUserApiKeyRequest' is not null or undefined
            assertParamExists('setUserApiKey', 'setUserApiKeyRequest', setUserApiKeyRequest)
            const localVarPath = `/api/user/api_key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setUserApiKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user\'s information. If the user_id is not provided, the auth\'ed user will be updated. If the user_id is provided, the role of the auth\'ed user or api key must be an admin (1) or owner (2) of the organization.
         * @summary Update User
         * @param {UpdateUserOrgRoleData} updateUserOrgRoleData JSON request payload to update user information for the auth\&#39;ed user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (updateUserOrgRoleData: UpdateUserOrgRoleData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserOrgRoleData' is not null or undefined
            assertParamExists('updateUser', 'updateUserOrgRoleData', updateUserOrgRoleData)
            const localVarPath = `/api/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserOrgRoleData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete an api key for the auth\'ed user.
         * @summary Delete User Api Key
         * @param {string} apiKeyId The id of the api key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserApiKey(apiKeyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserApiKey(apiKeyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.deleteUserApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new api key for the auth\'ed user. Successful response will contain the newly created api key. If a write role is assigned the api key will have permission level of the auth\'ed user who calls this endpoint.
         * @summary Set User Api Key
         * @param {SetUserApiKeyRequest} setUserApiKeyRequest JSON request payload to create a new user api key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserApiKey(setUserApiKeyRequest: SetUserApiKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetUserApiKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserApiKey(setUserApiKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.setUserApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a user\'s information. If the user_id is not provided, the auth\'ed user will be updated. If the user_id is provided, the role of the auth\'ed user or api key must be an admin (1) or owner (2) of the organization.
         * @summary Update User
         * @param {UpdateUserOrgRoleData} updateUserOrgRoleData JSON request payload to update user information for the auth\&#39;ed user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(updateUserOrgRoleData: UpdateUserOrgRoleData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(updateUserOrgRoleData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Delete an api key for the auth\'ed user.
         * @summary Delete User Api Key
         * @param {string} apiKeyId The id of the api key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserApiKey(apiKeyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserApiKey(apiKeyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new api key for the auth\'ed user. Successful response will contain the newly created api key. If a write role is assigned the api key will have permission level of the auth\'ed user who calls this endpoint.
         * @summary Set User Api Key
         * @param {SetUserApiKeyRequest} setUserApiKeyRequest JSON request payload to create a new user api key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserApiKey(setUserApiKeyRequest: SetUserApiKeyRequest, options?: any): AxiosPromise<SetUserApiKeyResponse> {
            return localVarFp.setUserApiKey(setUserApiKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user\'s information. If the user_id is not provided, the auth\'ed user will be updated. If the user_id is provided, the role of the auth\'ed user or api key must be an admin (1) or owner (2) of the organization.
         * @summary Update User
         * @param {UpdateUserOrgRoleData} updateUserOrgRoleData JSON request payload to update user information for the auth\&#39;ed user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(updateUserOrgRoleData: UpdateUserOrgRoleData, options?: any): AxiosPromise<void> {
            return localVarFp.updateUser(updateUserOrgRoleData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Delete an api key for the auth\'ed user.
     * @summary Delete User Api Key
     * @param {string} apiKeyId The id of the api key to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUserApiKey(apiKeyId: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteUserApiKey(apiKeyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new api key for the auth\'ed user. Successful response will contain the newly created api key. If a write role is assigned the api key will have permission level of the auth\'ed user who calls this endpoint.
     * @summary Set User Api Key
     * @param {SetUserApiKeyRequest} setUserApiKeyRequest JSON request payload to create a new user api key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public setUserApiKey(setUserApiKeyRequest: SetUserApiKeyRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).setUserApiKey(setUserApiKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user\'s information. If the user_id is not provided, the auth\'ed user will be updated. If the user_id is provided, the role of the auth\'ed user or api key must be an admin (1) or owner (2) of the organization.
     * @summary Update User
     * @param {UpdateUserOrgRoleData} updateUserOrgRoleData JSON request payload to update user information for the auth\&#39;ed user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(updateUserOrgRoleData: UpdateUserOrgRoleData, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUser(updateUserOrgRoleData, options).then((request) => request(this.axios, this.basePath));
    }
}



