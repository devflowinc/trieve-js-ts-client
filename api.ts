/* tslint:disable */
/* eslint-disable */
/**
 * Trieve API
 * Trieve OpenAPI Specification. This document describes all of the operations available through the Trieve API.
 *
 * The version of the OpenAPI document: 0.6.9
 * Contact: developers@trieve.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddChunkToGroupData
 */
export interface AddChunkToGroupData {
    /**
     * Id of the chunk to make a member of the group.
     * @type {string}
     * @memberof AddChunkToGroupData
     */
    'chunk_id'?: string | null;
    /**
     * Tracking Id of the chunk to make a member of the group.
     * @type {string}
     * @memberof AddChunkToGroupData
     */
    'tracking_id'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiKeyDTO
 */
export interface ApiKeyDTO {
    /**
     * 
     * @type {string}
     * @memberof ApiKeyDTO
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyDTO
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ApiKeyDTO
     */
    'role': number;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyDTO
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyDTO
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface AuthQuery
 */
export interface AuthQuery {
    /**
     * Code sent via email as a result of successful call to send_invitation
     * @type {string}
     * @memberof AuthQuery
     */
    'inv_code'?: string | null;
    /**
     * ID of organization to authenticate into
     * @type {string}
     * @memberof AuthQuery
     */
    'organization_id'?: string | null;
    /**
     * URL to redirect to after successful login
     * @type {string}
     * @memberof AuthQuery
     */
    'redirect_uri'?: string | null;
}
/**
 * 
 * @export
 * @interface BatchQueuedChunkResponse
 */
export interface BatchQueuedChunkResponse {
    /**
     * 
     * @type {Array<ChunkMetadata>}
     * @memberof BatchQueuedChunkResponse
     */
    'chunk_metadata': Array<ChunkMetadata>;
    /**
     * The current position the last access item is in the queue
     * @type {number}
     * @memberof BatchQueuedChunkResponse
     */
    'pos_in_queue': number;
}
/**
 * 
 * @export
 * @interface BookmarkData
 */
export interface BookmarkData {
    /**
     * 
     * @type {Array<ChunkMetadata>}
     * @memberof BookmarkData
     */
    'chunks': Array<ChunkMetadata>;
    /**
     * 
     * @type {ChunkGroup}
     * @memberof BookmarkData
     */
    'group': ChunkGroup;
    /**
     * 
     * @type {number}
     * @memberof BookmarkData
     */
    'total_pages': number;
}
/**
 * 
 * @export
 * @interface BookmarkGroupResult
 */
export interface BookmarkGroupResult {
    /**
     * 
     * @type {string}
     * @memberof BookmarkGroupResult
     */
    'chunk_uuid': string;
    /**
     * 
     * @type {Array<SlimGroup>}
     * @memberof BookmarkGroupResult
     */
    'slim_groups': Array<SlimGroup>;
}
/**
 * 
 * @export
 * @interface ChatMessageProxy
 */
export interface ChatMessageProxy {
    /**
     * 
     * @type {string}
     * @memberof ChatMessageProxy
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof ChatMessageProxy
     */
    'role': string;
}
/**
 * 
 * @export
 * @interface ChunkData
 */
export interface ChunkData {
    /**
     * HTML content of the chunk. This can also be plaintext. The innerText of the HTML will be used to create the embedding vector. The point of using HTML is for convienience, as some users have applications where users submit HTML content.
     * @type {string}
     * @memberof ChunkData
     */
    'chunk_html'?: string | null;
    /**
     * Chunk_vector is a vector of floats which can be used instead of generating a new embedding. This is useful for when you are using a pre-embedded dataset. If this is not provided, the innerText of the chunk_html will be used to create the embedding.
     * @type {Array<number>}
     * @memberof ChunkData
     */
    'chunk_vector'?: Array<number> | null;
    /**
     * Convert HTML to raw text before processing to avoid adding noise to the vector embeddings. By default this is true. If you are using HTML content that you want to be included in the vector embeddings, set this to false.
     * @type {boolean}
     * @memberof ChunkData
     */
    'convert_html_to_text'?: boolean | null;
    /**
     * File_uuid is the uuid of the file that the chunk is associated with. This is used to associate chunks with files. This is useful for when you want to delete a file and all of its associated chunks.
     * @type {string}
     * @memberof ChunkData
     */
    'file_id'?: string | null;
    /**
     * Group ids are the ids of the groups that the chunk should be placed into. This is useful for when you want to create a chunk and add it to a group or multiple groups in one request. Necessary because this route queues the chunk for ingestion and the chunk may not exist yet immediately after response.
     * @type {Array<string>}
     * @memberof ChunkData
     */
    'group_ids'?: Array<string> | null;
    /**
     * Group tracking_ids are the tracking_ids of the groups that the chunk should be placed into. This is useful for when you want to create a chunk and add it to a group or multiple groups in one request. Necessary because this route queues the chunk for ingestion and the chunk may not exist yet immediately after response.
     * @type {Array<string>}
     * @memberof ChunkData
     */
    'group_tracking_ids'?: Array<string> | null;
    /**
     * Link to the chunk. This can also be any string. Frequently, this is a link to the source of the chunk. The link value will not affect the embedding creation.
     * @type {string}
     * @memberof ChunkData
     */
    'link'?: string | null;
    /**
     * Metadata is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata.
     * @type {any}
     * @memberof ChunkData
     */
    'metadata'?: any | null;
    /**
     * Split avg is a boolean which tells the server to split the text in the chunk_html into smaller chunks and average their resulting vectors. This is useful for when you want to create a chunk from a large piece of text and want to split it into smaller chunks to create a more fuzzy average dense vector. The sparse vector will be generated normally with no averaging. By default this is false.
     * @type {boolean}
     * @memberof ChunkData
     */
    'split_avg'?: boolean | null;
    /**
     * Tag set is a list of tags. This can be used to filter chunks by tag. Unlike with metadata filtering, HNSW indices will exist for each tag such that there is not a performance hit for filtering on them.
     * @type {Array<string>}
     * @memberof ChunkData
     */
    'tag_set'?: Array<string> | null;
    /**
     * Time_stamp should be an ISO 8601 combined date and time without timezone. It is used for time window filtering and recency-biasing search results.
     * @type {string}
     * @memberof ChunkData
     */
    'time_stamp'?: string | null;
    /**
     * Tracking_id is a string which can be used to identify a chunk. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk.
     * @type {string}
     * @memberof ChunkData
     */
    'tracking_id'?: string | null;
    /**
     * Upsert when a chunk with the same tracking_id exists. By default this is false, and the request will fail if a chunk with the same tracking_id exists. If this is true, the chunk will be updated if a chunk with the same tracking_id exists.
     * @type {boolean}
     * @memberof ChunkData
     */
    'upsert_by_tracking_id'?: boolean | null;
    /**
     * Weight is a float which can be used to bias search results. This is useful for when you want to bias search results for a chunk. The magnitude only matters relative to other chunks in the chunk\'s dataset dataset.
     * @type {number}
     * @memberof ChunkData
     */
    'weight'?: number | null;
}
/**
 * 
 * @export
 * @interface ChunkFilter
 */
export interface ChunkFilter {
    /**
     * All of these field conditions have to match for the chunk to be included in the result set.
     * @type {Array<FieldCondition>}
     * @memberof ChunkFilter
     */
    'must'?: Array<FieldCondition> | null;
    /**
     * None of these field conditions can match for the chunk to be included in the result set.
     * @type {Array<FieldCondition>}
     * @memberof ChunkFilter
     */
    'must_not'?: Array<FieldCondition> | null;
    /**
     * Only one of these field conditions has to match for the chunk to be included in the result set.
     * @type {Array<FieldCondition>}
     * @memberof ChunkFilter
     */
    'should'?: Array<FieldCondition> | null;
}
/**
 * 
 * @export
 * @interface ChunkGroup
 */
export interface ChunkGroup {
    /**
     * 
     * @type {string}
     * @memberof ChunkGroup
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroup
     */
    'dataset_id': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroup
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroup
     */
    'id': string;
    /**
     * 
     * @type {any}
     * @memberof ChunkGroup
     */
    'metadata'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroup
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroup
     */
    'tag_set'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroup
     */
    'tracking_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroup
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface ChunkGroupAndFile
 */
export interface ChunkGroupAndFile {
    /**
     * 
     * @type {string}
     * @memberof ChunkGroupAndFile
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroupAndFile
     */
    'dataset_id': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroupAndFile
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroupAndFile
     */
    'file_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroupAndFile
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroupAndFile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroupAndFile
     */
    'tracking_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkGroupAndFile
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface ChunkMetadata
 */
export interface ChunkMetadata {
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadata
     */
    'chunk_html'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadata
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadata
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadata
     */
    'dataset_id': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadata
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadata
     */
    'link'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof ChunkMetadata
     */
    'metadata'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadata
     */
    'qdrant_point_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadata
     */
    'tag_set'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadata
     */
    'time_stamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadata
     */
    'tracking_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadata
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof ChunkMetadata
     */
    'weight': number;
}
/**
 * 
 * @export
 * @interface ChunkMetadataWithScore
 */
export interface ChunkMetadataWithScore {
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataWithScore
     */
    'chunk_html'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataWithScore
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataWithScore
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataWithScore
     */
    'dataset_id': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataWithScore
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataWithScore
     */
    'link'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof ChunkMetadataWithScore
     */
    'metadata'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataWithScore
     */
    'qdrant_point_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ChunkMetadataWithScore
     */
    'score': number;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataWithScore
     */
    'tag_set'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataWithScore
     */
    'time_stamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataWithScore
     */
    'tracking_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChunkMetadataWithScore
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof ChunkMetadataWithScore
     */
    'weight': number;
}
/**
 * 
 * @export
 * @interface ClientDatasetConfiguration
 */
export interface ClientDatasetConfiguration {
    /**
     * 
     * @type {boolean}
     * @memberof ClientDatasetConfiguration
     */
    'CREATE_CHUNK_FEATURE'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ClientDatasetConfiguration
     */
    'DATE_RANGE_VALUE'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ClientDatasetConfiguration
     */
    'DOCUMENT_UPLOAD_FEATURE'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ClientDatasetConfiguration
     */
    'FILE_NAME_KEY': string;
    /**
     * 
     * @type {any}
     * @memberof ClientDatasetConfiguration
     */
    'FILTER_ITEMS'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof ClientDatasetConfiguration
     */
    'FRONTMATTER_VALS'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ClientDatasetConfiguration
     */
    'IMAGE_RANGE_END_KEY'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ClientDatasetConfiguration
     */
    'IMAGE_RANGE_START_KEY'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ClientDatasetConfiguration
     */
    'LINES_BEFORE_SHOW_MORE'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ClientDatasetConfiguration
     */
    'SEARCH_QUERIES'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ClientDatasetConfiguration
     */
    'SUGGESTED_QUERIES'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateBatchChunkData
 */
export interface CreateBatchChunkData extends Array<ChunkData> {
}
/**
 * @type CreateChunkData
 * @export
 */
export type CreateChunkData = ChunkData | CreateBatchChunkData;

/**
 * 
 * @export
 * @interface CreateChunkGroupData
 */
export interface CreateChunkGroupData {
    /**
     * Description to assign to the chunk_group. Convenience field for you to avoid having to remember what the group is for.
     * @type {string}
     * @memberof CreateChunkGroupData
     */
    'description'?: string | null;
    /**
     * Optional metadata to assign to the chunk_group. This is a JSON object that can store any additional information you want to associate with the chunks inside of the chunk_group.
     * @type {any}
     * @memberof CreateChunkGroupData
     */
    'metadata'?: any | null;
    /**
     * Name to assign to the chunk_group. Does not need to be unique.
     * @type {string}
     * @memberof CreateChunkGroupData
     */
    'name': string;
    /**
     * Optional tags to assign to the chunk_group. This is a list of strings that can be used to categorize the chunks inside the chunk_group.
     * @type {Array<string>}
     * @memberof CreateChunkGroupData
     */
    'tag_set'?: Array<string> | null;
    /**
     * Optional tracking id to assign to the chunk_group. This is a unique identifier for the chunk_group.
     * @type {string}
     * @memberof CreateChunkGroupData
     */
    'tracking_id'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateDatasetRequest
 */
export interface CreateDatasetRequest {
    /**
     * Client configuration for the dataset, can be arbitrary JSON. We recommend setting to `{}` to start. See docs.trieve.ai for more information or adjust with the admin dashboard.
     * @type {any}
     * @memberof CreateDatasetRequest
     */
    'client_configuration': any;
    /**
     * Name of the dataset. Must be unique within the organization.
     * @type {string}
     * @memberof CreateDatasetRequest
     */
    'dataset_name': string;
    /**
     * Organization ID that the dataset will belong to.
     * @type {string}
     * @memberof CreateDatasetRequest
     */
    'organization_id': string;
    /**
     * Server configuration for the dataset, can be arbitrary JSON. We recommend setting to `{}` to start. See docs.trieve.ai for more information or adjust with the admin dashboard.
     * @type {any}
     * @memberof CreateDatasetRequest
     */
    'server_configuration': any;
    /**
     * Optional tracking ID for the dataset. Can be used to track the dataset in external systems.
     * @type {string}
     * @memberof CreateDatasetRequest
     */
    'tracking_id'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateMessageData
 */
export interface CreateMessageData {
    /**
     * Whether or not to highlight the citations in the response. If this is set to true or not included, the citations will be highlighted. If this is set to false, the citations will not be highlighted. Default is true.
     * @type {boolean}
     * @memberof CreateMessageData
     */
    'highlight_citations'?: boolean | null;
    /**
     * The delimiters to use for highlighting the citations. If this is not included, the default delimiters will be used. Default is `[\".\", \"!\", \"?\", \"\\n\", \"\\t\", \",\"]`.
     * @type {Array<string>}
     * @memberof CreateMessageData
     */
    'highlight_delimiters'?: Array<string> | null;
    /**
     * The model to use for the assistant\'s messages. This can be any model from the openrouter model list. If no model is provided, gpt-3.5-turbo will be used.
     * @type {string}
     * @memberof CreateMessageData
     */
    'model'?: string | null;
    /**
     * The content of the user message to attach to the topic and then generate an assistant message in response to.
     * @type {string}
     * @memberof CreateMessageData
     */
    'new_message_content': string;
    /**
     * Whether or not to stream the response. If this is set to true or not included, the response will be a stream. If this is set to false, the response will be a normal JSON response. Default is true.
     * @type {boolean}
     * @memberof CreateMessageData
     */
    'stream_response'?: boolean | null;
    /**
     * The ID of the topic to attach the message to.
     * @type {string}
     * @memberof CreateMessageData
     */
    'topic_id': string;
}
/**
 * 
 * @export
 * @interface CreateOrganizationData
 */
export interface CreateOrganizationData {
    /**
     * The arbitrary name which will be used to identify the organization. This name must be unique.
     * @type {string}
     * @memberof CreateOrganizationData
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateTopicData
 */
export interface CreateTopicData {
    /**
     * The first message which will belong to the topic. The topic name is generated based on this message similar to how it works in the OpenAI chat UX if a name is not explicitly provided on the name request body key.
     * @type {string}
     * @memberof CreateTopicData
     */
    'first_user_message'?: string | null;
    /**
     * The model to use for the assistant\'s messages. This can be any model from the openrouter model list. If no model is provided, the gpt-3.5-turbo will be used.
     * @type {string}
     * @memberof CreateTopicData
     */
    'model'?: string | null;
    /**
     * The name of the topic. If this is not provided, the topic name is generated from the first_user_message.
     * @type {string}
     * @memberof CreateTopicData
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface Dataset
 */
export interface Dataset {
    /**
     * 
     * @type {any}
     * @memberof Dataset
     */
    'client_configuration': any;
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    'organization_id': string;
    /**
     * 
     * @type {any}
     * @memberof Dataset
     */
    'server_configuration': any;
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    'tracking_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface DatasetAndUsage
 */
export interface DatasetAndUsage {
    /**
     * 
     * @type {DatasetDTO}
     * @memberof DatasetAndUsage
     */
    'dataset': DatasetDTO;
    /**
     * 
     * @type {DatasetUsageCount}
     * @memberof DatasetAndUsage
     */
    'dataset_usage': DatasetUsageCount;
}
/**
 * 
 * @export
 * @interface DatasetDTO
 */
export interface DatasetDTO {
    /**
     * 
     * @type {any}
     * @memberof DatasetDTO
     */
    'client_configuration': any;
    /**
     * 
     * @type {string}
     * @memberof DatasetDTO
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DatasetDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DatasetDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DatasetDTO
     */
    'organization_id': string;
    /**
     * 
     * @type {string}
     * @memberof DatasetDTO
     */
    'tracking_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DatasetDTO
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface DatasetUsageCount
 */
export interface DatasetUsageCount {
    /**
     * 
     * @type {number}
     * @memberof DatasetUsageCount
     */
    'chunk_count': number;
    /**
     * 
     * @type {string}
     * @memberof DatasetUsageCount
     */
    'dataset_id': string;
    /**
     * 
     * @type {string}
     * @memberof DatasetUsageCount
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface DeleteTopicData
 */
export interface DeleteTopicData {
    /**
     * The id of the topic to target.
     * @type {string}
     * @memberof DeleteTopicData
     */
    'topic_id': string;
}
/**
 * 
 * @export
 * @interface DeleteUserApiKeyRequest
 */
export interface DeleteUserApiKeyRequest {
    /**
     * The id of the api key to delete.
     * @type {string}
     * @memberof DeleteUserApiKeyRequest
     */
    'api_key_id': string;
}
/**
 * 
 * @export
 * @interface EditMessageData
 */
export interface EditMessageData {
    /**
     * Whether or not to highlight the citations in the response. If this is set to true or not included, the citations will be highlighted. If this is set to false, the citations will not be highlighted. Default is true.
     * @type {boolean}
     * @memberof EditMessageData
     */
    'highlight_citations'?: boolean | null;
    /**
     * The delimiters to use for highlighting the citations. If this is not included, the default delimiters will be used. Default is `[\".\", \"!\", \"?\", \"\\n\", \"\\t\", \",\"]`.
     * @type {Array<string>}
     * @memberof EditMessageData
     */
    'highlight_delimiters'?: Array<string> | null;
    /**
     * The sort order of the message to edit.
     * @type {number}
     * @memberof EditMessageData
     */
    'message_sort_order': number;
    /**
     * The model to use for the assistant generative inferences. This can be any model from the openrouter model list. If no model is provided, the gpt-3.5-turbo will be used.~
     * @type {string}
     * @memberof EditMessageData
     */
    'model'?: string | null;
    /**
     * The new content of the message to replace the old content with.
     * @type {string}
     * @memberof EditMessageData
     */
    'new_message_content': string;
    /**
     * Whether or not to stream the response. If this is set to true or not included, the response will be a stream. If this is set to false, the response will be a normal JSON response. Default is true.
     * @type {boolean}
     * @memberof EditMessageData
     */
    'stream_response'?: boolean | null;
    /**
     * The id of the topic to edit the message at the given sort order for.
     * @type {string}
     * @memberof EditMessageData
     */
    'topic_id': string;
}
/**
 * 
 * @export
 * @interface ErrorResponseBody
 */
export interface ErrorResponseBody {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseBody
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'dataset_id': string;
    /**
     * 
     * @type {any}
     * @memberof Event
     */
    'event_data': any;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'event_type': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface EventReturn
 */
export interface EventReturn {
    /**
     * 
     * @type {Array<Event>}
     * @memberof EventReturn
     */
    'events': Array<Event>;
    /**
     * 
     * @type {number}
     * @memberof EventReturn
     */
    'page_count': number;
}
/**
 * 
 * @export
 * @interface FieldCondition
 */
export interface FieldCondition {
    /**
     * Field is the name of the field to filter on. The field value will be used to check for an exact substring match on the metadata values for each existing chunk. This is useful for when you want to filter chunks by arbitrary metadata. To access fields inside of the metadata that you provide with the card, prefix the field name with `metadata.`.
     * @type {string}
     * @memberof FieldCondition
     */
    'field': string;
    /**
     * Match is the value to match on the field. The match value will be used to check for an exact substring match on the metadata values for each existing chunk. This is useful for when you want to filter chunks by arbitrary metadata.
     * @type {Array<MatchCondition>}
     * @memberof FieldCondition
     */
    'match'?: Array<MatchCondition> | null;
    /**
     * 
     * @type {Range}
     * @memberof FieldCondition
     */
    'range'?: Range | null;
}
/**
 * 
 * @export
 * @interface FileDTO
 */
export interface FileDTO {
    /**
     * 
     * @type {string}
     * @memberof FileDTO
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof FileDTO
     */
    'file_name': string;
    /**
     * 
     * @type {string}
     * @memberof FileDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FileDTO
     */
    'link'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof FileDTO
     */
    'metadata'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof FileDTO
     */
    's3_url': string;
    /**
     * 
     * @type {number}
     * @memberof FileDTO
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof FileDTO
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface GenerateChunksRequest
 */
export interface GenerateChunksRequest {
    /**
     * The ids of the chunks to be retrieved and injected into the context window for RAG.
     * @type {Array<string>}
     * @memberof GenerateChunksRequest
     */
    'chunk_ids': Array<string>;
    /**
     * The model to use for the chat. This can be any model from the openrouter model list. If no model is provided, gpt-3.5-turbo will be used.
     * @type {string}
     * @memberof GenerateChunksRequest
     */
    'model'?: string | null;
    /**
     * The previous messages to be placed into the chat history. The last message in this array will be the prompt for the model to inference on. The length of this array must be at least 1.
     * @type {Array<ChatMessageProxy>}
     * @memberof GenerateChunksRequest
     */
    'prev_messages': Array<ChatMessageProxy>;
    /**
     * Prompt for the last message in the prev_messages array. This will be used to generate the next message in the chat. The default is \'Respond to the instruction and include the doc numbers that you used in square brackets at the end of the sentences that you used the docs for:\'. You can also specify an empty string to leave the final message alone such that your user\'s final message can be used as the prompt. See docs.trieve.ai or contact us for more information.
     * @type {string}
     * @memberof GenerateChunksRequest
     */
    'prompt'?: string | null;
    /**
     * Whether or not to stream the response. If this is set to true or not included, the response will be a stream. If this is set to false, the response will be a normal JSON response. Default is true.
     * @type {boolean}
     * @memberof GenerateChunksRequest
     */
    'stream_response'?: boolean | null;
}
/**
 * 
 * @export
 * @interface GetEventsData
 */
export interface GetEventsData {
    /**
     * The types of events to get. Any combination of file_uploaded, chunk_uploaded, chunk_action_failed, or chunk_updated. Leave undefined to get all events.
     * @type {Array<string>}
     * @memberof GetEventsData
     */
    'event_types'?: Array<string> | null;
    /**
     * The page number to get. Default is 1.
     * @type {number}
     * @memberof GetEventsData
     */
    'page'?: number | null;
    /**
     * The number of items per page. Default is 10.
     * @type {number}
     * @memberof GetEventsData
     */
    'page_size'?: number | null;
}
/**
 * 
 * @export
 * @interface GetGroupsForChunksData
 */
export interface GetGroupsForChunksData {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetGroupsForChunksData
     */
    'chunk_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface GroupData
 */
export interface GroupData {
    /**
     * 
     * @type {Array<ChunkGroupAndFile>}
     * @memberof GroupData
     */
    'groups': Array<ChunkGroupAndFile>;
    /**
     * 
     * @type {number}
     * @memberof GroupData
     */
    'total_pages': number;
}
/**
 * 
 * @export
 * @interface GroupScoreChunk
 */
export interface GroupScoreChunk {
    /**
     * 
     * @type {string}
     * @memberof GroupScoreChunk
     */
    'group_id': string;
    /**
     * 
     * @type {string}
     * @memberof GroupScoreChunk
     */
    'group_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GroupScoreChunk
     */
    'group_tracking_id'?: string | null;
    /**
     * 
     * @type {Array<ScoreChunkDTO>}
     * @memberof GroupScoreChunk
     */
    'metadata': Array<ScoreChunkDTO>;
}
/**
 * 
 * @export
 * @interface GroupScoreSlimChunks
 */
export interface GroupScoreSlimChunks {
    /**
     * 
     * @type {string}
     * @memberof GroupScoreSlimChunks
     */
    'group_id': string;
    /**
     * 
     * @type {Array<ScoreSlimChunks>}
     * @memberof GroupScoreSlimChunks
     */
    'metadata': Array<ScoreSlimChunks>;
}
/**
 * 
 * @export
 * @interface InvitationData
 */
export interface InvitationData {
    /**
     * The url of the app that the user will be directed to in order to set their password. Usually admin.trieve.ai, but may differ for local dev or self-hosted setups.
     * @type {string}
     * @memberof InvitationData
     */
    'app_url': string;
    /**
     * The email of the user to invite. Must be a valid email as they will be sent an email to register.
     * @type {string}
     * @memberof InvitationData
     */
    'email': string;
    /**
     * The id of the organization to invite the user to.
     * @type {string}
     * @memberof InvitationData
     */
    'organization_id': string;
    /**
     * The url that the user will be redirected to after setting their password.
     * @type {string}
     * @memberof InvitationData
     */
    'redirect_uri': string;
    /**
     * The role the user will have in the organization. 0 = User, 1 = Admin, 2 = Owner.
     * @type {number}
     * @memberof InvitationData
     */
    'user_role': number;
}
/**
 * @type MatchCondition
 * @export
 */
export type MatchCondition = number | string;

/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {number}
     * @memberof Message
     */
    'completion_tokens'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'dataset_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof Message
     */
    'deleted': boolean;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof Message
     */
    'prompt_tokens'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'role': string;
    /**
     * 
     * @type {number}
     * @memberof Message
     */
    'sort_order': number;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'topic_id': string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'dataset_id': string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'file_name': string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'link'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof ModelFile
     */
    'metadata'?: any | null;
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'tag_set'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'time_stamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof Organization
     */
    'registerable'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface OrganizationUsageCount
 */
export interface OrganizationUsageCount {
    /**
     * 
     * @type {number}
     * @memberof OrganizationUsageCount
     */
    'dataset_count': number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationUsageCount
     */
    'file_storage': number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUsageCount
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof OrganizationUsageCount
     */
    'message_count': number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUsageCount
     */
    'org_id': string;
    /**
     * 
     * @type {number}
     * @memberof OrganizationUsageCount
     */
    'user_count': number;
}
/**
 * 
 * @export
 * @interface Range
 */
export interface Range {
    /**
     * 
     * @type {RangeCondition}
     * @memberof Range
     */
    'gt'?: RangeCondition | null;
    /**
     * 
     * @type {RangeCondition}
     * @memberof Range
     */
    'gte'?: RangeCondition | null;
    /**
     * 
     * @type {RangeCondition}
     * @memberof Range
     */
    'lt'?: RangeCondition | null;
    /**
     * 
     * @type {RangeCondition}
     * @memberof Range
     */
    'lte'?: RangeCondition | null;
}
/**
 * @type RangeCondition
 * @export
 */
export type RangeCondition = number | string;

/**
 * 
 * @export
 * @interface RecommendChunksRequest
 */
export interface RecommendChunksRequest {
    /**
     * 
     * @type {ChunkFilter}
     * @memberof RecommendChunksRequest
     */
    'filters'?: ChunkFilter | null;
    /**
     * The number of chunks to return. This is the number of chunks which will be returned in the response. The default is 10.
     * @type {number}
     * @memberof RecommendChunksRequest
     */
    'limit'?: number | null;
    /**
     * The ids of the chunks to be used as negative examples for the recommendation. The chunks in this array will be used to filter out similar chunks.
     * @type {Array<string>}
     * @memberof RecommendChunksRequest
     */
    'negative_chunk_ids'?: Array<string> | null;
    /**
     * The tracking_ids of the chunks to be used as negative examples for the recommendation. The chunks in this array will be used to filter out similar chunks.
     * @type {Array<string>}
     * @memberof RecommendChunksRequest
     */
    'negative_tracking_ids'?: Array<string> | null;
    /**
     * The ids of the chunks to be used as positive examples for the recommendation. The chunks in this array will be used to find similar chunks.
     * @type {Array<string>}
     * @memberof RecommendChunksRequest
     */
    'positive_chunk_ids'?: Array<string> | null;
    /**
     * The tracking_ids of the chunks to be used as positive examples for the recommendation. The chunks in this array will be used to find similar chunks.
     * @type {Array<string>}
     * @memberof RecommendChunksRequest
     */
    'positive_tracking_ids'?: Array<string> | null;
    /**
     * The type of recommendation to make. This lets you choose whether to recommend based off of `semantic` or `fulltext` similarity. The default is `semantic`.
     * @type {string}
     * @memberof RecommendChunksRequest
     */
    'recommend_type'?: string | null;
    /**
     * Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement. Default is false.
     * @type {boolean}
     * @memberof RecommendChunksRequest
     */
    'slim_chunks'?: boolean | null;
    /**
     * Strategy to use for recommendations, either \"average_vector\" or \"best_score\". The default is \"average_vector\". The \"average_vector\" strategy will construct a single average vector from the positive and negative samples then use it to perform a pseudo-search. The \"best_score\" strategy is more advanced and navigates the HNSW with a heuristic of picking edges where the point is closer to the positive samples than it is the negatives.
     * @type {string}
     * @memberof RecommendChunksRequest
     */
    'strategy'?: string | null;
}
/**
 * 
 * @export
 * @interface RecommendGroupChunksRequest
 */
export interface RecommendGroupChunksRequest {
    /**
     * 
     * @type {ChunkFilter}
     * @memberof RecommendGroupChunksRequest
     */
    'filters'?: ChunkFilter | null;
    /**
     * The number of chunks to fetch for each group. This is the number of chunks which will be returned in the response for each group. The default is 3. If this is set to a large number, we recommend setting slim_chunks to true to avoid returning the content and chunk_html of the chunks so as to reduce latency due to content download and serialization.
     * @type {number}
     * @memberof RecommendGroupChunksRequest
     */
    'group_size'?: number | null;
    /**
     * The number of groups to return. This is the number of groups which will be returned in the response. The default is 10.
     * @type {number}
     * @memberof RecommendGroupChunksRequest
     */
    'limit'?: number | null;
    /**
     * The ids of the groups to be used as negative examples for the recommendation. The groups in this array will be used to filter out similar groups.
     * @type {Array<string>}
     * @memberof RecommendGroupChunksRequest
     */
    'negative_group_ids'?: Array<string> | null;
    /**
     * The ids of the groups to be used as negative examples for the recommendation. The groups in this array will be used to filter out similar groups.
     * @type {Array<string>}
     * @memberof RecommendGroupChunksRequest
     */
    'negative_group_tracking_ids'?: Array<string> | null;
    /**
     * The ids of the groups to be used as positive examples for the recommendation. The groups in this array will be used to find similar groups.
     * @type {Array<string>}
     * @memberof RecommendGroupChunksRequest
     */
    'positive_group_ids'?: Array<string> | null;
    /**
     * The ids of the groups to be used as positive examples for the recommendation. The groups in this array will be used to find similar groups.
     * @type {Array<string>}
     * @memberof RecommendGroupChunksRequest
     */
    'positive_group_tracking_ids'?: Array<string> | null;
    /**
     * The type of recommendation to make. This lets you choose whether to recommend based off of `semantic` or `fulltext` similarity. The default is `semantic`.
     * @type {string}
     * @memberof RecommendGroupChunksRequest
     */
    'recommend_type'?: string | null;
    /**
     * Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement. Default is false.
     * @type {boolean}
     * @memberof RecommendGroupChunksRequest
     */
    'slim_chunks'?: boolean | null;
    /**
     * Strategy to use for recommendations, either \"average_vector\" or \"best_score\". The default is \"average_vector\". The \"average_vector\" strategy will construct a single average vector from the positive and negative samples then use it to perform a pseudo-search. The \"best_score\" strategy is more advanced and navigates the HNSW with a heuristic of picking edges where the point is closer to the positive samples than it is the negatives.
     * @type {string}
     * @memberof RecommendGroupChunksRequest
     */
    'strategy'?: string | null;
}
/**
 * 
 * @export
 * @interface RegenerateMessageData
 */
export interface RegenerateMessageData {
    /**
     * Whether or not to highlight the citations in the response. If this is set to true or not included, the citations will be highlighted. If this is set to false, the citations will not be highlighted. Default is true.
     * @type {boolean}
     * @memberof RegenerateMessageData
     */
    'highlight_citations'?: boolean | null;
    /**
     * The delimiters to use for highlighting the citations. If this is not included, the default delimiters will be used. Default is `[\".\", \"!\", \"?\", \"\\n\", \"\\t\", \",\"]`.
     * @type {Array<string>}
     * @memberof RegenerateMessageData
     */
    'highlight_delimiters'?: Array<string> | null;
    /**
     * The model to use for the assistant generative inferences. This can be any model from the openrouter model list. If no model is provided, the gpt-3.5-turbo will be used.~
     * @type {string}
     * @memberof RegenerateMessageData
     */
    'model'?: string | null;
    /**
     * Whether or not to stream the response. If this is set to true or not included, the response will be a stream. If this is set to false, the response will be a normal JSON response. Default is true.
     * @type {boolean}
     * @memberof RegenerateMessageData
     */
    'stream_response'?: boolean | null;
    /**
     * The id of the topic to regenerate the last message for.
     * @type {string}
     * @memberof RegenerateMessageData
     */
    'topic_id': string;
}
/**
 * @type ReturnQueuedChunk
 * @export
 */
export type ReturnQueuedChunk = BatchQueuedChunkResponse | SingleQueuedChunkResponse;

/**
 * 
 * @export
 * @interface ScoreChunkDTO
 */
export interface ScoreChunkDTO {
    /**
     * 
     * @type {Array<ChunkMetadata>}
     * @memberof ScoreChunkDTO
     */
    'metadata': Array<ChunkMetadata>;
    /**
     * 
     * @type {number}
     * @memberof ScoreChunkDTO
     */
    'score': number;
}
/**
 * 
 * @export
 * @interface ScoreSlimChunks
 */
export interface ScoreSlimChunks {
    /**
     * 
     * @type {Array<SlimChunkMetadata>}
     * @memberof ScoreSlimChunks
     */
    'metadata': Array<SlimChunkMetadata>;
    /**
     * 
     * @type {number}
     * @memberof ScoreSlimChunks
     */
    'score': number;
}
/**
 * 
 * @export
 * @interface SearchChunkData
 */
export interface SearchChunkData {
    /**
     * Set date_bias to true to bias search results towards more recent chunks. This will work best in hybrid search mode.
     * @type {boolean}
     * @memberof SearchChunkData
     */
    'date_bias'?: boolean | null;
    /**
     * 
     * @type {ChunkFilter}
     * @memberof SearchChunkData
     */
    'filters'?: ChunkFilter | null;
    /**
     * Set get_collisions to true to get the collisions for each chunk. This will only apply if environment variable COLLISIONS_ENABLED is set to true.
     * @type {boolean}
     * @memberof SearchChunkData
     */
    'get_collisions'?: boolean | null;
    /**
     * Set highlight_delimiters to a list of strings to use as delimiters for highlighting. If not specified, this defaults to [\"?\", \",\", \".\", \"!\"].
     * @type {Array<string>}
     * @memberof SearchChunkData
     */
    'highlight_delimiters'?: Array<string> | null;
    /**
     * Set highlight_results to true to highlight the results. If not specified, this defaults to true.
     * @type {boolean}
     * @memberof SearchChunkData
     */
    'highlight_results'?: boolean | null;
    /**
     * Page of chunks to fetch. Page is 1-indexed.
     * @type {number}
     * @memberof SearchChunkData
     */
    'page'?: number | null;
    /**
     * Page size is the number of chunks to fetch. This can be used to fetch more than 10 chunks at a time.
     * @type {number}
     * @memberof SearchChunkData
     */
    'page_size'?: number | null;
    /**
     * Query is the search query. This can be any string. The query will be used to create an embedding vector and/or SPLADE vector which will be used to find the result set.
     * @type {string}
     * @memberof SearchChunkData
     */
    'query': string;
    /**
     * Set score_threshold to a float to filter out chunks with a score below the threshold.
     * @type {number}
     * @memberof SearchChunkData
     */
    'score_threshold'?: number | null;
    /**
     * Can be either \"semantic\", \"fulltext\", or \"hybrid\". \"hybrid\" will pull in one page (10 chunks) of both semantic and full-text results then re-rank them using BAAI/bge-reranker-large. \"semantic\" will pull in one page (10 chunks) of the nearest cosine distant vectors. \"fulltext\" will pull in one page (10 chunks) of full-text results based on SPLADE.
     * @type {string}
     * @memberof SearchChunkData
     */
    'search_type': string;
    /**
     * Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement. Default is false.
     * @type {boolean}
     * @memberof SearchChunkData
     */
    'slim_chunks'?: boolean | null;
    /**
     * Set use_weights to true to use the weights of the chunks in the result set in order to sort them. If not specified, this defaults to true.
     * @type {boolean}
     * @memberof SearchChunkData
     */
    'use_weights'?: boolean | null;
}
/**
 * 
 * @export
 * @interface SearchChunkQueryResponseBody
 */
export interface SearchChunkQueryResponseBody {
    /**
     * 
     * @type {Array<ScoreChunkDTO>}
     * @memberof SearchChunkQueryResponseBody
     */
    'score_chunks': Array<ScoreChunkDTO>;
    /**
     * 
     * @type {number}
     * @memberof SearchChunkQueryResponseBody
     */
    'total_chunk_pages': number;
}
/**
 * 
 * @export
 * @interface SearchOverGroupsData
 */
export interface SearchOverGroupsData {
    /**
     * 
     * @type {ChunkFilter}
     * @memberof SearchOverGroupsData
     */
    'filters'?: ChunkFilter | null;
    /**
     * Set get_collisions to true to get the collisions for each chunk. This will only apply if environment variable COLLISIONS_ENABLED is set to true.
     * @type {boolean}
     * @memberof SearchOverGroupsData
     */
    'get_collisions'?: boolean | null;
    /**
     * Group_size is the number of chunks to fetch for each group. The default is 3. If a group has less than group_size chunks, all chunks will be returned. If this is set to a large number, we recommend setting slim_chunks to true to avoid returning the content and chunk_html of the chunks so as to lower the amount of time required for content download and serialization.
     * @type {number}
     * @memberof SearchOverGroupsData
     */
    'group_size'?: number | null;
    /**
     * Set highlight_delimiters to a list of strings to use as delimiters for highlighting. If not specified, this defaults to [\"?\", \",\", \".\", \"!\"].
     * @type {Array<string>}
     * @memberof SearchOverGroupsData
     */
    'highlight_delimiters'?: Array<string> | null;
    /**
     * Set highlight_results to true to highlight the results. If not specified, this defaults to true.
     * @type {boolean}
     * @memberof SearchOverGroupsData
     */
    'highlight_results'?: boolean | null;
    /**
     * Page of group results to fetch. Page is 1-indexed.
     * @type {number}
     * @memberof SearchOverGroupsData
     */
    'page'?: number | null;
    /**
     * Page size is the number of group results to fetch. The default is 10.
     * @type {number}
     * @memberof SearchOverGroupsData
     */
    'page_size'?: number | null;
    /**
     * Query is the search query. This can be any string. The query will be used to create an embedding vector and/or SPLADE vector which will be used to find the result set.
     * @type {string}
     * @memberof SearchOverGroupsData
     */
    'query': string;
    /**
     * Set score_threshold to a float to filter out chunks with a score below the threshold.
     * @type {number}
     * @memberof SearchOverGroupsData
     */
    'score_threshold'?: number | null;
    /**
     * Can be either \"semantic\", \"fulltext\", or \"hybrid\". \"hybrid\" will pull in one page (10 chunks) of both semantic and full-text results then re-rank them using BAAI/bge-reranker-large. \"semantic\" will pull in one page (10 chunks) of the nearest cosine distant vectors. \"fulltext\" will pull in one page (10 chunks) of full-text results based on SPLADE.
     * @type {string}
     * @memberof SearchOverGroupsData
     */
    'search_type': string;
    /**
     * Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement. Default is false.
     * @type {boolean}
     * @memberof SearchOverGroupsData
     */
    'slim_chunks'?: boolean | null;
}
/**
 * 
 * @export
 * @interface SearchOverGroupsResults
 */
export interface SearchOverGroupsResults {
    /**
     * 
     * @type {Array<GroupScoreChunk>}
     * @memberof SearchOverGroupsResults
     */
    'group_chunks': Array<GroupScoreChunk>;
    /**
     * 
     * @type {number}
     * @memberof SearchOverGroupsResults
     */
    'total_chunk_pages': number;
}
/**
 * 
 * @export
 * @interface SearchOverGroupsSlimResults
 */
export interface SearchOverGroupsSlimResults {
    /**
     * 
     * @type {Array<GroupScoreSlimChunks>}
     * @memberof SearchOverGroupsSlimResults
     */
    'group_chunks': Array<GroupScoreSlimChunks>;
    /**
     * 
     * @type {number}
     * @memberof SearchOverGroupsSlimResults
     */
    'total_chunk_pages': number;
}
/**
 * 
 * @export
 * @interface SearchSlimChunkQueryResponseBody
 */
export interface SearchSlimChunkQueryResponseBody {
    /**
     * 
     * @type {Array<ScoreSlimChunks>}
     * @memberof SearchSlimChunkQueryResponseBody
     */
    'score_chunks': Array<ScoreSlimChunks>;
    /**
     * 
     * @type {number}
     * @memberof SearchSlimChunkQueryResponseBody
     */
    'total_chunk_pages': number;
}
/**
 * 
 * @export
 * @interface SearchWithinGroupData
 */
export interface SearchWithinGroupData {
    /**
     * Set date_bias to true to bias search results towards more recent chunks. This will work best in hybrid search mode.
     * @type {boolean}
     * @memberof SearchWithinGroupData
     */
    'date_bias'?: boolean | null;
    /**
     * 
     * @type {ChunkFilter}
     * @memberof SearchWithinGroupData
     */
    'filters'?: ChunkFilter | null;
    /**
     * Group specifies the group to search within. Results will only consist of chunks which are bookmarks within the specified group.
     * @type {string}
     * @memberof SearchWithinGroupData
     */
    'group_id'?: string | null;
    /**
     * Group_tracking_id specifies the group to search within by tracking id. Results will only consist of chunks which are bookmarks within the specified group. If both group_id and group_tracking_id are provided, group_id will be used.
     * @type {string}
     * @memberof SearchWithinGroupData
     */
    'group_tracking_id'?: string | null;
    /**
     * Set highlight_delimiters to a list of strings to use as delimiters for highlighting. If not specified, this defaults to [\"?\", \",\", \".\", \"!\"].
     * @type {Array<string>}
     * @memberof SearchWithinGroupData
     */
    'highlight_delimiters'?: Array<string> | null;
    /**
     * Set highlight_results to true to highlight the results. If not specified, this defaults to true.
     * @type {boolean}
     * @memberof SearchWithinGroupData
     */
    'highlight_results'?: boolean | null;
    /**
     * The page of chunks to fetch. Page is 1-indexed.
     * @type {number}
     * @memberof SearchWithinGroupData
     */
    'page'?: number | null;
    /**
     * The page size is the number of chunks to fetch. This can be used to fetch more than 10 chunks at a time.
     * @type {number}
     * @memberof SearchWithinGroupData
     */
    'page_size'?: number | null;
    /**
     * The query is the search query. This can be any string. The query will be used to create an embedding vector and/or SPLADE vector which will be used to find the result set.
     * @type {string}
     * @memberof SearchWithinGroupData
     */
    'query': string;
    /**
     * Set score_threshold to a float to filter out chunks with a score below the threshold.
     * @type {number}
     * @memberof SearchWithinGroupData
     */
    'score_threshold'?: number | null;
    /**
     * Search_type can be either \"semantic\", \"fulltext\", or \"hybrid\". \"hybrid\" will pull in one page (10 chunks) of both semantic and full-text results then re-rank them using BAAI/bge-reranker-large. \"semantic\" will pull in one page (10 chunks) of the nearest cosine distant vectors. \"fulltext\" will pull in one page (10 chunks) of full-text results based on SPLADE.
     * @type {string}
     * @memberof SearchWithinGroupData
     */
    'search_type': string;
    /**
     * Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement. Default is false.
     * @type {boolean}
     * @memberof SearchWithinGroupData
     */
    'slim_chunks'?: boolean | null;
    /**
     * Set use_weights to true to use the weights of the chunks in the result set in order to sort them. If not specified, this defaults to true.
     * @type {boolean}
     * @memberof SearchWithinGroupData
     */
    'use_weights'?: boolean | null;
}
/**
 * 
 * @export
 * @interface SearchWithinGroupResults
 */
export interface SearchWithinGroupResults {
    /**
     * 
     * @type {Array<ScoreChunkDTO>}
     * @memberof SearchWithinGroupResults
     */
    'bookmarks': Array<ScoreChunkDTO>;
    /**
     * 
     * @type {ChunkGroup}
     * @memberof SearchWithinGroupResults
     */
    'group': ChunkGroup;
    /**
     * 
     * @type {number}
     * @memberof SearchWithinGroupResults
     */
    'total_pages': number;
}
/**
 * 
 * @export
 * @interface SearchWithinGroupSlimResults
 */
export interface SearchWithinGroupSlimResults {
    /**
     * 
     * @type {Array<ScoreSlimChunks>}
     * @memberof SearchWithinGroupSlimResults
     */
    'bookmarks': Array<ScoreSlimChunks>;
    /**
     * 
     * @type {ChunkGroup}
     * @memberof SearchWithinGroupSlimResults
     */
    'group': ChunkGroup;
    /**
     * 
     * @type {number}
     * @memberof SearchWithinGroupSlimResults
     */
    'total_pages': number;
}
/**
 * 
 * @export
 * @interface SetUserApiKeyRequest
 */
export interface SetUserApiKeyRequest {
    /**
     * The name which will be assigned to the new api key.
     * @type {string}
     * @memberof SetUserApiKeyRequest
     */
    'name': string;
    /**
     * The role which will be assigned to the new api key. Either 0 (read), 1 (read and write at the level of the currently auth\'ed user). The auth\'ed user must have a role greater than or equal to the role being assigned which means they must be an admin (1) or owner (2) of the organization to assign write permissions with a role of 1.
     * @type {number}
     * @memberof SetUserApiKeyRequest
     */
    'role': number;
}
/**
 * 
 * @export
 * @interface SetUserApiKeyResponse
 */
export interface SetUserApiKeyResponse {
    /**
     * The api key which was created. This is the value which should be used in the Authorization header.
     * @type {string}
     * @memberof SetUserApiKeyResponse
     */
    'api_key': string;
}
/**
 * 
 * @export
 * @interface SingleQueuedChunkResponse
 */
export interface SingleQueuedChunkResponse {
    /**
     * 
     * @type {ChunkMetadata}
     * @memberof SingleQueuedChunkResponse
     */
    'chunk_metadata': ChunkMetadata;
    /**
     * The current position the last access item is in the queue
     * @type {number}
     * @memberof SingleQueuedChunkResponse
     */
    'pos_in_queue': number;
}
/**
 * 
 * @export
 * @interface SlimChunkMetadata
 */
export interface SlimChunkMetadata {
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadata
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadata
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadata
     */
    'link'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof SlimChunkMetadata
     */
    'metadata'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadata
     */
    'qdrant_point_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadata
     */
    'tag_set'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadata
     */
    'time_stamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadata
     */
    'tracking_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadata
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof SlimChunkMetadata
     */
    'weight': number;
}
/**
 * 
 * @export
 * @interface SlimChunkMetadataWithScore
 */
export interface SlimChunkMetadataWithScore {
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadataWithScore
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadataWithScore
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadataWithScore
     */
    'link'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof SlimChunkMetadataWithScore
     */
    'metadata'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadataWithScore
     */
    'qdrant_point_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SlimChunkMetadataWithScore
     */
    'score': number;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadataWithScore
     */
    'tag_set'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadataWithScore
     */
    'time_stamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadataWithScore
     */
    'tracking_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SlimChunkMetadataWithScore
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof SlimChunkMetadataWithScore
     */
    'weight': number;
}
/**
 * 
 * @export
 * @interface SlimGroup
 */
export interface SlimGroup {
    /**
     * 
     * @type {string}
     * @memberof SlimGroup
     */
    'dataset_id': string;
    /**
     * 
     * @type {string}
     * @memberof SlimGroup
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SlimGroup
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof SlimGroup
     */
    'of_current_dataset': boolean;
}
/**
 * 
 * @export
 * @interface SlimUser
 */
export interface SlimUser {
    /**
     * 
     * @type {string}
     * @memberof SlimUser
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SlimUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SlimUser
     */
    'name'?: string | null;
    /**
     * 
     * @type {Array<Organization>}
     * @memberof SlimUser
     */
    'orgs': Array<Organization>;
    /**
     * 
     * @type {Array<UserOrganization>}
     * @memberof SlimUser
     */
    'user_orgs': Array<UserOrganization>;
}
/**
 * 
 * @export
 * @interface StripePlan
 */
export interface StripePlan {
    /**
     * 
     * @type {number}
     * @memberof StripePlan
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof StripePlan
     */
    'chunk_count': number;
    /**
     * 
     * @type {string}
     * @memberof StripePlan
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof StripePlan
     */
    'dataset_count': number;
    /**
     * 
     * @type {number}
     * @memberof StripePlan
     */
    'file_storage': number;
    /**
     * 
     * @type {string}
     * @memberof StripePlan
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof StripePlan
     */
    'message_count': number;
    /**
     * 
     * @type {string}
     * @memberof StripePlan
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StripePlan
     */
    'stripe_id': string;
    /**
     * 
     * @type {string}
     * @memberof StripePlan
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof StripePlan
     */
    'user_count': number;
}
/**
 * 
 * @export
 * @interface SuggestedQueriesRequest
 */
export interface SuggestedQueriesRequest {
    /**
     * The query to base the generated suggested queries off of.
     * @type {string}
     * @memberof SuggestedQueriesRequest
     */
    'query': string;
}
/**
 * 
 * @export
 * @interface SuggestedQueriesResponse
 */
export interface SuggestedQueriesResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof SuggestedQueriesResponse
     */
    'queries': Array<string>;
}
/**
 * 
 * @export
 * @interface Topic
 */
export interface Topic {
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'dataset_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof Topic
     */
    'deleted': boolean;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface UpdateChunkByTrackingIdData
 */
export interface UpdateChunkByTrackingIdData {
    /**
     * HTML content of the chunk you want to update. This can also be plaintext. The innerText of the HTML will be used to create the embedding vector. The point of using HTML is for convienience, as some users have applications where users submit HTML content. If no chunk_html is provided, the existing chunk_html will be used.
     * @type {string}
     * @memberof UpdateChunkByTrackingIdData
     */
    'chunk_html'?: string | null;
    /**
     * Convert HTML to raw text before processing to avoid adding noise to the vector embeddings. By default this is true. If you are using HTML content that you want to be included in the vector embeddings, set this to false.
     * @type {boolean}
     * @memberof UpdateChunkByTrackingIdData
     */
    'convert_html_to_text'?: boolean | null;
    /**
     * Group ids are the ids of the groups that the chunk should be placed into. This is useful for when you want to update a chunk and add it to a group or multiple groups in one request.
     * @type {Array<string>}
     * @memberof UpdateChunkByTrackingIdData
     */
    'group_ids'?: Array<string> | null;
    /**
     * Group tracking_ids are the tracking_ids of the groups that the chunk should be placed into. This is useful for when you want to update a chunk and add it to a group or multiple groups in one request.
     * @type {Array<string>}
     * @memberof UpdateChunkByTrackingIdData
     */
    'group_tracking_ids'?: Array<string> | null;
    /**
     * Link of the chunk you want to update. This can also be any string. Frequently, this is a link to the source of the chunk. The link value will not affect the embedding creation. If no link is provided, the existing link will be used.
     * @type {string}
     * @memberof UpdateChunkByTrackingIdData
     */
    'link'?: string | null;
    /**
     * The metadata is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata. If no metadata is provided, the existing metadata will be used.
     * @type {any}
     * @memberof UpdateChunkByTrackingIdData
     */
    'metadata'?: any | null;
    /**
     * Time_stamp should be an ISO 8601 combined date and time without timezone. It is used for time window filtering and recency-biasing search results. If no time_stamp is provided, the existing time_stamp will be used.
     * @type {string}
     * @memberof UpdateChunkByTrackingIdData
     */
    'time_stamp'?: string | null;
    /**
     * Tracking_id of the chunk you want to update. This is required to match an existing chunk.
     * @type {string}
     * @memberof UpdateChunkByTrackingIdData
     */
    'tracking_id': string;
    /**
     * Weight is a float which can be used to bias search results. This is useful for when you want to bias search results for a chunk. The magnitude only matters relative to other chunks in the chunk\'s dataset dataset. If no weight is provided, the existing weight will be used.
     * @type {number}
     * @memberof UpdateChunkByTrackingIdData
     */
    'weight'?: number | null;
}
/**
 * 
 * @export
 * @interface UpdateChunkData
 */
export interface UpdateChunkData {
    /**
     * HTML content of the chunk you want to update. This can also be plaintext. The innerText of the HTML will be used to create the embedding vector. The point of using HTML is for convienience, as some users have applications where users submit HTML content. If no chunk_html is provided, the existing chunk_html will be used.
     * @type {string}
     * @memberof UpdateChunkData
     */
    'chunk_html'?: string | null;
    /**
     * Id of the chunk you want to update. You can provide either the chunk_id or the tracking_id. If both are provided, the chunk_id will be used.
     * @type {string}
     * @memberof UpdateChunkData
     */
    'chunk_id'?: string | null;
    /**
     * Convert HTML to raw text before processing to avoid adding noise to the vector embeddings. By default this is true. If you are using HTML content that you want to be included in the vector embeddings, set this to false.
     * @type {boolean}
     * @memberof UpdateChunkData
     */
    'convert_html_to_text'?: boolean | null;
    /**
     * Group ids are the ids of the groups that the chunk should be placed into. This is useful for when you want to update a chunk and add it to a group or multiple groups in one request.
     * @type {Array<string>}
     * @memberof UpdateChunkData
     */
    'group_ids'?: Array<string> | null;
    /**
     * Group tracking_ids are the tracking_ids of the groups that the chunk should be placed into. This is useful for when you want to update a chunk and add it to a group or multiple groups in one request.
     * @type {Array<string>}
     * @memberof UpdateChunkData
     */
    'group_tracking_ids'?: Array<string> | null;
    /**
     * Link of the chunk you want to update. This can also be any string. Frequently, this is a link to the source of the chunk. The link value will not affect the embedding creation. If no link is provided, the existing link will be used.
     * @type {string}
     * @memberof UpdateChunkData
     */
    'link'?: string | null;
    /**
     * The metadata is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata. If no metadata is provided, the existing metadata will be used.
     * @type {any}
     * @memberof UpdateChunkData
     */
    'metadata'?: any | null;
    /**
     * Tag set is a list of tags. This can be used to filter chunks by tag. Unlike with metadata filtering, HNSW indices will exist for each tag such that there is not a performance hit for filtering on them. If no tag_set is provided, the existing tag_set will be used.
     * @type {Array<string>}
     * @memberof UpdateChunkData
     */
    'tag_set'?: Array<string> | null;
    /**
     * Time_stamp should be an ISO 8601 combined date and time without timezone. It is used for time window filtering and recency-biasing search results. If no time_stamp is provided, the existing time_stamp will be used.
     * @type {string}
     * @memberof UpdateChunkData
     */
    'time_stamp'?: string | null;
    /**
     * Tracking_id of the chunk you want to update. This is required to match an existing chunk.
     * @type {string}
     * @memberof UpdateChunkData
     */
    'tracking_id'?: string | null;
    /**
     * Weight is a float which can be used to bias search results. This is useful for when you want to bias search results for a chunk. The magnitude only matters relative to other chunks in the chunk\'s dataset dataset. If no weight is provided, the existing weight will be used.
     * @type {number}
     * @memberof UpdateChunkData
     */
    'weight'?: number | null;
}
/**
 * 
 * @export
 * @interface UpdateChunkGroupData
 */
export interface UpdateChunkGroupData {
    /**
     * Description to assign to the chunk_group. Convenience field for you to avoid having to remember what the group is for. If not provided, the description will not be updated.
     * @type {string}
     * @memberof UpdateChunkGroupData
     */
    'description'?: string | null;
    /**
     * Id of the chunk_group to update.
     * @type {string}
     * @memberof UpdateChunkGroupData
     */
    'group_id'?: string | null;
    /**
     * Optional metadata to assign to the chunk_group. This is a JSON object that can store any additional information you want to associate with the chunks inside of the chunk_group.
     * @type {any}
     * @memberof UpdateChunkGroupData
     */
    'metadata'?: any | null;
    /**
     * Name to assign to the chunk_group. Does not need to be unique. If not provided, the name will not be updated.
     * @type {string}
     * @memberof UpdateChunkGroupData
     */
    'name'?: string | null;
    /**
     * Optional tags to assign to the chunk_group. This is a list of strings that can be used to categorize the chunks inside the chunk_group.
     * @type {Array<string>}
     * @memberof UpdateChunkGroupData
     */
    'tag_set'?: Array<string> | null;
    /**
     * Tracking Id of the chunk_group to update.
     * @type {string}
     * @memberof UpdateChunkGroupData
     */
    'tracking_id'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateDatasetRequest
 */
export interface UpdateDatasetRequest {
    /**
     * The new client configuration of the dataset, can be arbitrary JSON. See docs.trieve.ai for more information. If not provided, the client configuration will not be updated.
     * @type {any}
     * @memberof UpdateDatasetRequest
     */
    'client_configuration'?: any | null;
    /**
     * The id of the dataset you want to update.
     * @type {string}
     * @memberof UpdateDatasetRequest
     */
    'dataset_id'?: string | null;
    /**
     * The new name of the dataset. Must be unique within the organization. If not provided, the name will not be updated.
     * @type {string}
     * @memberof UpdateDatasetRequest
     */
    'dataset_name'?: string | null;
    /**
     * The new server configuration of the dataset, can be arbitrary JSON. See docs.trieve.ai for more information. If not provided, the server configuration will not be updated.
     * @type {any}
     * @memberof UpdateDatasetRequest
     */
    'server_configuration'?: any | null;
    /**
     * tracking ID for the dataset. Can be used to track the dataset in external systems.
     * @type {string}
     * @memberof UpdateDatasetRequest
     */
    'tracking_id'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateGroupByTrackingIDData
 */
export interface UpdateGroupByTrackingIDData {
    /**
     * Description to assign to the chunk_group. Convenience field for you to avoid having to remember what the group is for. If not provided, the description will not be updated.
     * @type {string}
     * @memberof UpdateGroupByTrackingIDData
     */
    'description'?: string | null;
    /**
     * Optional metadata to assign to the chunk_group. This is a JSON object that can store any additional information you want to associate with the chunks inside of the chunk_group.
     * @type {any}
     * @memberof UpdateGroupByTrackingIDData
     */
    'metadata'?: any | null;
    /**
     * Name to assign to the chunk_group. Does not need to be unique. If not provided, the name will not be updated.
     * @type {string}
     * @memberof UpdateGroupByTrackingIDData
     */
    'name'?: string | null;
    /**
     * Optional tags to assign to the chunk_group. This is a list of strings that can be used to categorize the chunks inside the chunk_group.
     * @type {Array<string>}
     * @memberof UpdateGroupByTrackingIDData
     */
    'tag_set'?: Array<string> | null;
    /**
     * Tracking Id of the chunk_group to update.
     * @type {string}
     * @memberof UpdateGroupByTrackingIDData
     */
    'tracking_id': string;
}
/**
 * 
 * @export
 * @interface UpdateOrganizationData
 */
export interface UpdateOrganizationData {
    /**
     * The new name of the organization. If not provided, the name will not be updated.
     * @type {string}
     * @memberof UpdateOrganizationData
     */
    'name'?: string | null;
    /**
     * The id of the organization to update.
     * @type {string}
     * @memberof UpdateOrganizationData
     */
    'organization_id': string;
}
/**
 * 
 * @export
 * @interface UpdateTopicData
 */
export interface UpdateTopicData {
    /**
     * The new name of the topic. A name is not generated from this field, it is used as-is.
     * @type {string}
     * @memberof UpdateTopicData
     */
    'name': string;
    /**
     * The id of the topic to target.
     * @type {string}
     * @memberof UpdateTopicData
     */
    'topic_id': string;
}
/**
 * 
 * @export
 * @interface UpdateUserData
 */
export interface UpdateUserData {
    /**
     * In the sense of a legal name, not a username. The new name to assign to the user, if not provided, the current name will be used.
     * @type {string}
     * @memberof UpdateUserData
     */
    'name'?: string | null;
    /**
     * The id of the organization to update the user for.
     * @type {string}
     * @memberof UpdateUserData
     */
    'organization_id': string;
    /**
     * Either 0 (user), 1 (admin), or 2 (owner). If not provided, the current role will be used. The auth\'ed user must have a role greater than or equal to the role being assigned.
     * @type {number}
     * @memberof UpdateUserData
     */
    'role'?: number | null;
    /**
     * The id of the user to update, if not provided, the auth\'ed user will be updated. If provided, the auth\'ed user must be an admin (1) or owner (2) of the organization.
     * @type {string}
     * @memberof UpdateUserData
     */
    'user_id'?: string | null;
}
/**
 * 
 * @export
 * @interface UploadFileData
 */
export interface UploadFileData {
    /**
     * Base64 encoded file. Convert + to -, / to _, and remove the ending = if present. This is the standard base64url encoding.
     * @type {string}
     * @memberof UploadFileData
     */
    'base64_file': string;
    /**
     * Create chunks is a boolean which determines whether or not to create chunks from the file. If false, you can manually chunk the file and send the chunks to the create_chunk endpoint with the file_id to associate chunks with the file. Meant mostly for advanced users.
     * @type {boolean}
     * @memberof UploadFileData
     */
    'create_chunks'?: boolean | null;
    /**
     * Description is an optional convience field so you do not have to remember what the file contains or is about. It will be included on the group resulting from the file which will hold its chunk.
     * @type {string}
     * @memberof UploadFileData
     */
    'description'?: string | null;
    /**
     * Name of the file being uploaded, including the extension.
     * @type {string}
     * @memberof UploadFileData
     */
    'file_name': string;
    /**
     * Group tracking id is an optional field which allows you to specify the tracking id of the group that is created from the file. Chunks created will be created with the tracking id of `group_tracking_id|<index of chunk>`
     * @type {string}
     * @memberof UploadFileData
     */
    'group_tracking_id'?: string | null;
    /**
     * Link to the file. This can also be any string. This can be used to filter when searching for the file\'s resulting chunks. The link value will not affect embedding creation.
     * @type {string}
     * @memberof UploadFileData
     */
    'link'?: string | null;
    /**
     * Metadata is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata. Will be passed down to the file\'s chunks.
     * @type {any}
     * @memberof UploadFileData
     */
    'metadata'?: any | null;
    /**
     * Tag set is a comma separated list of tags which will be passed down to the chunks made from the file. Tags are used to filter chunks when searching. HNSW indices are created for each tag such that there is no performance loss when filtering on them.
     * @type {Array<string>}
     * @memberof UploadFileData
     */
    'tag_set'?: Array<string> | null;
    /**
     * Time stamp should be an ISO 8601 combined date and time without timezone. Time_stamp is used for time window filtering and recency-biasing search results. Will be passed down to the file\'s chunks.
     * @type {string}
     * @memberof UploadFileData
     */
    'time_stamp'?: string | null;
}
/**
 * 
 * @export
 * @interface UploadFileResult
 */
export interface UploadFileResult {
    /**
     * 
     * @type {any}
     * @memberof UploadFileResult
     */
    'file_metadata': any;
}
/**
 * 
 * @export
 * @interface UserOrganization
 */
export interface UserOrganization {
    /**
     * 
     * @type {string}
     * @memberof UserOrganization
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof UserOrganization
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserOrganization
     */
    'organization_id': string;
    /**
     * 
     * @type {number}
     * @memberof UserOrganization
     */
    'role': number;
    /**
     * 
     * @type {string}
     * @memberof UserOrganization
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof UserOrganization
     */
    'user_id': string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OpenID Connect callback  This is the callback route for the OAuth provider, it should not be called directly. Redirects to browser with set-cookie header.
         * @summary OpenID Connect callback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callback: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Me  Get the user corresponding to your current auth credentials.
         * @summary Get Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login  This will redirect you to the OAuth provider for authentication with email/pass, SSO, Google, Github, etc.
         * @summary Login
         * @param {string | null} [organizationId] ID of organization to authenticate into
         * @param {string | null} [redirectUri] URL to redirect to after successful login
         * @param {string | null} [invCode] Code sent via email as a result of successful call to send_invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (organizationId?: string | null, redirectUri?: string | null, invCode?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (organizationId !== undefined) {
                localVarQueryParameter['organization_id'] = organizationId;
            }

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (invCode !== undefined) {
                localVarQueryParameter['inv_code'] = invCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logout  Invalidate your current auth credential stored typically stored in a cookie. This does not invalidate your API key.
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * OpenID Connect callback  This is the callback route for the OAuth provider, it should not be called directly. Redirects to browser with set-cookie header.
         * @summary OpenID Connect callback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callback(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SlimUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callback(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.callback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Me  Get the user corresponding to your current auth credentials.
         * @summary Get Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SlimUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Login  This will redirect you to the OAuth provider for authentication with email/pass, SSO, Google, Github, etc.
         * @summary Login
         * @param {string | null} [organizationId] ID of organization to authenticate into
         * @param {string | null} [redirectUri] URL to redirect to after successful login
         * @param {string | null} [invCode] Code sent via email as a result of successful call to send_invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(organizationId?: string | null, redirectUri?: string | null, invCode?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(organizationId, redirectUri, invCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Logout  Invalidate your current auth credential stored typically stored in a cookie. This does not invalidate your API key.
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * OpenID Connect callback  This is the callback route for the OAuth provider, it should not be called directly. Redirects to browser with set-cookie header.
         * @summary OpenID Connect callback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callback(options?: any): AxiosPromise<SlimUser> {
            return localVarFp.callback(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Me  Get the user corresponding to your current auth credentials.
         * @summary Get Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: any): AxiosPromise<SlimUser> {
            return localVarFp.getMe(options).then((request) => request(axios, basePath));
        },
        /**
         * Login  This will redirect you to the OAuth provider for authentication with email/pass, SSO, Google, Github, etc.
         * @summary Login
         * @param {string | null} [organizationId] ID of organization to authenticate into
         * @param {string | null} [redirectUri] URL to redirect to after successful login
         * @param {string | null} [invCode] Code sent via email as a result of successful call to send_invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(organizationId?: string | null, redirectUri?: string | null, invCode?: string | null, options?: any): AxiosPromise<void> {
            return localVarFp.login(organizationId, redirectUri, invCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Logout  Invalidate your current auth credential stored typically stored in a cookie. This does not invalidate your API key.
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<void> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * OpenID Connect callback  This is the callback route for the OAuth provider, it should not be called directly. Redirects to browser with set-cookie header.
     * @summary OpenID Connect callback
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public callback(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).callback(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Me  Get the user corresponding to your current auth credentials.
     * @summary Get Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getMe(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Login  This will redirect you to the OAuth provider for authentication with email/pass, SSO, Google, Github, etc.
     * @summary Login
     * @param {string | null} [organizationId] ID of organization to authenticate into
     * @param {string | null} [redirectUri] URL to redirect to after successful login
     * @param {string | null} [invCode] Code sent via email as a result of successful call to send_invitation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(organizationId?: string | null, redirectUri?: string | null, invCode?: string | null, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(organizationId, redirectUri, invCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logout  Invalidate your current auth credential stored typically stored in a cookie. This does not invalidate your API key.
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logout(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChunkApi - axios parameter creator
 * @export
 */
export const ChunkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create or Upsert Chunk or Chunks  Create a new chunk. If the chunk has the same tracking_id as an existing chunk, the request will fail. Once a chunk is created, it can be searched for using the search endpoint.
         * @summary Create or Upsert Chunk or Chunks
         * @param {string} tRDataset The dataset id to use for the request
         * @param {CreateChunkData} createChunkData JSON request payload to create a new chunk (chunk)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChunk: async (tRDataset: string, createChunkData: CreateChunkData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('createChunk', 'tRDataset', tRDataset)
            // verify required parameter 'createChunkData' is not null or undefined
            assertParamExists('createChunk', 'createChunkData', createChunkData)
            const localVarPath = `/api/chunk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createChunkData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate suggested queries  This endpoint will generate 3 suggested queries based off the query provided in the request body and return them as a JSON object.
         * @summary Generate suggested queries
         * @param {string} tRDataset The dataset id to use for the request
         * @param {SuggestedQueriesRequest} suggestedQueriesRequest JSON request payload to get alternative suggested queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSuggestedQueriesHandler: async (tRDataset: string, suggestedQueriesRequest: SuggestedQueriesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('createSuggestedQueriesHandler', 'tRDataset', tRDataset)
            // verify required parameter 'suggestedQueriesRequest' is not null or undefined
            assertParamExists('createSuggestedQueriesHandler', 'suggestedQueriesRequest', suggestedQueriesRequest)
            const localVarPath = `/api/chunk/gen_suggestions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(suggestedQueriesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Chunk  Delete a chunk by its id. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.
         * @summary Delete Chunk
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} chunkId Id of the chunk you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChunk: async (tRDataset: string, chunkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('deleteChunk', 'tRDataset', tRDataset)
            // verify required parameter 'chunkId' is not null or undefined
            assertParamExists('deleteChunk', 'chunkId', chunkId)
            const localVarPath = `/api/chunk/{chunk_id}`
                .replace(`{${"chunk_id"}}`, encodeURIComponent(String(chunkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Chunk By Tracking Id  Delete a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.
         * @summary Delete Chunk By Tracking Id
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} trackingId tracking_id of the chunk you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChunkByTrackingId: async (tRDataset: string, trackingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('deleteChunkByTrackingId', 'tRDataset', tRDataset)
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('deleteChunkByTrackingId', 'trackingId', trackingId)
            const localVarPath = `/api/chunk/tracking_id/{tracking_id}`
                .replace(`{${"tracking_id"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * RAG on Specified Chunks  This endpoint exists as an alternative to the topic+message concept where our API handles chat memory. With this endpoint, the user is responsible for providing the context window and the prompt. See more in the \"search before generate\" page at docs.trieve.ai.
         * @summary RAG on Specified Chunks
         * @param {string} tRDataset The dataset id to use for the request
         * @param {GenerateChunksRequest} generateChunksRequest JSON request payload to perform RAG on some chunks (chunks)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateOffChunks: async (tRDataset: string, generateChunksRequest: GenerateChunksRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('generateOffChunks', 'tRDataset', tRDataset)
            // verify required parameter 'generateChunksRequest' is not null or undefined
            assertParamExists('generateOffChunks', 'generateChunksRequest', generateChunksRequest)
            const localVarPath = `/api/chunk/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateChunksRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Chunk By Id  Get a singular chunk by id.
         * @summary Get Chunk By Id
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} chunkId Id of the chunk you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunkById: async (tRDataset: string, chunkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getChunkById', 'tRDataset', tRDataset)
            // verify required parameter 'chunkId' is not null or undefined
            assertParamExists('getChunkById', 'chunkId', chunkId)
            const localVarPath = `/api/chunk/{chunk_id}`
                .replace(`{${"chunk_id"}}`, encodeURIComponent(String(chunkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Chunk By Tracking Id  Get a singular chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use your own id as the primary reference for a chunk.
         * @summary Get Chunk By Tracking Id
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} trackingId tracking_id of the chunk you want to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunkByTrackingId: async (tRDataset: string, trackingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getChunkByTrackingId', 'tRDataset', tRDataset)
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('getChunkByTrackingId', 'trackingId', trackingId)
            const localVarPath = `/api/chunk/tracking_id/{tracking_id}`
                .replace(`{${"tracking_id"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Recommended Chunks  Get recommendations of chunks similar to the chunks in the request. Think about this as a feature similar to the \"add to playlist\" recommendation feature on Spotify. This request pairs especially well with our groups endpoint.
         * @summary Get Recommended Chunks
         * @param {string} tRDataset The dataset id to use for the request
         * @param {RecommendChunksRequest} recommendChunksRequest JSON request payload to get recommendations of chunks similar to the chunks in the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedChunks: async (tRDataset: string, recommendChunksRequest: RecommendChunksRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getRecommendedChunks', 'tRDataset', tRDataset)
            // verify required parameter 'recommendChunksRequest' is not null or undefined
            assertParamExists('getRecommendedChunks', 'recommendChunksRequest', recommendChunksRequest)
            const localVarPath = `/api/chunk/recommend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recommendChunksRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search  This route provides the primary search functionality for the API. It can be used to search for chunks by semantic similarity, full-text similarity, or a combination of both. Results\' `chunk_html` values will be modified with `<b><mark>` tags for sub-sentence highlighting.
         * @summary Search
         * @param {string} tRDataset The dataset id to use for the request
         * @param {SearchChunkData} searchChunkData JSON request payload to semantically search for chunks (chunks)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchChunk: async (tRDataset: string, searchChunkData: SearchChunkData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('searchChunk', 'tRDataset', tRDataset)
            // verify required parameter 'searchChunkData' is not null or undefined
            assertParamExists('searchChunk', 'searchChunkData', searchChunkData)
            const localVarPath = `/api/chunk/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchChunkData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Chunk  Update a chunk. If you try to change the tracking_id of the chunk to have the same tracking_id as an existing chunk, the request will fail.
         * @summary Update Chunk
         * @param {string} tRDataset The dataset id to use for the request
         * @param {UpdateChunkData} updateChunkData JSON request payload to update a chunk (chunk)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChunk: async (tRDataset: string, updateChunkData: UpdateChunkData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('updateChunk', 'tRDataset', tRDataset)
            // verify required parameter 'updateChunkData' is not null or undefined
            assertParamExists('updateChunk', 'updateChunkData', updateChunkData)
            const localVarPath = `/api/chunk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateChunkData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Chunk By Tracking Id  Update a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk.
         * @summary Update Chunk By Tracking Id
         * @param {string} tRDataset The dataset id to use for the request
         * @param {UpdateChunkByTrackingIdData} updateChunkByTrackingIdData JSON request payload to update a chunk by tracking_id (chunks)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateChunkByTrackingId: async (tRDataset: string, updateChunkByTrackingIdData: UpdateChunkByTrackingIdData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('updateChunkByTrackingId', 'tRDataset', tRDataset)
            // verify required parameter 'updateChunkByTrackingIdData' is not null or undefined
            assertParamExists('updateChunkByTrackingId', 'updateChunkByTrackingIdData', updateChunkByTrackingIdData)
            const localVarPath = `/api/chunk/tracking_id/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateChunkByTrackingIdData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChunkApi - functional programming interface
 * @export
 */
export const ChunkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChunkApiAxiosParamCreator(configuration)
    return {
        /**
         * Create or Upsert Chunk or Chunks  Create a new chunk. If the chunk has the same tracking_id as an existing chunk, the request will fail. Once a chunk is created, it can be searched for using the search endpoint.
         * @summary Create or Upsert Chunk or Chunks
         * @param {string} tRDataset The dataset id to use for the request
         * @param {CreateChunkData} createChunkData JSON request payload to create a new chunk (chunk)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChunk(tRDataset: string, createChunkData: CreateChunkData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReturnQueuedChunk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChunk(tRDataset, createChunkData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.createChunk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate suggested queries  This endpoint will generate 3 suggested queries based off the query provided in the request body and return them as a JSON object.
         * @summary Generate suggested queries
         * @param {string} tRDataset The dataset id to use for the request
         * @param {SuggestedQueriesRequest} suggestedQueriesRequest JSON request payload to get alternative suggested queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSuggestedQueriesHandler(tRDataset: string, suggestedQueriesRequest: SuggestedQueriesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuggestedQueriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSuggestedQueriesHandler(tRDataset, suggestedQueriesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.createSuggestedQueriesHandler']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Chunk  Delete a chunk by its id. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.
         * @summary Delete Chunk
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} chunkId Id of the chunk you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChunk(tRDataset: string, chunkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChunk(tRDataset, chunkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.deleteChunk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Chunk By Tracking Id  Delete a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.
         * @summary Delete Chunk By Tracking Id
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} trackingId tracking_id of the chunk you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChunkByTrackingId(tRDataset: string, trackingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChunkByTrackingId(tRDataset, trackingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.deleteChunkByTrackingId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * RAG on Specified Chunks  This endpoint exists as an alternative to the topic+message concept where our API handles chat memory. With this endpoint, the user is responsible for providing the context window and the prompt. See more in the \"search before generate\" page at docs.trieve.ai.
         * @summary RAG on Specified Chunks
         * @param {string} tRDataset The dataset id to use for the request
         * @param {GenerateChunksRequest} generateChunksRequest JSON request payload to perform RAG on some chunks (chunks)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateOffChunks(tRDataset: string, generateChunksRequest: GenerateChunksRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateOffChunks(tRDataset, generateChunksRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.generateOffChunks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Chunk By Id  Get a singular chunk by id.
         * @summary Get Chunk By Id
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} chunkId Id of the chunk you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChunkById(tRDataset: string, chunkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChunkMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChunkById(tRDataset, chunkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.getChunkById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Chunk By Tracking Id  Get a singular chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use your own id as the primary reference for a chunk.
         * @summary Get Chunk By Tracking Id
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} trackingId tracking_id of the chunk you want to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChunkByTrackingId(tRDataset: string, trackingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChunkMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChunkByTrackingId(tRDataset, trackingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.getChunkByTrackingId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Recommended Chunks  Get recommendations of chunks similar to the chunks in the request. Think about this as a feature similar to the \"add to playlist\" recommendation feature on Spotify. This request pairs especially well with our groups endpoint.
         * @summary Get Recommended Chunks
         * @param {string} tRDataset The dataset id to use for the request
         * @param {RecommendChunksRequest} recommendChunksRequest JSON request payload to get recommendations of chunks similar to the chunks in the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendedChunks(tRDataset: string, recommendChunksRequest: RecommendChunksRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChunkMetadataWithScore>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendedChunks(tRDataset, recommendChunksRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.getRecommendedChunks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search  This route provides the primary search functionality for the API. It can be used to search for chunks by semantic similarity, full-text similarity, or a combination of both. Results\' `chunk_html` values will be modified with `<b><mark>` tags for sub-sentence highlighting.
         * @summary Search
         * @param {string} tRDataset The dataset id to use for the request
         * @param {SearchChunkData} searchChunkData JSON request payload to semantically search for chunks (chunks)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchChunk(tRDataset: string, searchChunkData: SearchChunkData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchChunkQueryResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchChunk(tRDataset, searchChunkData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.searchChunk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Chunk  Update a chunk. If you try to change the tracking_id of the chunk to have the same tracking_id as an existing chunk, the request will fail.
         * @summary Update Chunk
         * @param {string} tRDataset The dataset id to use for the request
         * @param {UpdateChunkData} updateChunkData JSON request payload to update a chunk (chunk)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateChunk(tRDataset: string, updateChunkData: UpdateChunkData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateChunk(tRDataset, updateChunkData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.updateChunk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Chunk By Tracking Id  Update a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk.
         * @summary Update Chunk By Tracking Id
         * @param {string} tRDataset The dataset id to use for the request
         * @param {UpdateChunkByTrackingIdData} updateChunkByTrackingIdData JSON request payload to update a chunk by tracking_id (chunks)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateChunkByTrackingId(tRDataset: string, updateChunkByTrackingIdData: UpdateChunkByTrackingIdData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateChunkByTrackingId(tRDataset, updateChunkByTrackingIdData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkApi.updateChunkByTrackingId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChunkApi - factory interface
 * @export
 */
export const ChunkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChunkApiFp(configuration)
    return {
        /**
         * Create or Upsert Chunk or Chunks  Create a new chunk. If the chunk has the same tracking_id as an existing chunk, the request will fail. Once a chunk is created, it can be searched for using the search endpoint.
         * @summary Create or Upsert Chunk or Chunks
         * @param {string} tRDataset The dataset id to use for the request
         * @param {CreateChunkData} createChunkData JSON request payload to create a new chunk (chunk)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChunk(tRDataset: string, createChunkData: CreateChunkData, options?: any): AxiosPromise<ReturnQueuedChunk> {
            return localVarFp.createChunk(tRDataset, createChunkData, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate suggested queries  This endpoint will generate 3 suggested queries based off the query provided in the request body and return them as a JSON object.
         * @summary Generate suggested queries
         * @param {string} tRDataset The dataset id to use for the request
         * @param {SuggestedQueriesRequest} suggestedQueriesRequest JSON request payload to get alternative suggested queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSuggestedQueriesHandler(tRDataset: string, suggestedQueriesRequest: SuggestedQueriesRequest, options?: any): AxiosPromise<SuggestedQueriesResponse> {
            return localVarFp.createSuggestedQueriesHandler(tRDataset, suggestedQueriesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Chunk  Delete a chunk by its id. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.
         * @summary Delete Chunk
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} chunkId Id of the chunk you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChunk(tRDataset: string, chunkId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteChunk(tRDataset, chunkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Chunk By Tracking Id  Delete a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.
         * @summary Delete Chunk By Tracking Id
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} trackingId tracking_id of the chunk you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChunkByTrackingId(tRDataset: string, trackingId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteChunkByTrackingId(tRDataset, trackingId, options).then((request) => request(axios, basePath));
        },
        /**
         * RAG on Specified Chunks  This endpoint exists as an alternative to the topic+message concept where our API handles chat memory. With this endpoint, the user is responsible for providing the context window and the prompt. See more in the \"search before generate\" page at docs.trieve.ai.
         * @summary RAG on Specified Chunks
         * @param {string} tRDataset The dataset id to use for the request
         * @param {GenerateChunksRequest} generateChunksRequest JSON request payload to perform RAG on some chunks (chunks)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateOffChunks(tRDataset: string, generateChunksRequest: GenerateChunksRequest, options?: any): AxiosPromise<string> {
            return localVarFp.generateOffChunks(tRDataset, generateChunksRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Chunk By Id  Get a singular chunk by id.
         * @summary Get Chunk By Id
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} chunkId Id of the chunk you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunkById(tRDataset: string, chunkId: string, options?: any): AxiosPromise<ChunkMetadata> {
            return localVarFp.getChunkById(tRDataset, chunkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Chunk By Tracking Id  Get a singular chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use your own id as the primary reference for a chunk.
         * @summary Get Chunk By Tracking Id
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} trackingId tracking_id of the chunk you want to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunkByTrackingId(tRDataset: string, trackingId: string, options?: any): AxiosPromise<ChunkMetadata> {
            return localVarFp.getChunkByTrackingId(tRDataset, trackingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Recommended Chunks  Get recommendations of chunks similar to the chunks in the request. Think about this as a feature similar to the \"add to playlist\" recommendation feature on Spotify. This request pairs especially well with our groups endpoint.
         * @summary Get Recommended Chunks
         * @param {string} tRDataset The dataset id to use for the request
         * @param {RecommendChunksRequest} recommendChunksRequest JSON request payload to get recommendations of chunks similar to the chunks in the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedChunks(tRDataset: string, recommendChunksRequest: RecommendChunksRequest, options?: any): AxiosPromise<Array<ChunkMetadataWithScore>> {
            return localVarFp.getRecommendedChunks(tRDataset, recommendChunksRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Search  This route provides the primary search functionality for the API. It can be used to search for chunks by semantic similarity, full-text similarity, or a combination of both. Results\' `chunk_html` values will be modified with `<b><mark>` tags for sub-sentence highlighting.
         * @summary Search
         * @param {string} tRDataset The dataset id to use for the request
         * @param {SearchChunkData} searchChunkData JSON request payload to semantically search for chunks (chunks)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchChunk(tRDataset: string, searchChunkData: SearchChunkData, options?: any): AxiosPromise<SearchChunkQueryResponseBody> {
            return localVarFp.searchChunk(tRDataset, searchChunkData, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Chunk  Update a chunk. If you try to change the tracking_id of the chunk to have the same tracking_id as an existing chunk, the request will fail.
         * @summary Update Chunk
         * @param {string} tRDataset The dataset id to use for the request
         * @param {UpdateChunkData} updateChunkData JSON request payload to update a chunk (chunk)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChunk(tRDataset: string, updateChunkData: UpdateChunkData, options?: any): AxiosPromise<void> {
            return localVarFp.updateChunk(tRDataset, updateChunkData, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Chunk By Tracking Id  Update a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk.
         * @summary Update Chunk By Tracking Id
         * @param {string} tRDataset The dataset id to use for the request
         * @param {UpdateChunkByTrackingIdData} updateChunkByTrackingIdData JSON request payload to update a chunk by tracking_id (chunks)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateChunkByTrackingId(tRDataset: string, updateChunkByTrackingIdData: UpdateChunkByTrackingIdData, options?: any): AxiosPromise<void> {
            return localVarFp.updateChunkByTrackingId(tRDataset, updateChunkByTrackingIdData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChunkApi - object-oriented interface
 * @export
 * @class ChunkApi
 * @extends {BaseAPI}
 */
export class ChunkApi extends BaseAPI {
    /**
     * Create or Upsert Chunk or Chunks  Create a new chunk. If the chunk has the same tracking_id as an existing chunk, the request will fail. Once a chunk is created, it can be searched for using the search endpoint.
     * @summary Create or Upsert Chunk or Chunks
     * @param {string} tRDataset The dataset id to use for the request
     * @param {CreateChunkData} createChunkData JSON request payload to create a new chunk (chunk)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public createChunk(tRDataset: string, createChunkData: CreateChunkData, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).createChunk(tRDataset, createChunkData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate suggested queries  This endpoint will generate 3 suggested queries based off the query provided in the request body and return them as a JSON object.
     * @summary Generate suggested queries
     * @param {string} tRDataset The dataset id to use for the request
     * @param {SuggestedQueriesRequest} suggestedQueriesRequest JSON request payload to get alternative suggested queries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public createSuggestedQueriesHandler(tRDataset: string, suggestedQueriesRequest: SuggestedQueriesRequest, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).createSuggestedQueriesHandler(tRDataset, suggestedQueriesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Chunk  Delete a chunk by its id. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.
     * @summary Delete Chunk
     * @param {string} tRDataset The dataset id to use for the request
     * @param {string} chunkId Id of the chunk you want to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public deleteChunk(tRDataset: string, chunkId: string, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).deleteChunk(tRDataset, chunkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Chunk By Tracking Id  Delete a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.
     * @summary Delete Chunk By Tracking Id
     * @param {string} tRDataset The dataset id to use for the request
     * @param {string} trackingId tracking_id of the chunk you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public deleteChunkByTrackingId(tRDataset: string, trackingId: string, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).deleteChunkByTrackingId(tRDataset, trackingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * RAG on Specified Chunks  This endpoint exists as an alternative to the topic+message concept where our API handles chat memory. With this endpoint, the user is responsible for providing the context window and the prompt. See more in the \"search before generate\" page at docs.trieve.ai.
     * @summary RAG on Specified Chunks
     * @param {string} tRDataset The dataset id to use for the request
     * @param {GenerateChunksRequest} generateChunksRequest JSON request payload to perform RAG on some chunks (chunks)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public generateOffChunks(tRDataset: string, generateChunksRequest: GenerateChunksRequest, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).generateOffChunks(tRDataset, generateChunksRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Chunk By Id  Get a singular chunk by id.
     * @summary Get Chunk By Id
     * @param {string} tRDataset The dataset id to use for the request
     * @param {string} chunkId Id of the chunk you want to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public getChunkById(tRDataset: string, chunkId: string, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).getChunkById(tRDataset, chunkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Chunk By Tracking Id  Get a singular chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use your own id as the primary reference for a chunk.
     * @summary Get Chunk By Tracking Id
     * @param {string} tRDataset The dataset id to use for the request
     * @param {string} trackingId tracking_id of the chunk you want to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public getChunkByTrackingId(tRDataset: string, trackingId: string, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).getChunkByTrackingId(tRDataset, trackingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Recommended Chunks  Get recommendations of chunks similar to the chunks in the request. Think about this as a feature similar to the \"add to playlist\" recommendation feature on Spotify. This request pairs especially well with our groups endpoint.
     * @summary Get Recommended Chunks
     * @param {string} tRDataset The dataset id to use for the request
     * @param {RecommendChunksRequest} recommendChunksRequest JSON request payload to get recommendations of chunks similar to the chunks in the request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public getRecommendedChunks(tRDataset: string, recommendChunksRequest: RecommendChunksRequest, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).getRecommendedChunks(tRDataset, recommendChunksRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search  This route provides the primary search functionality for the API. It can be used to search for chunks by semantic similarity, full-text similarity, or a combination of both. Results\' `chunk_html` values will be modified with `<b><mark>` tags for sub-sentence highlighting.
     * @summary Search
     * @param {string} tRDataset The dataset id to use for the request
     * @param {SearchChunkData} searchChunkData JSON request payload to semantically search for chunks (chunks)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public searchChunk(tRDataset: string, searchChunkData: SearchChunkData, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).searchChunk(tRDataset, searchChunkData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Chunk  Update a chunk. If you try to change the tracking_id of the chunk to have the same tracking_id as an existing chunk, the request will fail.
     * @summary Update Chunk
     * @param {string} tRDataset The dataset id to use for the request
     * @param {UpdateChunkData} updateChunkData JSON request payload to update a chunk (chunk)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public updateChunk(tRDataset: string, updateChunkData: UpdateChunkData, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).updateChunk(tRDataset, updateChunkData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Chunk By Tracking Id  Update a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk.
     * @summary Update Chunk By Tracking Id
     * @param {string} tRDataset The dataset id to use for the request
     * @param {UpdateChunkByTrackingIdData} updateChunkByTrackingIdData JSON request payload to update a chunk by tracking_id (chunks)
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public updateChunkByTrackingId(tRDataset: string, updateChunkByTrackingIdData: UpdateChunkByTrackingIdData, options?: RawAxiosRequestConfig) {
        return ChunkApiFp(this.configuration).updateChunkByTrackingId(tRDataset, updateChunkByTrackingIdData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChunkGroupApi - axios parameter creator
 * @export
 */
export const ChunkGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add Chunk to Group  Route to add a chunk to a group.
         * @summary Add Chunk to Group
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} groupId Id of the group to add the chunk to as a bookmark
         * @param {AddChunkToGroupData} addChunkToGroupData JSON request payload to add a chunk to a group (bookmark it)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addChunkToGroup: async (tRDataset: string, groupId: string, addChunkToGroupData: AddChunkToGroupData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('addChunkToGroup', 'tRDataset', tRDataset)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('addChunkToGroup', 'groupId', groupId)
            // verify required parameter 'addChunkToGroupData' is not null or undefined
            assertParamExists('addChunkToGroup', 'addChunkToGroupData', addChunkToGroupData)
            const localVarPath = `/api/chunk_group/chunk/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addChunkToGroupData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add Chunk to Group by Tracking ID  Route to add a chunk to a group by tracking id.
         * @summary Add Chunk to Group by Tracking ID
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} trackingId Id of the group to add the chunk to as a bookmark
         * @param {AddChunkToGroupData} addChunkToGroupData JSON request payload to add a chunk to a group (bookmark it)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        addChunkToGroupByTrackingId: async (tRDataset: string, trackingId: string, addChunkToGroupData: AddChunkToGroupData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('addChunkToGroupByTrackingId', 'tRDataset', tRDataset)
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('addChunkToGroupByTrackingId', 'trackingId', trackingId)
            // verify required parameter 'addChunkToGroupData' is not null or undefined
            assertParamExists('addChunkToGroupByTrackingId', 'addChunkToGroupData', addChunkToGroupData)
            const localVarPath = `/api/chunk_group/tracking_id/{tracking_id}`
                .replace(`{${"tracking_id"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addChunkToGroupData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create Chunk Group  Create a new chunk_group. This is a way to group chunks together. If you try to create a chunk_group with the same tracking_id as an existing chunk_group, this operation will fail.
         * @summary Create Chunk Group
         * @param {string} tRDataset The dataset id to use for the request
         * @param {CreateChunkGroupData} createChunkGroupData JSON request payload to cretea a chunkGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChunkGroup: async (tRDataset: string, createChunkGroupData: CreateChunkGroupData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('createChunkGroup', 'tRDataset', tRDataset)
            // verify required parameter 'createChunkGroupData' is not null or undefined
            assertParamExists('createChunkGroup', 'createChunkGroupData', createChunkGroupData)
            const localVarPath = `/api/chunk_group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createChunkGroupData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Group  This will delete a chunk_group. If you set delete_chunks to true, it will also delete the chunks within the group.
         * @summary Delete Group
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} groupId Id of the group you want to fetch.
         * @param {boolean} deleteChunks Delete the chunks within the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChunkGroup: async (tRDataset: string, groupId: string, deleteChunks: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('deleteChunkGroup', 'tRDataset', tRDataset)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteChunkGroup', 'groupId', groupId)
            // verify required parameter 'deleteChunks' is not null or undefined
            assertParamExists('deleteChunkGroup', 'deleteChunks', deleteChunks)
            const localVarPath = `/api/chunk_group/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (deleteChunks !== undefined) {
                localVarQueryParameter['delete_chunks'] = deleteChunks;
            }

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Group by Tracking ID  Delete a chunk_group with the given tracking id.
         * @summary Delete Group by Tracking ID
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} trackingId Tracking id of the chunk_group to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupByTrackingId: async (tRDataset: string, trackingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('deleteGroupByTrackingId', 'tRDataset', tRDataset)
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('deleteGroupByTrackingId', 'trackingId', trackingId)
            const localVarPath = `/api/chunk_group/tracking_id/{tracking_id}`
                .replace(`{${"tracking_id"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Group  Fetch the group with the given id. get_group
         * @summary Get Group
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} groupId Id of the group you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunkGroup: async (tRDataset: string, groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getChunkGroup', 'tRDataset', tRDataset)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getChunkGroup', 'groupId', groupId)
            const localVarPath = `/api/chunk_group/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Chunks in Group  Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Page is 1-indexed.
         * @summary Get Chunks in Group
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} groupId Id of the group you want to fetch.
         * @param {number | null} page The page of chunks to get from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunksInGroup: async (tRDataset: string, groupId: string, page: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getChunksInGroup', 'tRDataset', tRDataset)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getChunksInGroup', 'groupId', groupId)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getChunksInGroup', 'page', page)
            const localVarPath = `/api/chunk_group/{group_id}/{page}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"page"}}`, encodeURIComponent(String(page)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Chunks in Group by Tracking ID  Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Support for custom page size is coming soon. Page is 1-indexed.
         * @summary Get Chunks in Group by Tracking ID
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} groupTrackingId The id of the group to get the chunks from
         * @param {number} page The page of chunks to get from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunksInGroupByTrackingId: async (tRDataset: string, groupTrackingId: string, page: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getChunksInGroupByTrackingId', 'tRDataset', tRDataset)
            // verify required parameter 'groupTrackingId' is not null or undefined
            assertParamExists('getChunksInGroupByTrackingId', 'groupTrackingId', groupTrackingId)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getChunksInGroupByTrackingId', 'page', page)
            const localVarPath = `/api/chunk_group/tracking_id/{group_tracking_id}/{page}`
                .replace(`{${"group_tracking_id"}}`, encodeURIComponent(String(groupTrackingId)))
                .replace(`{${"page"}}`, encodeURIComponent(String(page)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Group by Tracking ID  Fetch the group with the given tracking id. get_group_by_tracking_id
         * @summary Get Group by Tracking ID
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} trackingId The tracking id of the group to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupByTrackingId: async (tRDataset: string, trackingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getGroupByTrackingId', 'tRDataset', tRDataset)
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('getGroupByTrackingId', 'trackingId', trackingId)
            const localVarPath = `/api/chunk_group/tracking_id/{tracking_id}`
                .replace(`{${"tracking_id"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Groups for Chunks  Route to get the groups that a chunk is in.
         * @summary Get Groups for Chunks
         * @param {string} tRDataset The dataset id to use for the request
         * @param {GetGroupsForChunksData} getGroupsForChunksData JSON request payload to get the groups that a chunk is in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsChunkIsIn: async (tRDataset: string, getGroupsForChunksData: GetGroupsForChunksData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getGroupsChunkIsIn', 'tRDataset', tRDataset)
            // verify required parameter 'getGroupsForChunksData' is not null or undefined
            assertParamExists('getGroupsChunkIsIn', 'getGroupsForChunksData', getGroupsForChunksData)
            const localVarPath = `/api/chunk_group/chunks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getGroupsForChunksData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Recommended Groups  Route to get recommended groups. This route will return groups which are similar to the groups in the request body.
         * @summary Get Recommended Groups
         * @param {string} tRDataset The dataset id to use for the request
         * @param {RecommendGroupChunksRequest} recommendGroupChunksRequest JSON request payload to get recommendations of chunks similar to the chunks in the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedGroups: async (tRDataset: string, recommendGroupChunksRequest: RecommendGroupChunksRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getRecommendedGroups', 'tRDataset', tRDataset)
            // verify required parameter 'recommendGroupChunksRequest' is not null or undefined
            assertParamExists('getRecommendedGroups', 'recommendGroupChunksRequest', recommendGroupChunksRequest)
            const localVarPath = `/api/chunk_group/recommend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recommendGroupChunksRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Groups for Dataset  Fetch the groups which belong to a dataset specified by its id.
         * @summary Get Groups for Dataset
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} datasetId The id of the dataset to fetch groups for.
         * @param {number} page The page of groups to fetch. Page is 1-indexed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpecificDatasetChunkGroups: async (tRDataset: string, datasetId: string, page: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getSpecificDatasetChunkGroups', 'tRDataset', tRDataset)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getSpecificDatasetChunkGroups', 'datasetId', datasetId)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getSpecificDatasetChunkGroups', 'page', page)
            const localVarPath = `/api/dataset/groups/{dataset_id}/{page}`
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"page"}}`, encodeURIComponent(String(page)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove Chunk from Group  Route to remove a chunk from a group.
         * @summary Remove Chunk from Group
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} groupId Id of the group to remove the bookmark\&#39;ed chunk from
         * @param {CreateChunkGroupData} createChunkGroupData JSON request payload to cretea a chunkGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeChunkFromGroup: async (tRDataset: string, groupId: string, createChunkGroupData: CreateChunkGroupData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('removeChunkFromGroup', 'tRDataset', tRDataset)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('removeChunkFromGroup', 'groupId', groupId)
            // verify required parameter 'createChunkGroupData' is not null or undefined
            assertParamExists('removeChunkFromGroup', 'createChunkGroupData', createChunkGroupData)
            const localVarPath = `/api/chunk_group/chunk/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createChunkGroupData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search Over Groups  This route allows you to get groups as results instead of chunks. Each group returned will have the matching chunks sorted by similarity within the group. This is useful for when you want to get groups of chunks which are similar to the search query. If choosing hybrid search, the results will be re-ranked using BAAI/bge-reranker-large. Compatible with semantic, fulltext, or hybrid search modes.
         * @summary Search Over Groups
         * @param {string} tRDataset The dataset id to use for the request
         * @param {SearchOverGroupsData} searchOverGroupsData JSON request payload to semantically search over groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchOverGroups: async (tRDataset: string, searchOverGroupsData: SearchOverGroupsData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('searchOverGroups', 'tRDataset', tRDataset)
            // verify required parameter 'searchOverGroupsData' is not null or undefined
            assertParamExists('searchOverGroups', 'searchOverGroupsData', searchOverGroupsData)
            const localVarPath = `/api/chunk_group/group_oriented_search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchOverGroupsData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search Within Group  This route allows you to search only within a group. This is useful for when you only want search results to contain chunks which are members of a specific group. If choosing hybrid search, the results will be re-ranked using BAAI/bge-reranker-large.
         * @summary Search Within Group
         * @param {string} tRDataset The dataset id to use for the request
         * @param {SearchWithinGroupData} searchWithinGroupData JSON request payload to semantically search a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchWithinGroup: async (tRDataset: string, searchWithinGroupData: SearchWithinGroupData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('searchWithinGroup', 'tRDataset', tRDataset)
            // verify required parameter 'searchWithinGroupData' is not null or undefined
            assertParamExists('searchWithinGroup', 'searchWithinGroupData', searchWithinGroupData)
            const localVarPath = `/api/chunk_group/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchWithinGroupData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Group  Update a chunk_group. If you try to change the tracking_id to one that already exists, this operation will fail.
         * @summary Update Group
         * @param {string} tRDataset The dataset id to use for the request
         * @param {UpdateChunkGroupData} updateChunkGroupData JSON request payload to update a chunkGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChunkGroup: async (tRDataset: string, updateChunkGroupData: UpdateChunkGroupData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('updateChunkGroup', 'tRDataset', tRDataset)
            // verify required parameter 'updateChunkGroupData' is not null or undefined
            assertParamExists('updateChunkGroup', 'updateChunkGroupData', updateChunkGroupData)
            const localVarPath = `/api/chunk_group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateChunkGroupData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Group by Tracking ID  Update a chunk_group with the given tracking id.
         * @summary Update Group by Tracking ID
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} trackingId Tracking id of the chunk_group to update
         * @param {UpdateGroupByTrackingIDData} updateGroupByTrackingIDData JSON request payload to update a chunkGroup
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateGroupByTrackingId: async (tRDataset: string, trackingId: string, updateGroupByTrackingIDData: UpdateGroupByTrackingIDData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('updateGroupByTrackingId', 'tRDataset', tRDataset)
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('updateGroupByTrackingId', 'trackingId', trackingId)
            // verify required parameter 'updateGroupByTrackingIDData' is not null or undefined
            assertParamExists('updateGroupByTrackingId', 'updateGroupByTrackingIDData', updateGroupByTrackingIDData)
            const localVarPath = `/api/chunk_group/tracking_id/{tracking_id}`
                .replace(`{${"tracking_id"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGroupByTrackingIDData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChunkGroupApi - functional programming interface
 * @export
 */
export const ChunkGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChunkGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * Add Chunk to Group  Route to add a chunk to a group.
         * @summary Add Chunk to Group
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} groupId Id of the group to add the chunk to as a bookmark
         * @param {AddChunkToGroupData} addChunkToGroupData JSON request payload to add a chunk to a group (bookmark it)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addChunkToGroup(tRDataset: string, groupId: string, addChunkToGroupData: AddChunkToGroupData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addChunkToGroup(tRDataset, groupId, addChunkToGroupData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.addChunkToGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add Chunk to Group by Tracking ID  Route to add a chunk to a group by tracking id.
         * @summary Add Chunk to Group by Tracking ID
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} trackingId Id of the group to add the chunk to as a bookmark
         * @param {AddChunkToGroupData} addChunkToGroupData JSON request payload to add a chunk to a group (bookmark it)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async addChunkToGroupByTrackingId(tRDataset: string, trackingId: string, addChunkToGroupData: AddChunkToGroupData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addChunkToGroupByTrackingId(tRDataset, trackingId, addChunkToGroupData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.addChunkToGroupByTrackingId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create Chunk Group  Create a new chunk_group. This is a way to group chunks together. If you try to create a chunk_group with the same tracking_id as an existing chunk_group, this operation will fail.
         * @summary Create Chunk Group
         * @param {string} tRDataset The dataset id to use for the request
         * @param {CreateChunkGroupData} createChunkGroupData JSON request payload to cretea a chunkGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChunkGroup(tRDataset: string, createChunkGroupData: CreateChunkGroupData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChunkGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChunkGroup(tRDataset, createChunkGroupData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.createChunkGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Group  This will delete a chunk_group. If you set delete_chunks to true, it will also delete the chunks within the group.
         * @summary Delete Group
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} groupId Id of the group you want to fetch.
         * @param {boolean} deleteChunks Delete the chunks within the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChunkGroup(tRDataset: string, groupId: string, deleteChunks: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChunkGroup(tRDataset, groupId, deleteChunks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.deleteChunkGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Group by Tracking ID  Delete a chunk_group with the given tracking id.
         * @summary Delete Group by Tracking ID
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} trackingId Tracking id of the chunk_group to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupByTrackingId(tRDataset: string, trackingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupByTrackingId(tRDataset, trackingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.deleteGroupByTrackingId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Group  Fetch the group with the given id. get_group
         * @summary Get Group
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} groupId Id of the group you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChunkGroup(tRDataset: string, groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChunkGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChunkGroup(tRDataset, groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.getChunkGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Chunks in Group  Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Page is 1-indexed.
         * @summary Get Chunks in Group
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} groupId Id of the group you want to fetch.
         * @param {number | null} page The page of chunks to get from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChunksInGroup(tRDataset: string, groupId: string, page: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChunksInGroup(tRDataset, groupId, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.getChunksInGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Chunks in Group by Tracking ID  Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Support for custom page size is coming soon. Page is 1-indexed.
         * @summary Get Chunks in Group by Tracking ID
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} groupTrackingId The id of the group to get the chunks from
         * @param {number} page The page of chunks to get from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChunksInGroupByTrackingId(tRDataset: string, groupTrackingId: string, page: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChunksInGroupByTrackingId(tRDataset, groupTrackingId, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.getChunksInGroupByTrackingId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Group by Tracking ID  Fetch the group with the given tracking id. get_group_by_tracking_id
         * @summary Get Group by Tracking ID
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} trackingId The tracking id of the group to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupByTrackingId(tRDataset: string, trackingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChunkGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupByTrackingId(tRDataset, trackingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.getGroupByTrackingId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Groups for Chunks  Route to get the groups that a chunk is in.
         * @summary Get Groups for Chunks
         * @param {string} tRDataset The dataset id to use for the request
         * @param {GetGroupsForChunksData} getGroupsForChunksData JSON request payload to get the groups that a chunk is in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupsChunkIsIn(tRDataset: string, getGroupsForChunksData: GetGroupsForChunksData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BookmarkGroupResult>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupsChunkIsIn(tRDataset, getGroupsForChunksData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.getGroupsChunkIsIn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Recommended Groups  Route to get recommended groups. This route will return groups which are similar to the groups in the request body.
         * @summary Get Recommended Groups
         * @param {string} tRDataset The dataset id to use for the request
         * @param {RecommendGroupChunksRequest} recommendGroupChunksRequest JSON request payload to get recommendations of chunks similar to the chunks in the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendedGroups(tRDataset: string, recommendGroupChunksRequest: RecommendGroupChunksRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupScoreChunk>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendedGroups(tRDataset, recommendGroupChunksRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.getRecommendedGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Groups for Dataset  Fetch the groups which belong to a dataset specified by its id.
         * @summary Get Groups for Dataset
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} datasetId The id of the dataset to fetch groups for.
         * @param {number} page The page of groups to fetch. Page is 1-indexed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpecificDatasetChunkGroups(tRDataset: string, datasetId: string, page: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSpecificDatasetChunkGroups(tRDataset, datasetId, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.getSpecificDatasetChunkGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove Chunk from Group  Route to remove a chunk from a group.
         * @summary Remove Chunk from Group
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} groupId Id of the group to remove the bookmark\&#39;ed chunk from
         * @param {CreateChunkGroupData} createChunkGroupData JSON request payload to cretea a chunkGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeChunkFromGroup(tRDataset: string, groupId: string, createChunkGroupData: CreateChunkGroupData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeChunkFromGroup(tRDataset, groupId, createChunkGroupData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.removeChunkFromGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search Over Groups  This route allows you to get groups as results instead of chunks. Each group returned will have the matching chunks sorted by similarity within the group. This is useful for when you want to get groups of chunks which are similar to the search query. If choosing hybrid search, the results will be re-ranked using BAAI/bge-reranker-large. Compatible with semantic, fulltext, or hybrid search modes.
         * @summary Search Over Groups
         * @param {string} tRDataset The dataset id to use for the request
         * @param {SearchOverGroupsData} searchOverGroupsData JSON request payload to semantically search over groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchOverGroups(tRDataset: string, searchOverGroupsData: SearchOverGroupsData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchOverGroupsResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchOverGroups(tRDataset, searchOverGroupsData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.searchOverGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search Within Group  This route allows you to search only within a group. This is useful for when you only want search results to contain chunks which are members of a specific group. If choosing hybrid search, the results will be re-ranked using BAAI/bge-reranker-large.
         * @summary Search Within Group
         * @param {string} tRDataset The dataset id to use for the request
         * @param {SearchWithinGroupData} searchWithinGroupData JSON request payload to semantically search a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchWithinGroup(tRDataset: string, searchWithinGroupData: SearchWithinGroupData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchWithinGroupResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchWithinGroup(tRDataset, searchWithinGroupData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.searchWithinGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Group  Update a chunk_group. If you try to change the tracking_id to one that already exists, this operation will fail.
         * @summary Update Group
         * @param {string} tRDataset The dataset id to use for the request
         * @param {UpdateChunkGroupData} updateChunkGroupData JSON request payload to update a chunkGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateChunkGroup(tRDataset: string, updateChunkGroupData: UpdateChunkGroupData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateChunkGroup(tRDataset, updateChunkGroupData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.updateChunkGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Group by Tracking ID  Update a chunk_group with the given tracking id.
         * @summary Update Group by Tracking ID
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} trackingId Tracking id of the chunk_group to update
         * @param {UpdateGroupByTrackingIDData} updateGroupByTrackingIDData JSON request payload to update a chunkGroup
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateGroupByTrackingId(tRDataset: string, trackingId: string, updateGroupByTrackingIDData: UpdateGroupByTrackingIDData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupByTrackingId(tRDataset, trackingId, updateGroupByTrackingIDData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChunkGroupApi.updateGroupByTrackingId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChunkGroupApi - factory interface
 * @export
 */
export const ChunkGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChunkGroupApiFp(configuration)
    return {
        /**
         * Add Chunk to Group  Route to add a chunk to a group.
         * @summary Add Chunk to Group
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} groupId Id of the group to add the chunk to as a bookmark
         * @param {AddChunkToGroupData} addChunkToGroupData JSON request payload to add a chunk to a group (bookmark it)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addChunkToGroup(tRDataset: string, groupId: string, addChunkToGroupData: AddChunkToGroupData, options?: any): AxiosPromise<void> {
            return localVarFp.addChunkToGroup(tRDataset, groupId, addChunkToGroupData, options).then((request) => request(axios, basePath));
        },
        /**
         * Add Chunk to Group by Tracking ID  Route to add a chunk to a group by tracking id.
         * @summary Add Chunk to Group by Tracking ID
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} trackingId Id of the group to add the chunk to as a bookmark
         * @param {AddChunkToGroupData} addChunkToGroupData JSON request payload to add a chunk to a group (bookmark it)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        addChunkToGroupByTrackingId(tRDataset: string, trackingId: string, addChunkToGroupData: AddChunkToGroupData, options?: any): AxiosPromise<void> {
            return localVarFp.addChunkToGroupByTrackingId(tRDataset, trackingId, addChunkToGroupData, options).then((request) => request(axios, basePath));
        },
        /**
         * Create Chunk Group  Create a new chunk_group. This is a way to group chunks together. If you try to create a chunk_group with the same tracking_id as an existing chunk_group, this operation will fail.
         * @summary Create Chunk Group
         * @param {string} tRDataset The dataset id to use for the request
         * @param {CreateChunkGroupData} createChunkGroupData JSON request payload to cretea a chunkGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChunkGroup(tRDataset: string, createChunkGroupData: CreateChunkGroupData, options?: any): AxiosPromise<ChunkGroup> {
            return localVarFp.createChunkGroup(tRDataset, createChunkGroupData, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Group  This will delete a chunk_group. If you set delete_chunks to true, it will also delete the chunks within the group.
         * @summary Delete Group
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} groupId Id of the group you want to fetch.
         * @param {boolean} deleteChunks Delete the chunks within the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChunkGroup(tRDataset: string, groupId: string, deleteChunks: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteChunkGroup(tRDataset, groupId, deleteChunks, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Group by Tracking ID  Delete a chunk_group with the given tracking id.
         * @summary Delete Group by Tracking ID
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} trackingId Tracking id of the chunk_group to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupByTrackingId(tRDataset: string, trackingId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroupByTrackingId(tRDataset, trackingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Group  Fetch the group with the given id. get_group
         * @summary Get Group
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} groupId Id of the group you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunkGroup(tRDataset: string, groupId: string, options?: any): AxiosPromise<ChunkGroup> {
            return localVarFp.getChunkGroup(tRDataset, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Chunks in Group  Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Page is 1-indexed.
         * @summary Get Chunks in Group
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} groupId Id of the group you want to fetch.
         * @param {number | null} page The page of chunks to get from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunksInGroup(tRDataset: string, groupId: string, page: number | null, options?: any): AxiosPromise<BookmarkData> {
            return localVarFp.getChunksInGroup(tRDataset, groupId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Chunks in Group by Tracking ID  Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Support for custom page size is coming soon. Page is 1-indexed.
         * @summary Get Chunks in Group by Tracking ID
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} groupTrackingId The id of the group to get the chunks from
         * @param {number} page The page of chunks to get from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunksInGroupByTrackingId(tRDataset: string, groupTrackingId: string, page: number, options?: any): AxiosPromise<BookmarkData> {
            return localVarFp.getChunksInGroupByTrackingId(tRDataset, groupTrackingId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Group by Tracking ID  Fetch the group with the given tracking id. get_group_by_tracking_id
         * @summary Get Group by Tracking ID
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} trackingId The tracking id of the group to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupByTrackingId(tRDataset: string, trackingId: string, options?: any): AxiosPromise<ChunkGroup> {
            return localVarFp.getGroupByTrackingId(tRDataset, trackingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Groups for Chunks  Route to get the groups that a chunk is in.
         * @summary Get Groups for Chunks
         * @param {string} tRDataset The dataset id to use for the request
         * @param {GetGroupsForChunksData} getGroupsForChunksData JSON request payload to get the groups that a chunk is in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsChunkIsIn(tRDataset: string, getGroupsForChunksData: GetGroupsForChunksData, options?: any): AxiosPromise<Array<BookmarkGroupResult>> {
            return localVarFp.getGroupsChunkIsIn(tRDataset, getGroupsForChunksData, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Recommended Groups  Route to get recommended groups. This route will return groups which are similar to the groups in the request body.
         * @summary Get Recommended Groups
         * @param {string} tRDataset The dataset id to use for the request
         * @param {RecommendGroupChunksRequest} recommendGroupChunksRequest JSON request payload to get recommendations of chunks similar to the chunks in the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedGroups(tRDataset: string, recommendGroupChunksRequest: RecommendGroupChunksRequest, options?: any): AxiosPromise<Array<GroupScoreChunk>> {
            return localVarFp.getRecommendedGroups(tRDataset, recommendGroupChunksRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Groups for Dataset  Fetch the groups which belong to a dataset specified by its id.
         * @summary Get Groups for Dataset
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} datasetId The id of the dataset to fetch groups for.
         * @param {number} page The page of groups to fetch. Page is 1-indexed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpecificDatasetChunkGroups(tRDataset: string, datasetId: string, page: number, options?: any): AxiosPromise<GroupData> {
            return localVarFp.getSpecificDatasetChunkGroups(tRDataset, datasetId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove Chunk from Group  Route to remove a chunk from a group.
         * @summary Remove Chunk from Group
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} groupId Id of the group to remove the bookmark\&#39;ed chunk from
         * @param {CreateChunkGroupData} createChunkGroupData JSON request payload to cretea a chunkGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeChunkFromGroup(tRDataset: string, groupId: string, createChunkGroupData: CreateChunkGroupData, options?: any): AxiosPromise<void> {
            return localVarFp.removeChunkFromGroup(tRDataset, groupId, createChunkGroupData, options).then((request) => request(axios, basePath));
        },
        /**
         * Search Over Groups  This route allows you to get groups as results instead of chunks. Each group returned will have the matching chunks sorted by similarity within the group. This is useful for when you want to get groups of chunks which are similar to the search query. If choosing hybrid search, the results will be re-ranked using BAAI/bge-reranker-large. Compatible with semantic, fulltext, or hybrid search modes.
         * @summary Search Over Groups
         * @param {string} tRDataset The dataset id to use for the request
         * @param {SearchOverGroupsData} searchOverGroupsData JSON request payload to semantically search over groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchOverGroups(tRDataset: string, searchOverGroupsData: SearchOverGroupsData, options?: any): AxiosPromise<SearchOverGroupsResults> {
            return localVarFp.searchOverGroups(tRDataset, searchOverGroupsData, options).then((request) => request(axios, basePath));
        },
        /**
         * Search Within Group  This route allows you to search only within a group. This is useful for when you only want search results to contain chunks which are members of a specific group. If choosing hybrid search, the results will be re-ranked using BAAI/bge-reranker-large.
         * @summary Search Within Group
         * @param {string} tRDataset The dataset id to use for the request
         * @param {SearchWithinGroupData} searchWithinGroupData JSON request payload to semantically search a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchWithinGroup(tRDataset: string, searchWithinGroupData: SearchWithinGroupData, options?: any): AxiosPromise<SearchWithinGroupResults> {
            return localVarFp.searchWithinGroup(tRDataset, searchWithinGroupData, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Group  Update a chunk_group. If you try to change the tracking_id to one that already exists, this operation will fail.
         * @summary Update Group
         * @param {string} tRDataset The dataset id to use for the request
         * @param {UpdateChunkGroupData} updateChunkGroupData JSON request payload to update a chunkGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChunkGroup(tRDataset: string, updateChunkGroupData: UpdateChunkGroupData, options?: any): AxiosPromise<void> {
            return localVarFp.updateChunkGroup(tRDataset, updateChunkGroupData, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Group by Tracking ID  Update a chunk_group with the given tracking id.
         * @summary Update Group by Tracking ID
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} trackingId Tracking id of the chunk_group to update
         * @param {UpdateGroupByTrackingIDData} updateGroupByTrackingIDData JSON request payload to update a chunkGroup
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateGroupByTrackingId(tRDataset: string, trackingId: string, updateGroupByTrackingIDData: UpdateGroupByTrackingIDData, options?: any): AxiosPromise<void> {
            return localVarFp.updateGroupByTrackingId(tRDataset, trackingId, updateGroupByTrackingIDData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChunkGroupApi - object-oriented interface
 * @export
 * @class ChunkGroupApi
 * @extends {BaseAPI}
 */
export class ChunkGroupApi extends BaseAPI {
    /**
     * Add Chunk to Group  Route to add a chunk to a group.
     * @summary Add Chunk to Group
     * @param {string} tRDataset The dataset id to use for the request
     * @param {string} groupId Id of the group to add the chunk to as a bookmark
     * @param {AddChunkToGroupData} addChunkToGroupData JSON request payload to add a chunk to a group (bookmark it)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public addChunkToGroup(tRDataset: string, groupId: string, addChunkToGroupData: AddChunkToGroupData, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).addChunkToGroup(tRDataset, groupId, addChunkToGroupData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add Chunk to Group by Tracking ID  Route to add a chunk to a group by tracking id.
     * @summary Add Chunk to Group by Tracking ID
     * @param {string} tRDataset The dataset id to use for the request
     * @param {string} trackingId Id of the group to add the chunk to as a bookmark
     * @param {AddChunkToGroupData} addChunkToGroupData JSON request payload to add a chunk to a group (bookmark it)
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public addChunkToGroupByTrackingId(tRDataset: string, trackingId: string, addChunkToGroupData: AddChunkToGroupData, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).addChunkToGroupByTrackingId(tRDataset, trackingId, addChunkToGroupData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create Chunk Group  Create a new chunk_group. This is a way to group chunks together. If you try to create a chunk_group with the same tracking_id as an existing chunk_group, this operation will fail.
     * @summary Create Chunk Group
     * @param {string} tRDataset The dataset id to use for the request
     * @param {CreateChunkGroupData} createChunkGroupData JSON request payload to cretea a chunkGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public createChunkGroup(tRDataset: string, createChunkGroupData: CreateChunkGroupData, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).createChunkGroup(tRDataset, createChunkGroupData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Group  This will delete a chunk_group. If you set delete_chunks to true, it will also delete the chunks within the group.
     * @summary Delete Group
     * @param {string} tRDataset The dataset id to use for the request
     * @param {string} groupId Id of the group you want to fetch.
     * @param {boolean} deleteChunks Delete the chunks within the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public deleteChunkGroup(tRDataset: string, groupId: string, deleteChunks: boolean, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).deleteChunkGroup(tRDataset, groupId, deleteChunks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Group by Tracking ID  Delete a chunk_group with the given tracking id.
     * @summary Delete Group by Tracking ID
     * @param {string} tRDataset The dataset id to use for the request
     * @param {string} trackingId Tracking id of the chunk_group to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public deleteGroupByTrackingId(tRDataset: string, trackingId: string, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).deleteGroupByTrackingId(tRDataset, trackingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Group  Fetch the group with the given id. get_group
     * @summary Get Group
     * @param {string} tRDataset The dataset id to use for the request
     * @param {string} groupId Id of the group you want to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public getChunkGroup(tRDataset: string, groupId: string, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).getChunkGroup(tRDataset, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Chunks in Group  Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Page is 1-indexed.
     * @summary Get Chunks in Group
     * @param {string} tRDataset The dataset id to use for the request
     * @param {string} groupId Id of the group you want to fetch.
     * @param {number | null} page The page of chunks to get from the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public getChunksInGroup(tRDataset: string, groupId: string, page: number | null, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).getChunksInGroup(tRDataset, groupId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Chunks in Group by Tracking ID  Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Support for custom page size is coming soon. Page is 1-indexed.
     * @summary Get Chunks in Group by Tracking ID
     * @param {string} tRDataset The dataset id to use for the request
     * @param {string} groupTrackingId The id of the group to get the chunks from
     * @param {number} page The page of chunks to get from the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public getChunksInGroupByTrackingId(tRDataset: string, groupTrackingId: string, page: number, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).getChunksInGroupByTrackingId(tRDataset, groupTrackingId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Group by Tracking ID  Fetch the group with the given tracking id. get_group_by_tracking_id
     * @summary Get Group by Tracking ID
     * @param {string} tRDataset The dataset id to use for the request
     * @param {string} trackingId The tracking id of the group to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public getGroupByTrackingId(tRDataset: string, trackingId: string, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).getGroupByTrackingId(tRDataset, trackingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Groups for Chunks  Route to get the groups that a chunk is in.
     * @summary Get Groups for Chunks
     * @param {string} tRDataset The dataset id to use for the request
     * @param {GetGroupsForChunksData} getGroupsForChunksData JSON request payload to get the groups that a chunk is in
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public getGroupsChunkIsIn(tRDataset: string, getGroupsForChunksData: GetGroupsForChunksData, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).getGroupsChunkIsIn(tRDataset, getGroupsForChunksData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Recommended Groups  Route to get recommended groups. This route will return groups which are similar to the groups in the request body.
     * @summary Get Recommended Groups
     * @param {string} tRDataset The dataset id to use for the request
     * @param {RecommendGroupChunksRequest} recommendGroupChunksRequest JSON request payload to get recommendations of chunks similar to the chunks in the request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public getRecommendedGroups(tRDataset: string, recommendGroupChunksRequest: RecommendGroupChunksRequest, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).getRecommendedGroups(tRDataset, recommendGroupChunksRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Groups for Dataset  Fetch the groups which belong to a dataset specified by its id.
     * @summary Get Groups for Dataset
     * @param {string} tRDataset The dataset id to use for the request
     * @param {string} datasetId The id of the dataset to fetch groups for.
     * @param {number} page The page of groups to fetch. Page is 1-indexed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public getSpecificDatasetChunkGroups(tRDataset: string, datasetId: string, page: number, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).getSpecificDatasetChunkGroups(tRDataset, datasetId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove Chunk from Group  Route to remove a chunk from a group.
     * @summary Remove Chunk from Group
     * @param {string} tRDataset The dataset id to use for the request
     * @param {string} groupId Id of the group to remove the bookmark\&#39;ed chunk from
     * @param {CreateChunkGroupData} createChunkGroupData JSON request payload to cretea a chunkGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public removeChunkFromGroup(tRDataset: string, groupId: string, createChunkGroupData: CreateChunkGroupData, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).removeChunkFromGroup(tRDataset, groupId, createChunkGroupData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search Over Groups  This route allows you to get groups as results instead of chunks. Each group returned will have the matching chunks sorted by similarity within the group. This is useful for when you want to get groups of chunks which are similar to the search query. If choosing hybrid search, the results will be re-ranked using BAAI/bge-reranker-large. Compatible with semantic, fulltext, or hybrid search modes.
     * @summary Search Over Groups
     * @param {string} tRDataset The dataset id to use for the request
     * @param {SearchOverGroupsData} searchOverGroupsData JSON request payload to semantically search over groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public searchOverGroups(tRDataset: string, searchOverGroupsData: SearchOverGroupsData, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).searchOverGroups(tRDataset, searchOverGroupsData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search Within Group  This route allows you to search only within a group. This is useful for when you only want search results to contain chunks which are members of a specific group. If choosing hybrid search, the results will be re-ranked using BAAI/bge-reranker-large.
     * @summary Search Within Group
     * @param {string} tRDataset The dataset id to use for the request
     * @param {SearchWithinGroupData} searchWithinGroupData JSON request payload to semantically search a group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public searchWithinGroup(tRDataset: string, searchWithinGroupData: SearchWithinGroupData, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).searchWithinGroup(tRDataset, searchWithinGroupData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Group  Update a chunk_group. If you try to change the tracking_id to one that already exists, this operation will fail.
     * @summary Update Group
     * @param {string} tRDataset The dataset id to use for the request
     * @param {UpdateChunkGroupData} updateChunkGroupData JSON request payload to update a chunkGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public updateChunkGroup(tRDataset: string, updateChunkGroupData: UpdateChunkGroupData, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).updateChunkGroup(tRDataset, updateChunkGroupData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Group by Tracking ID  Update a chunk_group with the given tracking id.
     * @summary Update Group by Tracking ID
     * @param {string} tRDataset The dataset id to use for the request
     * @param {string} trackingId Tracking id of the chunk_group to update
     * @param {UpdateGroupByTrackingIDData} updateGroupByTrackingIDData JSON request payload to update a chunkGroup
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ChunkGroupApi
     */
    public updateGroupByTrackingId(tRDataset: string, trackingId: string, updateGroupByTrackingIDData: UpdateGroupByTrackingIDData, options?: RawAxiosRequestConfig) {
        return ChunkGroupApiFp(this.configuration).updateGroupByTrackingId(tRDataset, trackingId, updateGroupByTrackingIDData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DatasetApi - axios parameter creator
 * @export
 */
export const DatasetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create dataset  Create a new dataset. The auth\'ed user must be an owner of the organization to create a dataset.
         * @summary Create dataset
         * @param {string} tROrganization The organization id to use for the request
         * @param {CreateDatasetRequest} createDatasetRequest JSON request payload to create a new dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataset: async (tROrganization: string, createDatasetRequest: CreateDatasetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('createDataset', 'tROrganization', tROrganization)
            // verify required parameter 'createDatasetRequest' is not null or undefined
            assertParamExists('createDataset', 'createDatasetRequest', createDatasetRequest)
            const localVarPath = `/api/dataset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDatasetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Dataset  Delete a dataset. The auth\'ed user must be an owner of the organization to delete a dataset.
         * @summary Delete Dataset
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} datasetId The id of the dataset you want to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataset: async (tRDataset: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('deleteDataset', 'tRDataset', tRDataset)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('deleteDataset', 'datasetId', datasetId)
            const localVarPath = `/api/dataset/{dataset_id}`
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Client Configuration  Get the client configuration for a dataset. Will use the TR-D
         * @summary Get Client Configuration
         * @param {string} tRDataset The dataset id to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientDatasetConfig: async (tRDataset: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getClientDatasetConfig', 'tRDataset', tRDataset)
            const localVarPath = `/api/dataset/envs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Dataset  Get a dataset by id. The auth\'ed user must be an admin or owner of the organization to get a dataset.
         * @summary Get Dataset
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} datasetId The id of the dataset you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataset: async (tROrganization: string, tRDataset: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('getDataset', 'tROrganization', tROrganization)
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getDataset', 'tRDataset', tRDataset)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getDataset', 'datasetId', datasetId)
            const localVarPath = `/api/dataset/{dataset_id}`
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Datasets from Organization  Get all datasets for an organization. The auth\'ed user must be an admin or owner of the organization to get its datasets.
         * @summary Get Datasets from Organization
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId id of the organization you want to retrieve datasets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetsFromOrganization: async (tROrganization: string, organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('getDatasetsFromOrganization', 'tROrganization', tROrganization)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getDatasetsFromOrganization', 'organizationId', organizationId)
            const localVarPath = `/api/dataset/organization/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Dataset  Update a dataset. The auth\'ed user must be an owner of the organization to update a dataset.
         * @summary Update Dataset
         * @param {string} tROrganization The organization id to use for the request
         * @param {UpdateDatasetRequest} updateDatasetRequest JSON request payload to update a dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataset: async (tROrganization: string, updateDatasetRequest: UpdateDatasetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('updateDataset', 'tROrganization', tROrganization)
            // verify required parameter 'updateDatasetRequest' is not null or undefined
            assertParamExists('updateDataset', 'updateDatasetRequest', updateDatasetRequest)
            const localVarPath = `/api/dataset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDatasetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatasetApi - functional programming interface
 * @export
 */
export const DatasetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatasetApiAxiosParamCreator(configuration)
    return {
        /**
         * Create dataset  Create a new dataset. The auth\'ed user must be an owner of the organization to create a dataset.
         * @summary Create dataset
         * @param {string} tROrganization The organization id to use for the request
         * @param {CreateDatasetRequest} createDatasetRequest JSON request payload to create a new dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDataset(tROrganization: string, createDatasetRequest: CreateDatasetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDataset(tROrganization, createDatasetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.createDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Dataset  Delete a dataset. The auth\'ed user must be an owner of the organization to delete a dataset.
         * @summary Delete Dataset
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} datasetId The id of the dataset you want to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDataset(tRDataset: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDataset(tRDataset, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.deleteDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Client Configuration  Get the client configuration for a dataset. Will use the TR-D
         * @summary Get Client Configuration
         * @param {string} tRDataset The dataset id to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientDatasetConfig(tRDataset: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientDatasetConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClientDatasetConfig(tRDataset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getClientDatasetConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Dataset  Get a dataset by id. The auth\'ed user must be an admin or owner of the organization to get a dataset.
         * @summary Get Dataset
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} datasetId The id of the dataset you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataset(tROrganization: string, tRDataset: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataset(tROrganization, tRDataset, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Datasets from Organization  Get all datasets for an organization. The auth\'ed user must be an admin or owner of the organization to get its datasets.
         * @summary Get Datasets from Organization
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId id of the organization you want to retrieve datasets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatasetsFromOrganization(tROrganization: string, organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DatasetAndUsage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatasetsFromOrganization(tROrganization, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getDatasetsFromOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Dataset  Update a dataset. The auth\'ed user must be an owner of the organization to update a dataset.
         * @summary Update Dataset
         * @param {string} tROrganization The organization id to use for the request
         * @param {UpdateDatasetRequest} updateDatasetRequest JSON request payload to update a dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDataset(tROrganization: string, updateDatasetRequest: UpdateDatasetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDataset(tROrganization, updateDatasetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.updateDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DatasetApi - factory interface
 * @export
 */
export const DatasetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatasetApiFp(configuration)
    return {
        /**
         * Create dataset  Create a new dataset. The auth\'ed user must be an owner of the organization to create a dataset.
         * @summary Create dataset
         * @param {string} tROrganization The organization id to use for the request
         * @param {CreateDatasetRequest} createDatasetRequest JSON request payload to create a new dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataset(tROrganization: string, createDatasetRequest: CreateDatasetRequest, options?: any): AxiosPromise<Dataset> {
            return localVarFp.createDataset(tROrganization, createDatasetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Dataset  Delete a dataset. The auth\'ed user must be an owner of the organization to delete a dataset.
         * @summary Delete Dataset
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} datasetId The id of the dataset you want to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataset(tRDataset: string, datasetId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDataset(tRDataset, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Client Configuration  Get the client configuration for a dataset. Will use the TR-D
         * @summary Get Client Configuration
         * @param {string} tRDataset The dataset id to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientDatasetConfig(tRDataset: string, options?: any): AxiosPromise<ClientDatasetConfiguration> {
            return localVarFp.getClientDatasetConfig(tRDataset, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Dataset  Get a dataset by id. The auth\'ed user must be an admin or owner of the organization to get a dataset.
         * @summary Get Dataset
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} datasetId The id of the dataset you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataset(tROrganization: string, tRDataset: string, datasetId: string, options?: any): AxiosPromise<Dataset> {
            return localVarFp.getDataset(tROrganization, tRDataset, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Datasets from Organization  Get all datasets for an organization. The auth\'ed user must be an admin or owner of the organization to get its datasets.
         * @summary Get Datasets from Organization
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId id of the organization you want to retrieve datasets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetsFromOrganization(tROrganization: string, organizationId: string, options?: any): AxiosPromise<Array<DatasetAndUsage>> {
            return localVarFp.getDatasetsFromOrganization(tROrganization, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Dataset  Update a dataset. The auth\'ed user must be an owner of the organization to update a dataset.
         * @summary Update Dataset
         * @param {string} tROrganization The organization id to use for the request
         * @param {UpdateDatasetRequest} updateDatasetRequest JSON request payload to update a dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataset(tROrganization: string, updateDatasetRequest: UpdateDatasetRequest, options?: any): AxiosPromise<Dataset> {
            return localVarFp.updateDataset(tROrganization, updateDatasetRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatasetApi - object-oriented interface
 * @export
 * @class DatasetApi
 * @extends {BaseAPI}
 */
export class DatasetApi extends BaseAPI {
    /**
     * Create dataset  Create a new dataset. The auth\'ed user must be an owner of the organization to create a dataset.
     * @summary Create dataset
     * @param {string} tROrganization The organization id to use for the request
     * @param {CreateDatasetRequest} createDatasetRequest JSON request payload to create a new dataset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public createDataset(tROrganization: string, createDatasetRequest: CreateDatasetRequest, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).createDataset(tROrganization, createDatasetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Dataset  Delete a dataset. The auth\'ed user must be an owner of the organization to delete a dataset.
     * @summary Delete Dataset
     * @param {string} tRDataset The dataset id to use for the request
     * @param {string} datasetId The id of the dataset you want to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public deleteDataset(tRDataset: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).deleteDataset(tRDataset, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Client Configuration  Get the client configuration for a dataset. Will use the TR-D
     * @summary Get Client Configuration
     * @param {string} tRDataset The dataset id to use for the request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getClientDatasetConfig(tRDataset: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getClientDatasetConfig(tRDataset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Dataset  Get a dataset by id. The auth\'ed user must be an admin or owner of the organization to get a dataset.
     * @summary Get Dataset
     * @param {string} tROrganization The organization id to use for the request
     * @param {string} tRDataset The dataset id to use for the request
     * @param {string} datasetId The id of the dataset you want to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getDataset(tROrganization: string, tRDataset: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getDataset(tROrganization, tRDataset, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Datasets from Organization  Get all datasets for an organization. The auth\'ed user must be an admin or owner of the organization to get its datasets.
     * @summary Get Datasets from Organization
     * @param {string} tROrganization The organization id to use for the request
     * @param {string} organizationId id of the organization you want to retrieve datasets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getDatasetsFromOrganization(tROrganization: string, organizationId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getDatasetsFromOrganization(tROrganization, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Dataset  Update a dataset. The auth\'ed user must be an owner of the organization to update a dataset.
     * @summary Update Dataset
     * @param {string} tROrganization The organization id to use for the request
     * @param {UpdateDatasetRequest} updateDatasetRequest JSON request payload to update a dataset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public updateDataset(tROrganization: string, updateDatasetRequest: UpdateDatasetRequest, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).updateDataset(tROrganization, updateDatasetRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get events for the dataset  Get events for the dataset specified by the TR-Dataset header.
         * @summary Get events for the dataset
         * @param {string} tRDataset The dataset id to use for the request
         * @param {GetEventsData} getEventsData JSON request payload to get events for a dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (tRDataset: string, getEventsData: GetEventsData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getEvents', 'tRDataset', tRDataset)
            // verify required parameter 'getEventsData' is not null or undefined
            assertParamExists('getEvents', 'getEventsData', getEventsData)
            const localVarPath = `/api/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEventsData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get events for the dataset  Get events for the dataset specified by the TR-Dataset header.
         * @summary Get events for the dataset
         * @param {string} tRDataset The dataset id to use for the request
         * @param {GetEventsData} getEventsData JSON request payload to get events for a dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(tRDataset: string, getEventsData: GetEventsData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(tRDataset, getEventsData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.getEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * Get events for the dataset  Get events for the dataset specified by the TR-Dataset header.
         * @summary Get events for the dataset
         * @param {string} tRDataset The dataset id to use for the request
         * @param {GetEventsData} getEventsData JSON request payload to get events for a dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(tRDataset: string, getEventsData: GetEventsData, options?: any): AxiosPromise<EventReturn> {
            return localVarFp.getEvents(tRDataset, getEventsData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * Get events for the dataset  Get events for the dataset specified by the TR-Dataset header.
     * @summary Get events for the dataset
     * @param {string} tRDataset The dataset id to use for the request
     * @param {GetEventsData} getEventsData JSON request payload to get events for a dataset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEvents(tRDataset: string, getEventsData: GetEventsData, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEvents(tRDataset, getEventsData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FileApi - axios parameter creator
 * @export
 */
export const FileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete File  Delete a file from S3 attached to the server based on its id. This will disassociate chunks from the file, but only delete them all together if you specify delete_chunks to be true. Auth\'ed user must be an admin or owner of the dataset\'s organization to delete a file.
         * @summary Delete File
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} fileId The id of the file to delete
         * @param {boolean} deleteChunks Whether or not to delete the chunks associated with the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileHandler: async (tRDataset: string, fileId: string, deleteChunks: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('deleteFileHandler', 'tRDataset', tRDataset)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('deleteFileHandler', 'fileId', fileId)
            // verify required parameter 'deleteChunks' is not null or undefined
            assertParamExists('deleteFileHandler', 'deleteChunks', deleteChunks)
            const localVarPath = `/api/file/{file_id}`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (deleteChunks !== undefined) {
                localVarQueryParameter['delete_chunks'] = deleteChunks;
            }

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Files for Dataset  Get all files which belong to a given dataset specified by the dataset_id parameter. 10 files are returned per page.
         * @summary Get Files for Dataset
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} datasetId The id of the dataset to fetch files for.
         * @param {number} page The page number of files you wish to fetch. Each page contains at most 10 files.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetFilesHandler: async (tRDataset: string, datasetId: string, page: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getDatasetFilesHandler', 'tRDataset', tRDataset)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getDatasetFilesHandler', 'datasetId', datasetId)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getDatasetFilesHandler', 'page', page)
            const localVarPath = `/api/dataset/files/{dataset_id}/{page}`
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"page"}}`, encodeURIComponent(String(page)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get File  Download a file based on its id.
         * @summary Get File
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} fileId The id of the file to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileHandler: async (tRDataset: string, fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getFileHandler', 'tRDataset', tRDataset)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFileHandler', 'fileId', fileId)
            const localVarPath = `/api/file/{file_id}`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload File  Upload a file to S3 attached to the server. The file will be converted to HTML with tika and chunked algorithmically, images will be OCR\'ed with tesseract. The resulting chunks will be indexed and searchable. Optionally, you can only upload the file and manually create chunks associated to the file after. See docs.trieve.ai and/or contact us for more details and tips. Auth\'ed user must be an admin or owner of the dataset\'s organization to upload a file.
         * @summary Upload File
         * @param {string} tRDataset The dataset id to use for the request
         * @param {UploadFileData} uploadFileData JSON request payload to upload a file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileHandler: async (tRDataset: string, uploadFileData: UploadFileData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('uploadFileHandler', 'tRDataset', tRDataset)
            // verify required parameter 'uploadFileData' is not null or undefined
            assertParamExists('uploadFileHandler', 'uploadFileData', uploadFileData)
            const localVarPath = `/api/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadFileData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileApi - functional programming interface
 * @export
 */
export const FileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete File  Delete a file from S3 attached to the server based on its id. This will disassociate chunks from the file, but only delete them all together if you specify delete_chunks to be true. Auth\'ed user must be an admin or owner of the dataset\'s organization to delete a file.
         * @summary Delete File
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} fileId The id of the file to delete
         * @param {boolean} deleteChunks Whether or not to delete the chunks associated with the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFileHandler(tRDataset: string, fileId: string, deleteChunks: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFileHandler(tRDataset, fileId, deleteChunks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.deleteFileHandler']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Files for Dataset  Get all files which belong to a given dataset specified by the dataset_id parameter. 10 files are returned per page.
         * @summary Get Files for Dataset
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} datasetId The id of the dataset to fetch files for.
         * @param {number} page The page number of files you wish to fetch. Each page contains at most 10 files.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatasetFilesHandler(tRDataset: string, datasetId: string, page: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatasetFilesHandler(tRDataset, datasetId, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.getDatasetFilesHandler']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get File  Download a file based on its id.
         * @summary Get File
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} fileId The id of the file to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileHandler(tRDataset: string, fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileHandler(tRDataset, fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.getFileHandler']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload File  Upload a file to S3 attached to the server. The file will be converted to HTML with tika and chunked algorithmically, images will be OCR\'ed with tesseract. The resulting chunks will be indexed and searchable. Optionally, you can only upload the file and manually create chunks associated to the file after. See docs.trieve.ai and/or contact us for more details and tips. Auth\'ed user must be an admin or owner of the dataset\'s organization to upload a file.
         * @summary Upload File
         * @param {string} tRDataset The dataset id to use for the request
         * @param {UploadFileData} uploadFileData JSON request payload to upload a file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFileHandler(tRDataset: string, uploadFileData: UploadFileData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadFileResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFileHandler(tRDataset, uploadFileData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.uploadFileHandler']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FileApi - factory interface
 * @export
 */
export const FileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileApiFp(configuration)
    return {
        /**
         * Delete File  Delete a file from S3 attached to the server based on its id. This will disassociate chunks from the file, but only delete them all together if you specify delete_chunks to be true. Auth\'ed user must be an admin or owner of the dataset\'s organization to delete a file.
         * @summary Delete File
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} fileId The id of the file to delete
         * @param {boolean} deleteChunks Whether or not to delete the chunks associated with the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileHandler(tRDataset: string, fileId: string, deleteChunks: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFileHandler(tRDataset, fileId, deleteChunks, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Files for Dataset  Get all files which belong to a given dataset specified by the dataset_id parameter. 10 files are returned per page.
         * @summary Get Files for Dataset
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} datasetId The id of the dataset to fetch files for.
         * @param {number} page The page number of files you wish to fetch. Each page contains at most 10 files.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetFilesHandler(tRDataset: string, datasetId: string, page: number, options?: any): AxiosPromise<Array<any>> {
            return localVarFp.getDatasetFilesHandler(tRDataset, datasetId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Get File  Download a file based on its id.
         * @summary Get File
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} fileId The id of the file to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileHandler(tRDataset: string, fileId: string, options?: any): AxiosPromise<FileDTO> {
            return localVarFp.getFileHandler(tRDataset, fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload File  Upload a file to S3 attached to the server. The file will be converted to HTML with tika and chunked algorithmically, images will be OCR\'ed with tesseract. The resulting chunks will be indexed and searchable. Optionally, you can only upload the file and manually create chunks associated to the file after. See docs.trieve.ai and/or contact us for more details and tips. Auth\'ed user must be an admin or owner of the dataset\'s organization to upload a file.
         * @summary Upload File
         * @param {string} tRDataset The dataset id to use for the request
         * @param {UploadFileData} uploadFileData JSON request payload to upload a file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileHandler(tRDataset: string, uploadFileData: UploadFileData, options?: any): AxiosPromise<UploadFileResult> {
            return localVarFp.uploadFileHandler(tRDataset, uploadFileData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
export class FileApi extends BaseAPI {
    /**
     * Delete File  Delete a file from S3 attached to the server based on its id. This will disassociate chunks from the file, but only delete them all together if you specify delete_chunks to be true. Auth\'ed user must be an admin or owner of the dataset\'s organization to delete a file.
     * @summary Delete File
     * @param {string} tRDataset The dataset id to use for the request
     * @param {string} fileId The id of the file to delete
     * @param {boolean} deleteChunks Whether or not to delete the chunks associated with the file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public deleteFileHandler(tRDataset: string, fileId: string, deleteChunks: boolean, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).deleteFileHandler(tRDataset, fileId, deleteChunks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Files for Dataset  Get all files which belong to a given dataset specified by the dataset_id parameter. 10 files are returned per page.
     * @summary Get Files for Dataset
     * @param {string} tRDataset The dataset id to use for the request
     * @param {string} datasetId The id of the dataset to fetch files for.
     * @param {number} page The page number of files you wish to fetch. Each page contains at most 10 files.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public getDatasetFilesHandler(tRDataset: string, datasetId: string, page: number, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).getDatasetFilesHandler(tRDataset, datasetId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get File  Download a file based on its id.
     * @summary Get File
     * @param {string} tRDataset The dataset id to use for the request
     * @param {string} fileId The id of the file to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public getFileHandler(tRDataset: string, fileId: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).getFileHandler(tRDataset, fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload File  Upload a file to S3 attached to the server. The file will be converted to HTML with tika and chunked algorithmically, images will be OCR\'ed with tesseract. The resulting chunks will be indexed and searchable. Optionally, you can only upload the file and manually create chunks associated to the file after. See docs.trieve.ai and/or contact us for more details and tips. Auth\'ed user must be an admin or owner of the dataset\'s organization to upload a file.
     * @summary Upload File
     * @param {string} tRDataset The dataset id to use for the request
     * @param {UploadFileData} uploadFileData JSON request payload to upload a file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public uploadFileHandler(tRDataset: string, uploadFileData: UploadFileData, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).uploadFileHandler(tRDataset, uploadFileData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Health Check  Confirmation that the service is healthy and can make embedding vectors
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * Health Check  Confirmation that the service is healthy and can make embedding vectors
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * Health Check  Confirmation that the service is healthy and can make embedding vectors
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(options?: any): AxiosPromise<void> {
            return localVarFp.healthCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * Health Check  Confirmation that the service is healthy and can make embedding vectors
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public healthCheck(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthCheck(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InvitationApi - axios parameter creator
 * @export
 */
export const InvitationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Send Invitation  Invitations act as a way to invite users to join an organization. After a user is invited, they will automatically be added to the organization with the role specified in the invitation once they set their.
         * @summary Send Invitation
         * @param {string} tROrganization The organization id to use for the request
         * @param {InvitationData} invitationData JSON request payload to send an invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInvitation: async (tROrganization: string, invitationData: InvitationData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('postInvitation', 'tROrganization', tROrganization)
            // verify required parameter 'invitationData' is not null or undefined
            assertParamExists('postInvitation', 'invitationData', invitationData)
            const localVarPath = `/api/invitation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invitationData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvitationApi - functional programming interface
 * @export
 */
export const InvitationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvitationApiAxiosParamCreator(configuration)
    return {
        /**
         * Send Invitation  Invitations act as a way to invite users to join an organization. After a user is invited, they will automatically be added to the organization with the role specified in the invitation once they set their.
         * @summary Send Invitation
         * @param {string} tROrganization The organization id to use for the request
         * @param {InvitationData} invitationData JSON request payload to send an invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postInvitation(tROrganization: string, invitationData: InvitationData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInvitation(tROrganization, invitationData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitationApi.postInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InvitationApi - factory interface
 * @export
 */
export const InvitationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvitationApiFp(configuration)
    return {
        /**
         * Send Invitation  Invitations act as a way to invite users to join an organization. After a user is invited, they will automatically be added to the organization with the role specified in the invitation once they set their.
         * @summary Send Invitation
         * @param {string} tROrganization The organization id to use for the request
         * @param {InvitationData} invitationData JSON request payload to send an invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInvitation(tROrganization: string, invitationData: InvitationData, options?: any): AxiosPromise<void> {
            return localVarFp.postInvitation(tROrganization, invitationData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvitationApi - object-oriented interface
 * @export
 * @class InvitationApi
 * @extends {BaseAPI}
 */
export class InvitationApi extends BaseAPI {
    /**
     * Send Invitation  Invitations act as a way to invite users to join an organization. After a user is invited, they will automatically be added to the organization with the role specified in the invitation once they set their.
     * @summary Send Invitation
     * @param {string} tROrganization The organization id to use for the request
     * @param {InvitationData} invitationData JSON request payload to send an invitation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public postInvitation(tROrganization: string, invitationData: InvitationData, options?: RawAxiosRequestConfig) {
        return InvitationApiFp(this.configuration).postInvitation(tROrganization, invitationData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MessageApi - axios parameter creator
 * @export
 */
export const MessageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a message  Create a message. Messages are attached to topics in order to coordinate memory of gen-AI chat sessions. We are considering refactoring this resource of the API soon. Currently, you can only send user messages. If the topic is a RAG topic then the response will include Chunks first on the stream. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
         * @summary Create a message
         * @param {string} tRDataset The dataset id to use for the request
         * @param {CreateMessageData} createMessageData JSON request payload to create a message completion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessageCompletionHandler: async (tRDataset: string, createMessageData: CreateMessageData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('createMessageCompletionHandler', 'tRDataset', tRDataset)
            // verify required parameter 'createMessageData' is not null or undefined
            assertParamExists('createMessageCompletionHandler', 'createMessageData', createMessageData)
            const localVarPath = `/api/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMessageData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a message  Edit a message which exists within the topic\'s chat history. This will delete the message and replace it with a new message. The new message will be generated by the AI based on the new content provided in the request body. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
         * @summary Edit a message
         * @param {string} tRDataset The dataset id to use for the request
         * @param {EditMessageData} editMessageData JSON request payload to edit a message and get a new stream
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMessageHandler: async (tRDataset: string, editMessageData: EditMessageData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('editMessageHandler', 'tRDataset', tRDataset)
            // verify required parameter 'editMessageData' is not null or undefined
            assertParamExists('editMessageHandler', 'editMessageData', editMessageData)
            const localVarPath = `/api/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editMessageData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all messages for a given topic  Get all messages for a given topic. If the topic is a RAG topic then the response will include Chunks first on each message. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
         * @summary Get all messages for a given topic
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} messagesTopicId The ID of the topic to get messages for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTopicMessages: async (tRDataset: string, messagesTopicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getAllTopicMessages', 'tRDataset', tRDataset)
            // verify required parameter 'messagesTopicId' is not null or undefined
            assertParamExists('getAllTopicMessages', 'messagesTopicId', messagesTopicId)
            const localVarPath = `/api/messages/{messages_topic_id}`
                .replace(`{${"messages_topic_id"}}`, encodeURIComponent(String(messagesTopicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Regenerate message  Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
         * @summary Regenerate message
         * @param {string} tRDataset The dataset id to use for the request
         * @param {RegenerateMessageData} regenerateMessageData JSON request payload to delete an agent message then regenerate it in a strem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateMessageHandler: async (tRDataset: string, regenerateMessageData: RegenerateMessageData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('regenerateMessageHandler', 'tRDataset', tRDataset)
            // verify required parameter 'regenerateMessageData' is not null or undefined
            assertParamExists('regenerateMessageHandler', 'regenerateMessageData', regenerateMessageData)
            const localVarPath = `/api/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regenerateMessageData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessageApi - functional programming interface
 * @export
 */
export const MessageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessageApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a message  Create a message. Messages are attached to topics in order to coordinate memory of gen-AI chat sessions. We are considering refactoring this resource of the API soon. Currently, you can only send user messages. If the topic is a RAG topic then the response will include Chunks first on the stream. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
         * @summary Create a message
         * @param {string} tRDataset The dataset id to use for the request
         * @param {CreateMessageData} createMessageData JSON request payload to create a message completion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMessageCompletionHandler(tRDataset: string, createMessageData: CreateMessageData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMessageCompletionHandler(tRDataset, createMessageData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessageApi.createMessageCompletionHandler']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit a message  Edit a message which exists within the topic\'s chat history. This will delete the message and replace it with a new message. The new message will be generated by the AI based on the new content provided in the request body. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
         * @summary Edit a message
         * @param {string} tRDataset The dataset id to use for the request
         * @param {EditMessageData} editMessageData JSON request payload to edit a message and get a new stream
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editMessageHandler(tRDataset: string, editMessageData: EditMessageData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editMessageHandler(tRDataset, editMessageData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessageApi.editMessageHandler']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all messages for a given topic  Get all messages for a given topic. If the topic is a RAG topic then the response will include Chunks first on each message. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
         * @summary Get all messages for a given topic
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} messagesTopicId The ID of the topic to get messages for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTopicMessages(tRDataset: string, messagesTopicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Message>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTopicMessages(tRDataset, messagesTopicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessageApi.getAllTopicMessages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Regenerate message  Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
         * @summary Regenerate message
         * @param {string} tRDataset The dataset id to use for the request
         * @param {RegenerateMessageData} regenerateMessageData JSON request payload to delete an agent message then regenerate it in a strem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regenerateMessageHandler(tRDataset: string, regenerateMessageData: RegenerateMessageData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regenerateMessageHandler(tRDataset, regenerateMessageData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessageApi.regenerateMessageHandler']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MessageApi - factory interface
 * @export
 */
export const MessageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessageApiFp(configuration)
    return {
        /**
         * Create a message  Create a message. Messages are attached to topics in order to coordinate memory of gen-AI chat sessions. We are considering refactoring this resource of the API soon. Currently, you can only send user messages. If the topic is a RAG topic then the response will include Chunks first on the stream. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
         * @summary Create a message
         * @param {string} tRDataset The dataset id to use for the request
         * @param {CreateMessageData} createMessageData JSON request payload to create a message completion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessageCompletionHandler(tRDataset: string, createMessageData: CreateMessageData, options?: any): AxiosPromise<string> {
            return localVarFp.createMessageCompletionHandler(tRDataset, createMessageData, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a message  Edit a message which exists within the topic\'s chat history. This will delete the message and replace it with a new message. The new message will be generated by the AI based on the new content provided in the request body. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
         * @summary Edit a message
         * @param {string} tRDataset The dataset id to use for the request
         * @param {EditMessageData} editMessageData JSON request payload to edit a message and get a new stream
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMessageHandler(tRDataset: string, editMessageData: EditMessageData, options?: any): AxiosPromise<void> {
            return localVarFp.editMessageHandler(tRDataset, editMessageData, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all messages for a given topic  Get all messages for a given topic. If the topic is a RAG topic then the response will include Chunks first on each message. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
         * @summary Get all messages for a given topic
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} messagesTopicId The ID of the topic to get messages for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTopicMessages(tRDataset: string, messagesTopicId: string, options?: any): AxiosPromise<Array<Message>> {
            return localVarFp.getAllTopicMessages(tRDataset, messagesTopicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Regenerate message  Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
         * @summary Regenerate message
         * @param {string} tRDataset The dataset id to use for the request
         * @param {RegenerateMessageData} regenerateMessageData JSON request payload to delete an agent message then regenerate it in a strem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateMessageHandler(tRDataset: string, regenerateMessageData: RegenerateMessageData, options?: any): AxiosPromise<string> {
            return localVarFp.regenerateMessageHandler(tRDataset, regenerateMessageData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessageApi - object-oriented interface
 * @export
 * @class MessageApi
 * @extends {BaseAPI}
 */
export class MessageApi extends BaseAPI {
    /**
     * Create a message  Create a message. Messages are attached to topics in order to coordinate memory of gen-AI chat sessions. We are considering refactoring this resource of the API soon. Currently, you can only send user messages. If the topic is a RAG topic then the response will include Chunks first on the stream. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
     * @summary Create a message
     * @param {string} tRDataset The dataset id to use for the request
     * @param {CreateMessageData} createMessageData JSON request payload to create a message completion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public createMessageCompletionHandler(tRDataset: string, createMessageData: CreateMessageData, options?: RawAxiosRequestConfig) {
        return MessageApiFp(this.configuration).createMessageCompletionHandler(tRDataset, createMessageData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a message  Edit a message which exists within the topic\'s chat history. This will delete the message and replace it with a new message. The new message will be generated by the AI based on the new content provided in the request body. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
     * @summary Edit a message
     * @param {string} tRDataset The dataset id to use for the request
     * @param {EditMessageData} editMessageData JSON request payload to edit a message and get a new stream
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public editMessageHandler(tRDataset: string, editMessageData: EditMessageData, options?: RawAxiosRequestConfig) {
        return MessageApiFp(this.configuration).editMessageHandler(tRDataset, editMessageData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all messages for a given topic  Get all messages for a given topic. If the topic is a RAG topic then the response will include Chunks first on each message. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
     * @summary Get all messages for a given topic
     * @param {string} tRDataset The dataset id to use for the request
     * @param {string} messagesTopicId The ID of the topic to get messages for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public getAllTopicMessages(tRDataset: string, messagesTopicId: string, options?: RawAxiosRequestConfig) {
        return MessageApiFp(this.configuration).getAllTopicMessages(tRDataset, messagesTopicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Regenerate message  Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
     * @summary Regenerate message
     * @param {string} tRDataset The dataset id to use for the request
     * @param {RegenerateMessageData} regenerateMessageData JSON request payload to delete an agent message then regenerate it in a strem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public regenerateMessageHandler(tRDataset: string, regenerateMessageData: RegenerateMessageData, options?: RawAxiosRequestConfig) {
        return MessageApiFp(this.configuration).regenerateMessageHandler(tRDataset, regenerateMessageData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create Organization  Create a new organization. The auth\'ed user who creates the organization will be the default owner of the organization.
         * @summary Create Organization
         * @param {CreateOrganizationData} createOrganizationData The organization data that you want to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization: async (createOrganizationData: CreateOrganizationData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrganizationData' is not null or undefined
            assertParamExists('createOrganization', 'createOrganizationData', createOrganizationData)
            const localVarPath = `/api/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrganizationData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Organization  Delete an organization by its id. The auth\'ed user must be an owner of the organization to delete it.
         * @summary Delete Organization
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The id of the organization you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationById: async (tROrganization: string, organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('deleteOrganizationById', 'tROrganization', tROrganization)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganizationById', 'organizationId', organizationId)
            const localVarPath = `/api/organization/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Organization  Fetch the details of an organization by its id. The auth\'ed user must be an admin or owner of the organization to fetch it.
         * @summary Get Organization
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The id of the organization you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationById: async (tROrganization: string, organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('getOrganizationById', 'tROrganization', tROrganization)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationById', 'organizationId', organizationId)
            const localVarPath = `/api/organization/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Organization Usage  Fetch the current usage specification of an organization by its id. The auth\'ed user must be an admin or owner of the organization to fetch it.
         * @summary Get Organization Usage
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The id of the organization you want to fetch the usage of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUsage: async (tROrganization: string, organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('getOrganizationUsage', 'tROrganization', tROrganization)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationUsage', 'organizationId', organizationId)
            const localVarPath = `/api/organization/usage/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Organization Users  Fetch the users of an organization by its id. The auth\'ed user must be an admin or owner of the organization to fetch it.
         * @summary Get Organization Users
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The id of the organization you want to fetch the users of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUsers: async (tROrganization: string, organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('getOrganizationUsers', 'tROrganization', tROrganization)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationUsers', 'organizationId', organizationId)
            const localVarPath = `/api/organization/users/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Organization  Update an organization. Only the owner of the organization can update it.
         * @summary Update Organization
         * @param {string} tROrganization The organization id to use for the request
         * @param {UpdateOrganizationData} updateOrganizationData The organization data that you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization: async (tROrganization: string, updateOrganizationData: UpdateOrganizationData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('updateOrganization', 'tROrganization', tROrganization)
            // verify required parameter 'updateOrganizationData' is not null or undefined
            assertParamExists('updateOrganization', 'updateOrganizationData', updateOrganizationData)
            const localVarPath = `/api/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrganizationData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * Create Organization  Create a new organization. The auth\'ed user who creates the organization will be the default owner of the organization.
         * @summary Create Organization
         * @param {CreateOrganizationData} createOrganizationData The organization data that you want to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganization(createOrganizationData: CreateOrganizationData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganization(createOrganizationData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.createOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Organization  Delete an organization by its id. The auth\'ed user must be an owner of the organization to delete it.
         * @summary Delete Organization
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The id of the organization you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationById(tROrganization: string, organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationById(tROrganization, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.deleteOrganizationById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Organization  Fetch the details of an organization by its id. The auth\'ed user must be an admin or owner of the organization to fetch it.
         * @summary Get Organization
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The id of the organization you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationById(tROrganization: string, organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationById(tROrganization, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getOrganizationById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Organization Usage  Fetch the current usage specification of an organization by its id. The auth\'ed user must be an admin or owner of the organization to fetch it.
         * @summary Get Organization Usage
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The id of the organization you want to fetch the usage of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationUsage(tROrganization: string, organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationUsageCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationUsage(tROrganization, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getOrganizationUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Organization Users  Fetch the users of an organization by its id. The auth\'ed user must be an admin or owner of the organization to fetch it.
         * @summary Get Organization Users
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The id of the organization you want to fetch the users of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationUsers(tROrganization: string, organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SlimUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationUsers(tROrganization, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getOrganizationUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Organization  Update an organization. Only the owner of the organization can update it.
         * @summary Update Organization
         * @param {string} tROrganization The organization id to use for the request
         * @param {UpdateOrganizationData} updateOrganizationData The organization data that you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganization(tROrganization: string, updateOrganizationData: UpdateOrganizationData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganization(tROrganization, updateOrganizationData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.updateOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiFp(configuration)
    return {
        /**
         * Create Organization  Create a new organization. The auth\'ed user who creates the organization will be the default owner of the organization.
         * @summary Create Organization
         * @param {CreateOrganizationData} createOrganizationData The organization data that you want to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(createOrganizationData: CreateOrganizationData, options?: any): AxiosPromise<Organization> {
            return localVarFp.createOrganization(createOrganizationData, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Organization  Delete an organization by its id. The auth\'ed user must be an owner of the organization to delete it.
         * @summary Delete Organization
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The id of the organization you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationById(tROrganization: string, organizationId: string, options?: any): AxiosPromise<Organization> {
            return localVarFp.deleteOrganizationById(tROrganization, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Organization  Fetch the details of an organization by its id. The auth\'ed user must be an admin or owner of the organization to fetch it.
         * @summary Get Organization
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The id of the organization you want to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationById(tROrganization: string, organizationId: string, options?: any): AxiosPromise<Organization> {
            return localVarFp.getOrganizationById(tROrganization, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Organization Usage  Fetch the current usage specification of an organization by its id. The auth\'ed user must be an admin or owner of the organization to fetch it.
         * @summary Get Organization Usage
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The id of the organization you want to fetch the usage of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUsage(tROrganization: string, organizationId: string, options?: any): AxiosPromise<OrganizationUsageCount> {
            return localVarFp.getOrganizationUsage(tROrganization, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Organization Users  Fetch the users of an organization by its id. The auth\'ed user must be an admin or owner of the organization to fetch it.
         * @summary Get Organization Users
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} organizationId The id of the organization you want to fetch the users of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUsers(tROrganization: string, organizationId: string, options?: any): AxiosPromise<Array<SlimUser>> {
            return localVarFp.getOrganizationUsers(tROrganization, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Organization  Update an organization. Only the owner of the organization can update it.
         * @summary Update Organization
         * @param {string} tROrganization The organization id to use for the request
         * @param {UpdateOrganizationData} updateOrganizationData The organization data that you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(tROrganization: string, updateOrganizationData: UpdateOrganizationData, options?: any): AxiosPromise<Organization> {
            return localVarFp.updateOrganization(tROrganization, updateOrganizationData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * Create Organization  Create a new organization. The auth\'ed user who creates the organization will be the default owner of the organization.
     * @summary Create Organization
     * @param {CreateOrganizationData} createOrganizationData The organization data that you want to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public createOrganization(createOrganizationData: CreateOrganizationData, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).createOrganization(createOrganizationData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Organization  Delete an organization by its id. The auth\'ed user must be an owner of the organization to delete it.
     * @summary Delete Organization
     * @param {string} tROrganization The organization id to use for the request
     * @param {string} organizationId The id of the organization you want to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public deleteOrganizationById(tROrganization: string, organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).deleteOrganizationById(tROrganization, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Organization  Fetch the details of an organization by its id. The auth\'ed user must be an admin or owner of the organization to fetch it.
     * @summary Get Organization
     * @param {string} tROrganization The organization id to use for the request
     * @param {string} organizationId The id of the organization you want to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationById(tROrganization: string, organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganizationById(tROrganization, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Organization Usage  Fetch the current usage specification of an organization by its id. The auth\'ed user must be an admin or owner of the organization to fetch it.
     * @summary Get Organization Usage
     * @param {string} tROrganization The organization id to use for the request
     * @param {string} organizationId The id of the organization you want to fetch the usage of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationUsage(tROrganization: string, organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganizationUsage(tROrganization, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Organization Users  Fetch the users of an organization by its id. The auth\'ed user must be an admin or owner of the organization to fetch it.
     * @summary Get Organization Users
     * @param {string} tROrganization The organization id to use for the request
     * @param {string} organizationId The id of the organization you want to fetch the users of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationUsers(tROrganization: string, organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganizationUsers(tROrganization, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Organization  Update an organization. Only the owner of the organization can update it.
     * @summary Update Organization
     * @param {string} tROrganization The organization id to use for the request
     * @param {UpdateOrganizationData} updateOrganizationData The organization data that you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateOrganization(tROrganization: string, updateOrganizationData: UpdateOrganizationData, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateOrganization(tROrganization, updateOrganizationData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StripeApi - axios parameter creator
 * @export
 */
export const StripeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel Subscription  Cancel a subscription by its id
         * @summary Cancel Subscription
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} subscriptionId id of the subscription you want to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscription: async (tROrganization: string, subscriptionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('cancelSubscription', 'tROrganization', tROrganization)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('cancelSubscription', 'subscriptionId', subscriptionId)
            const localVarPath = `/api/stripe/subscription/{subscription_id}`
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checkout  Get a direct link to the stripe checkout page for the plan and organization
         * @summary Checkout
         * @param {string} planId id of the plan you want to subscribe to
         * @param {string} organizationId id of the organization you want to subscribe to the plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directToPaymentLink: async (planId: string, organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('directToPaymentLink', 'planId', planId)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('directToPaymentLink', 'organizationId', organizationId)
            const localVarPath = `/api/stripe/payment_link/{plan_id}/{organization_id}`
                .replace(`{${"plan_id"}}`, encodeURIComponent(String(planId)))
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get All Plans  Get a list of all plans
         * @summary Get All Plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPlans: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stripe/plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Subscription Plan  Update a subscription to a new plan
         * @summary Update Subscription Plan
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} subscriptionId id of the subscription you want to update
         * @param {string} planId id of the plan you want to subscribe to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionPlan: async (tROrganization: string, subscriptionId: string, planId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tROrganization' is not null or undefined
            assertParamExists('updateSubscriptionPlan', 'tROrganization', tROrganization)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('updateSubscriptionPlan', 'subscriptionId', subscriptionId)
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('updateSubscriptionPlan', 'planId', planId)
            const localVarPath = `/api/stripe/subscription_plan/{subscription_id}/{plan_id}`
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)))
                .replace(`{${"plan_id"}}`, encodeURIComponent(String(planId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tROrganization != null) {
                localVarHeaderParameter['TR-Organization'] = String(tROrganization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StripeApi - functional programming interface
 * @export
 */
export const StripeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StripeApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel Subscription  Cancel a subscription by its id
         * @summary Cancel Subscription
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} subscriptionId id of the subscription you want to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelSubscription(tROrganization: string, subscriptionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelSubscription(tROrganization, subscriptionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripeApi.cancelSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Checkout  Get a direct link to the stripe checkout page for the plan and organization
         * @summary Checkout
         * @param {string} planId id of the plan you want to subscribe to
         * @param {string} organizationId id of the organization you want to subscribe to the plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async directToPaymentLink(planId: string, organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.directToPaymentLink(planId, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripeApi.directToPaymentLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get All Plans  Get a list of all plans
         * @summary Get All Plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPlans(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StripePlan>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPlans(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripeApi.getAllPlans']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Subscription Plan  Update a subscription to a new plan
         * @summary Update Subscription Plan
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} subscriptionId id of the subscription you want to update
         * @param {string} planId id of the plan you want to subscribe to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubscriptionPlan(tROrganization: string, subscriptionId: string, planId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubscriptionPlan(tROrganization, subscriptionId, planId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripeApi.updateSubscriptionPlan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StripeApi - factory interface
 * @export
 */
export const StripeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StripeApiFp(configuration)
    return {
        /**
         * Cancel Subscription  Cancel a subscription by its id
         * @summary Cancel Subscription
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} subscriptionId id of the subscription you want to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscription(tROrganization: string, subscriptionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelSubscription(tROrganization, subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Checkout  Get a direct link to the stripe checkout page for the plan and organization
         * @summary Checkout
         * @param {string} planId id of the plan you want to subscribe to
         * @param {string} organizationId id of the organization you want to subscribe to the plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directToPaymentLink(planId: string, organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.directToPaymentLink(planId, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get All Plans  Get a list of all plans
         * @summary Get All Plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPlans(options?: any): AxiosPromise<Array<StripePlan>> {
            return localVarFp.getAllPlans(options).then((request) => request(axios, basePath));
        },
        /**
         * Update Subscription Plan  Update a subscription to a new plan
         * @summary Update Subscription Plan
         * @param {string} tROrganization The organization id to use for the request
         * @param {string} subscriptionId id of the subscription you want to update
         * @param {string} planId id of the plan you want to subscribe to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionPlan(tROrganization: string, subscriptionId: string, planId: string, options?: any): AxiosPromise<void> {
            return localVarFp.updateSubscriptionPlan(tROrganization, subscriptionId, planId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StripeApi - object-oriented interface
 * @export
 * @class StripeApi
 * @extends {BaseAPI}
 */
export class StripeApi extends BaseAPI {
    /**
     * Cancel Subscription  Cancel a subscription by its id
     * @summary Cancel Subscription
     * @param {string} tROrganization The organization id to use for the request
     * @param {string} subscriptionId id of the subscription you want to cancel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public cancelSubscription(tROrganization: string, subscriptionId: string, options?: RawAxiosRequestConfig) {
        return StripeApiFp(this.configuration).cancelSubscription(tROrganization, subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checkout  Get a direct link to the stripe checkout page for the plan and organization
     * @summary Checkout
     * @param {string} planId id of the plan you want to subscribe to
     * @param {string} organizationId id of the organization you want to subscribe to the plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public directToPaymentLink(planId: string, organizationId: string, options?: RawAxiosRequestConfig) {
        return StripeApiFp(this.configuration).directToPaymentLink(planId, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get All Plans  Get a list of all plans
     * @summary Get All Plans
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public getAllPlans(options?: RawAxiosRequestConfig) {
        return StripeApiFp(this.configuration).getAllPlans(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Subscription Plan  Update a subscription to a new plan
     * @summary Update Subscription Plan
     * @param {string} tROrganization The organization id to use for the request
     * @param {string} subscriptionId id of the subscription you want to update
     * @param {string} planId id of the plan you want to subscribe to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public updateSubscriptionPlan(tROrganization: string, subscriptionId: string, planId: string, options?: RawAxiosRequestConfig) {
        return StripeApiFp(this.configuration).updateSubscriptionPlan(tROrganization, subscriptionId, planId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TopicApi - axios parameter creator
 * @export
 */
export const TopicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create Topic  Create a new chat topic. Topics are attached to a user and act as a coordinator for memory of gen-AI chat sessions. We are considering refactoring this resource of the API soon.
         * @summary Create Topic
         * @param {string} tRDataset The dataset id to use for the request
         * @param {CreateTopicData} createTopicData JSON request payload to create chat topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTopic: async (tRDataset: string, createTopicData: CreateTopicData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('createTopic', 'tRDataset', tRDataset)
            // verify required parameter 'createTopicData' is not null or undefined
            assertParamExists('createTopic', 'createTopicData', createTopicData)
            const localVarPath = `/api/topic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTopicData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Topic  Delete an existing chat topic. When a topic is deleted, all associated chat messages are also deleted.
         * @summary Delete Topic
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} topicId The id of the topic you want to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTopic: async (tRDataset: string, topicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('deleteTopic', 'tRDataset', tRDataset)
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('deleteTopic', 'topicId', topicId)
            const localVarPath = `/api/topic/{topic_id}`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get All Topics for User  Get all topics belonging to a the auth\'ed user. Soon, we plan to allow specification of the user for this route and include pagination.
         * @summary Get All Topics for User
         * @param {string} userId The id of the user to get topics for
         * @param {string} tRDataset The dataset id to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTopicsForUser: async (userId: string, tRDataset: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAllTopicsForUser', 'userId', userId)
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('getAllTopicsForUser', 'tRDataset', tRDataset)
            const localVarPath = `/api/topic/user/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Topic  Update an existing chat topic. Currently, only the name of the topic can be updated.
         * @summary Update Topic
         * @param {string} tRDataset The dataset id to use for the request
         * @param {UpdateTopicData} updateTopicData JSON request payload to update a chat topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTopic: async (tRDataset: string, updateTopicData: UpdateTopicData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tRDataset' is not null or undefined
            assertParamExists('updateTopic', 'tRDataset', tRDataset)
            // verify required parameter 'updateTopicData' is not null or undefined
            assertParamExists('updateTopic', 'updateTopicData', updateTopicData)
            const localVarPath = `/api/topic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tRDataset != null) {
                localVarHeaderParameter['TR-Dataset'] = String(tRDataset);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTopicData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TopicApi - functional programming interface
 * @export
 */
export const TopicApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TopicApiAxiosParamCreator(configuration)
    return {
        /**
         * Create Topic  Create a new chat topic. Topics are attached to a user and act as a coordinator for memory of gen-AI chat sessions. We are considering refactoring this resource of the API soon.
         * @summary Create Topic
         * @param {string} tRDataset The dataset id to use for the request
         * @param {CreateTopicData} createTopicData JSON request payload to create chat topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTopic(tRDataset: string, createTopicData: CreateTopicData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Topic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTopic(tRDataset, createTopicData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicApi.createTopic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Topic  Delete an existing chat topic. When a topic is deleted, all associated chat messages are also deleted.
         * @summary Delete Topic
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} topicId The id of the topic you want to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTopic(tRDataset: string, topicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTopic(tRDataset, topicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicApi.deleteTopic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get All Topics for User  Get all topics belonging to a the auth\'ed user. Soon, we plan to allow specification of the user for this route and include pagination.
         * @summary Get All Topics for User
         * @param {string} userId The id of the user to get topics for
         * @param {string} tRDataset The dataset id to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTopicsForUser(userId: string, tRDataset: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Topic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTopicsForUser(userId, tRDataset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicApi.getAllTopicsForUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Topic  Update an existing chat topic. Currently, only the name of the topic can be updated.
         * @summary Update Topic
         * @param {string} tRDataset The dataset id to use for the request
         * @param {UpdateTopicData} updateTopicData JSON request payload to update a chat topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTopic(tRDataset: string, updateTopicData: UpdateTopicData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTopic(tRDataset, updateTopicData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicApi.updateTopic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TopicApi - factory interface
 * @export
 */
export const TopicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TopicApiFp(configuration)
    return {
        /**
         * Create Topic  Create a new chat topic. Topics are attached to a user and act as a coordinator for memory of gen-AI chat sessions. We are considering refactoring this resource of the API soon.
         * @summary Create Topic
         * @param {string} tRDataset The dataset id to use for the request
         * @param {CreateTopicData} createTopicData JSON request payload to create chat topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTopic(tRDataset: string, createTopicData: CreateTopicData, options?: any): AxiosPromise<Topic> {
            return localVarFp.createTopic(tRDataset, createTopicData, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Topic  Delete an existing chat topic. When a topic is deleted, all associated chat messages are also deleted.
         * @summary Delete Topic
         * @param {string} tRDataset The dataset id to use for the request
         * @param {string} topicId The id of the topic you want to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTopic(tRDataset: string, topicId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTopic(tRDataset, topicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get All Topics for User  Get all topics belonging to a the auth\'ed user. Soon, we plan to allow specification of the user for this route and include pagination.
         * @summary Get All Topics for User
         * @param {string} userId The id of the user to get topics for
         * @param {string} tRDataset The dataset id to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTopicsForUser(userId: string, tRDataset: string, options?: any): AxiosPromise<Array<Topic>> {
            return localVarFp.getAllTopicsForUser(userId, tRDataset, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Topic  Update an existing chat topic. Currently, only the name of the topic can be updated.
         * @summary Update Topic
         * @param {string} tRDataset The dataset id to use for the request
         * @param {UpdateTopicData} updateTopicData JSON request payload to update a chat topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTopic(tRDataset: string, updateTopicData: UpdateTopicData, options?: any): AxiosPromise<void> {
            return localVarFp.updateTopic(tRDataset, updateTopicData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TopicApi - object-oriented interface
 * @export
 * @class TopicApi
 * @extends {BaseAPI}
 */
export class TopicApi extends BaseAPI {
    /**
     * Create Topic  Create a new chat topic. Topics are attached to a user and act as a coordinator for memory of gen-AI chat sessions. We are considering refactoring this resource of the API soon.
     * @summary Create Topic
     * @param {string} tRDataset The dataset id to use for the request
     * @param {CreateTopicData} createTopicData JSON request payload to create chat topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public createTopic(tRDataset: string, createTopicData: CreateTopicData, options?: RawAxiosRequestConfig) {
        return TopicApiFp(this.configuration).createTopic(tRDataset, createTopicData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Topic  Delete an existing chat topic. When a topic is deleted, all associated chat messages are also deleted.
     * @summary Delete Topic
     * @param {string} tRDataset The dataset id to use for the request
     * @param {string} topicId The id of the topic you want to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public deleteTopic(tRDataset: string, topicId: string, options?: RawAxiosRequestConfig) {
        return TopicApiFp(this.configuration).deleteTopic(tRDataset, topicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get All Topics for User  Get all topics belonging to a the auth\'ed user. Soon, we plan to allow specification of the user for this route and include pagination.
     * @summary Get All Topics for User
     * @param {string} userId The id of the user to get topics for
     * @param {string} tRDataset The dataset id to use for the request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public getAllTopicsForUser(userId: string, tRDataset: string, options?: RawAxiosRequestConfig) {
        return TopicApiFp(this.configuration).getAllTopicsForUser(userId, tRDataset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Topic  Update an existing chat topic. Currently, only the name of the topic can be updated.
     * @summary Update Topic
     * @param {string} tRDataset The dataset id to use for the request
     * @param {UpdateTopicData} updateTopicData JSON request payload to update a chat topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public updateTopic(tRDataset: string, updateTopicData: UpdateTopicData, options?: RawAxiosRequestConfig) {
        return TopicApiFp(this.configuration).updateTopic(tRDataset, updateTopicData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete User Api Key  Delete an api key for the auth\'ed user.
         * @summary Delete User Api Key
         * @param {string} apiKeyId The id of the api key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserApiKey: async (apiKeyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKeyId' is not null or undefined
            assertParamExists('deleteUserApiKey', 'apiKeyId', apiKeyId)
            const localVarPath = `/api/user/api_key/{api_key_id}`
                .replace(`{${"api_key_id"}}`, encodeURIComponent(String(apiKeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set User Api Key  Create a new api key for the auth\'ed user. Successful response will contain the newly created api key. If a write role is assigned the api key will have permission level of the auth\'ed user who calls this endpoint.
         * @summary Set User Api Key
         * @param {SetUserApiKeyRequest} setUserApiKeyRequest JSON request payload to create a new user api key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserApiKey: async (setUserApiKeyRequest: SetUserApiKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setUserApiKeyRequest' is not null or undefined
            assertParamExists('setUserApiKey', 'setUserApiKeyRequest', setUserApiKeyRequest)
            const localVarPath = `/api/user/api_key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setUserApiKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update User  Update a user\'s information. If the user_id is not provided, the auth\'ed user will be updated. If the user_id is provided, the auth\'ed user must be an admin (1) or owner (2) of the organization.
         * @summary Update User
         * @param {UpdateUserData} updateUserData JSON request payload to update user information for the auth\&#39;ed user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (updateUserData: UpdateUserData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserData' is not null or undefined
            assertParamExists('updateUser', 'updateUserData', updateUserData)
            const localVarPath = `/api/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete User Api Key  Delete an api key for the auth\'ed user.
         * @summary Delete User Api Key
         * @param {string} apiKeyId The id of the api key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserApiKey(apiKeyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiKeyDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserApiKey(apiKeyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.deleteUserApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set User Api Key  Create a new api key for the auth\'ed user. Successful response will contain the newly created api key. If a write role is assigned the api key will have permission level of the auth\'ed user who calls this endpoint.
         * @summary Set User Api Key
         * @param {SetUserApiKeyRequest} setUserApiKeyRequest JSON request payload to create a new user api key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserApiKey(setUserApiKeyRequest: SetUserApiKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetUserApiKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserApiKey(setUserApiKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.setUserApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update User  Update a user\'s information. If the user_id is not provided, the auth\'ed user will be updated. If the user_id is provided, the auth\'ed user must be an admin (1) or owner (2) of the organization.
         * @summary Update User
         * @param {UpdateUserData} updateUserData JSON request payload to update user information for the auth\&#39;ed user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(updateUserData: UpdateUserData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SlimUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(updateUserData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Delete User Api Key  Delete an api key for the auth\'ed user.
         * @summary Delete User Api Key
         * @param {string} apiKeyId The id of the api key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserApiKey(apiKeyId: string, options?: any): AxiosPromise<Array<ApiKeyDTO>> {
            return localVarFp.deleteUserApiKey(apiKeyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Set User Api Key  Create a new api key for the auth\'ed user. Successful response will contain the newly created api key. If a write role is assigned the api key will have permission level of the auth\'ed user who calls this endpoint.
         * @summary Set User Api Key
         * @param {SetUserApiKeyRequest} setUserApiKeyRequest JSON request payload to create a new user api key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserApiKey(setUserApiKeyRequest: SetUserApiKeyRequest, options?: any): AxiosPromise<SetUserApiKeyResponse> {
            return localVarFp.setUserApiKey(setUserApiKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update User  Update a user\'s information. If the user_id is not provided, the auth\'ed user will be updated. If the user_id is provided, the auth\'ed user must be an admin (1) or owner (2) of the organization.
         * @summary Update User
         * @param {UpdateUserData} updateUserData JSON request payload to update user information for the auth\&#39;ed user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(updateUserData: UpdateUserData, options?: any): AxiosPromise<SlimUser> {
            return localVarFp.updateUser(updateUserData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Delete User Api Key  Delete an api key for the auth\'ed user.
     * @summary Delete User Api Key
     * @param {string} apiKeyId The id of the api key to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUserApiKey(apiKeyId: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteUserApiKey(apiKeyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set User Api Key  Create a new api key for the auth\'ed user. Successful response will contain the newly created api key. If a write role is assigned the api key will have permission level of the auth\'ed user who calls this endpoint.
     * @summary Set User Api Key
     * @param {SetUserApiKeyRequest} setUserApiKeyRequest JSON request payload to create a new user api key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public setUserApiKey(setUserApiKeyRequest: SetUserApiKeyRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).setUserApiKey(setUserApiKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update User  Update a user\'s information. If the user_id is not provided, the auth\'ed user will be updated. If the user_id is provided, the auth\'ed user must be an admin (1) or owner (2) of the organization.
     * @summary Update User
     * @param {UpdateUserData} updateUserData JSON request payload to update user information for the auth\&#39;ed user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(updateUserData: UpdateUserData, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUser(updateUserData, options).then((request) => request(this.axios, this.basePath));
    }
}



